<!DOCTYPE html>
<html lang="tr">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Programlama Dilleri - 9</title>
  <style>
    body { font-family: 'PT Sans', 'Trebuchet MS', sans-serif; background: #f9f9f9; padding: 20px; color: #333; }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .question-container { background: #fff; padding: 20px; margin-bottom: 25px; border-left: 5px solid #007BFF; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-text { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; }
    .option { padding: 10px; margin: 8px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; transition: background-color 0.2s ease-in-out; }
    .option:hover { background: #e9ecef; }
    .option.selected { background-color: #cce5ff; border-color: #b8daff; }
    .feedback { margin-top: 15px; padding: 12px; border-radius: 4px; display: none; font-weight: bold; }
    .correct { background: #d4edda; border-left: 5px solid #28a745; color: #155724; }
    .incorrect { background: #f8d7da; border-left: 5px solid #dc3545; color: #721c24; }
    .summary { display: none; background: #fff3cd; padding: 12px; margin-top: 10px; border-left: 5px solid #ffc107; border-radius: 4px; color: #856404; }
    button#submit-all {
        display: block;
        margin: 30px auto;
        padding: 12px 25px;
        font-size: 1.1em;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    button#submit-all:hover {
        background-color: #218838;
    }
    .results { margin-top: 30px; padding: 20px; background-color: #e9ecef; border-radius: 5px; text-align: center;}
  </style>
</head>
<body>
<h1>Programlama Dilleri - 9</h1>
<div id="quiz">
  </div>
<button id="submit-all" onclick="showResults()">TÃ¼m Testi Bitir ve SonuÃ§larÄ± GÃ¶r</button>
<div id="results-summary" class="results" style="display:none;">
    <h2>Test Sonucu</h2>
    <p>Toplam Soru: <span id="total-questions"></span></p>
    <p>DoÄŸru Cevap SayÄ±sÄ±: <span id="correct-answers"></span></p>
    <p>BaÅŸarÄ± YÃ¼zdesi: <span id="score-percentage"></span>%</p>
</div>

<script>
  const questions = [
{
  q: "1. BaÅŸka veri tipleri aracÄ±lÄ±ÄŸÄ±yla tanÄ±mlanmayan ve bir dilin temel yapÄ± taÅŸÄ± olan veri tiplerine ne ad verilir?",
  options: [
    ["YapÄ±sal Veri Tipleri", "YapÄ±sal tipler, tam tersine, diÄŸer tiplerin bir araya gelmesiyle oluÅŸur (Ã¶rn: diziler)."],
    ["KullanÄ±cÄ± TanÄ±mlÄ± Tipler", "Bu, ilkel tiplerden yola Ã§Ä±karak oluÅŸturulan yeni tipler olabilir, ancak temel kategori deÄŸildir."],
    ["Ä°lkel (Primitive) Veri Tipleri", "Ä°lkel tipler, bir dilin en temel, bÃ¶lÃ¼nemeyen veri tÃ¼rleridir. SayÄ±lar, karakterler ve mantÄ±ksal deÄŸerler bu gruba girer."],
    ["SÄ±ralÄ± Tipler (Ordinal Types)", "SÄ±ralÄ± tipler, ilkel tiplerin bir alt kÃ¼mesidir."],
    ["Ä°liÅŸkili Tipler (Associative Types)", "Bu, iliÅŸkili dizilerle ilgili bir kavramdÄ±r."]
  ],
  answer: 2,
  summary: "Ä°lkel tipler, bir programlama dilinin 'atomlarÄ±' gibidir; daha kÃ¼Ã§Ã¼k parÃ§alara ayrÄ±lamazlar ve diÄŸer tÃ¼m karmaÅŸÄ±k veri yapÄ±larÄ± bu temel tipler Ã¼zerine inÅŸa edilir."
},
{
  q: "2. Bir programlama dilinde, `type gunler = (Pazartesi, Sali, Carsamba, Persembe, Cuma, Cumartesi, Pazar)` ÅŸeklinde bir tanÄ±m yapÄ±lmasÄ±, hangi tÃ¼r veri tipi oluÅŸturmaya bir Ã¶rnektir?",
  options: [
    ["Altalan (Subrange) Tipi", "Altalan tipi, var olan bir tipin bir alt aralÄ±ÄŸÄ±nÄ± alÄ±r (Ã¶rn: 1..5)."],
    ["SayÄ±mlama (Enumeration) Tipi", "SayÄ±mlama tipi, bir tipin alabileceÄŸi tÃ¼m olasÄ± deÄŸerlerin sembolik isimlerle listelenerek kullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanmasÄ±nÄ± saÄŸlar. Bu, programÄ±n okunabilirliÄŸini ve gÃ¼venilirliÄŸini artÄ±rÄ±r."],
    ["KayÄ±t (Record) Tipi", "KayÄ±t tipi, farklÄ± tÃ¼rlerden alanlarÄ± bir araya getirir."],
    ["Ä°liÅŸkili Dizi (Associative Array)", "Ä°liÅŸkili dizi, anahtar-deÄŸer Ã§iftleriyle indekslenir."],
    ["Ä°lkel Tip (Primitive Type)", "Bu, kullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan yeni bir tiptir, ilkel deÄŸildir."]
  ],
  answer: 1,
  summary: "SayÄ±mlama tipleri, programdaki 'sihirli sayÄ±larÄ±' (magic numbers) ortadan kaldÄ±rÄ±r. `if (gun == 1)` gibi bir kod yerine, `if (gun == Pazartesi)` gibi Ã§ok daha anlaÅŸÄ±lÄ±r ve hataya daha az aÃ§Ä±k bir kod yazmayÄ± saÄŸlar."
},
{
  q: "3. OndalÄ±klÄ± sayÄ±larÄ± temsil eden `float` ve `double` veri tipleri arasÄ±ndaki temel fark nedir?",
  options: [
    ["float tamsayÄ±larÄ±, double ondalÄ±klÄ± sayÄ±larÄ± saklar.", "Bu yanlÄ±ÅŸtÄ±r, her ikisi de ondalÄ±klÄ± sayÄ±larÄ± saklar."],
    ["double, float'a gÃ¶re daha yÃ¼ksek hassasiyet sunar ve genellikle daha fazla bellek kullanÄ±r.", "Temel fark budur. `double` (Ã§ift hassasiyet), ondalÄ±klÄ± kÄ±sÄ±mdaki basamak sayÄ±sÄ±nÄ± daha doÄŸru bir ÅŸekilde saklamak iÃ§in `float`'a gÃ¶re genellikle daha fazla bellek kullanÄ±r."],
    ["float sadece pozitif, double sadece negatif sayÄ±larÄ± saklar.", "Bu yanlÄ±ÅŸtÄ±r, her ikisi de iÅŸaretli sayÄ±lar saklayabilir."],
    ["float C dilinde, double ise Java'da kullanÄ±lÄ±r.", "Bu yanlÄ±ÅŸtÄ±r, Ã§oÄŸu modern dil her iki tipi de destekler."],
    ["AralarÄ±nda iÅŸlevsel olarak hiÃ§bir fark yoktur.", "AralarÄ±nda hassasiyet ve bellek kullanÄ±mÄ± aÃ§Ä±sÄ±ndan Ã¶nemli bir fark vardÄ±r."]
  ],
  answer: 1,
  summary: "`double`, ismindeki 'Ã§ift' kelimesinden de anlaÅŸÄ±labileceÄŸi gibi, `float`'a kÄ±yasla daha fazla ondalÄ±k basamak hassasiyeti gerektiren bilimsel veya finansal hesaplamalar iÃ§in kullanÄ±lÄ±r. Bu daha yÃ¼ksek hassasiyetin bedeli, daha fazla bellek kullanÄ±mÄ±dÄ±r."
},
{
  q: "4. Bir sÄ±ralÄ± tipin (ordinal type) kesintisiz bir alt grubunu temsil eden ve ilk olarak Pascal dilinde tanÄ±tÄ±lan veri tipine ne ad verilir?",
  options: [
    ["SayÄ±mlama (Enumeration) Tipi", "SayÄ±mlama tipi, deÄŸerleri listeleyerek yeni bir tip oluÅŸturur."],
    ["Karakter (Char) Tipi", "Karakter tipi sÄ±ralÄ± bir tiptir, ancak bir alt grup deÄŸildir."],
    ["Altalan (Subrange) Tipi", "Altalan tipi, `type Notlar = 0..100` gibi, var olan bir sÄ±ralÄ± tipin belirli bir aralÄ±ÄŸÄ±nÄ± alarak yeni ve daha kÄ±sÄ±tlÄ± bir tip tanÄ±mlar."],
    ["Dizi (Array) Tipi", "Dizi, elemanlardan oluÅŸan bir koleksiyondur."],
    ["Ä°lkel Tip (Primitive Type)", "Bu genel bir kategoridir."]
  ],
  answer: 2,
  summary: "Altalan tipleri, programÄ±n gÃ¼venilirliÄŸini artÄ±ran Ã¶nemli bir mekanizmadÄ±r. Bir deÄŸiÅŸkeni '0..100' aralÄ±ÄŸÄ±nda tanÄ±mladÄ±ÄŸÄ±nÄ±zda, derleyici o deÄŸiÅŸkene 101 gibi geÃ§ersiz bir deÄŸer atanmasÄ±nÄ± engelleyerek potansiyel bir hatayÄ± daha oluÅŸmadan Ã¶nler."
},
{
  q: "5. Karakter dizgilerinin uzunluklarÄ±nÄ±n yÃ¶netimi konusunda, C ve C++ gibi dillerin, tanÄ±mlanan sabit bir uzunluÄŸa kadar deÄŸiÅŸen uzunlukta olmasÄ±na izin veren yaklaÅŸÄ±mÄ±na ne ad verilir?",
  options: [
    ["DuraÄŸan Uzunluk (Static Length)", "Bu yaklaÅŸÄ±mda dizginin uzunluÄŸu derleme zamanÄ±nda sabitlenir ve deÄŸiÅŸtirilemez."],
    ["DeÄŸiÅŸen Uzunluk (Ã¼st sÄ±nÄ±r var)", "PL/I, C ve C++ gibi diller bu yaklaÅŸÄ±mÄ± benimser. Bir maksimum boyut belirlenir ancak dizgi bu boyuttan daha kÄ±sa olabilir."],
    ["DeÄŸiÅŸen Uzunluk (Ã¼st sÄ±nÄ±r yok)", "Bu yaklaÅŸÄ±m, dinamik bellek yÃ¶netimi olan dillerde gÃ¶rÃ¼lÃ¼r ve en esnek yÃ¶ntemdir."],
    ["SÄ±fÄ±rla SonlandÄ±rÄ±lmÄ±ÅŸ Uzunluk", "Bu, C'nin deÄŸiÅŸen uzunluÄŸu (Ã¼st sÄ±nÄ±rla) gerÃ§ekleÅŸtirme yÃ¶ntemidir, yaklaÅŸÄ±mÄ±n kendisi deÄŸildir."],
    ["Dinamik Bellek YÃ¶netimi", "Bu, bir tekniktir, Ã¼Ã§ ana yaklaÅŸÄ±mdan birinin adÄ± deÄŸildir."]
  ],
  answer: 1,
  summary: "Karakter dizgilerinin uzunluklarÄ± Ã¼Ã§ farklÄ± stratejiyle yÃ¶netilebilir: Tamamen sabit (DuraÄŸan), bir tavana kadar esnek (DeÄŸiÅŸen Uzunluk - Ã¼st sÄ±nÄ±r var) veya tamamen esnek (DeÄŸiÅŸen Uzunluk - Ã¼st sÄ±nÄ±r yok). C/C++ ikinci yaklaÅŸÄ±mÄ± kullanÄ±r."
},
{
  q: "6. AÅŸaÄŸÄ±daki ilkel veri tiplerinden hangisi 'sÄ±ralÄ± (ordinal)' bir tip deÄŸildir?",
  options: [
    ["TamsayÄ± (Integer)", "TamsayÄ±lar sÄ±ralÄ±dÄ±r (her tamsayÄ±nÄ±n bir ardÄ±lÄ± ve Ã¶nceli vardÄ±r)."],
    ["Karakter (Char)", "Karakterler ASCII/Unicode tablosundaki sÄ±ralarÄ±na gÃ¶re sÄ±ralÄ±dÄ±r."],
    ["MantÄ±ksal (Boolean)", "MantÄ±ksal tip genellikle (FALSE, TRUE) olarak sÄ±ralÄ± kabul edilir."],
    ["OndalÄ±klÄ± SayÄ± (Float/Double)", "OndalÄ±klÄ± sayÄ±lar sÄ±ralÄ± bir tip deÄŸildir, Ã§Ã¼nkÃ¼ iki ondalÄ±klÄ± sayÄ± arasÄ±nda her zaman sonsuz sayÄ±da baÅŸka ondalÄ±klÄ± sayÄ± bulunur. Yani bir sayÄ±nÄ±n 'bir sonraki' ondalÄ±klÄ± sayÄ± diye bir ardÄ±lÄ± yoktur."],
    ["SayÄ±mlama Tipi (Enumeration Type)", "SayÄ±mlama tipleri, tanÄ±mlandÄ±klarÄ± sÄ±raya gÃ¶re sÄ±ralÄ±dÄ±r."]
  ],
  answer: 3,
  summary: "Bir tipin 'sÄ±ralÄ±' olmasÄ±, o tipin deÄŸerleri arasÄ±nda net bir 'Ã¶nceki' ve 'sonraki' iliÅŸkisi kurulabilmesi anlamÄ±na gelir. Bu Ã¶zellik, `FOR` dÃ¶ngÃ¼lerinde sayaÃ§ olarak veya dizilerde indis olarak kullanÄ±labilmeleri iÃ§in Ã¶nemlidir. OndalÄ±klÄ± sayÄ±larda bu net ardÄ±llÄ±k iliÅŸkisi yoktur."
},
{
  q: "7. AÅŸaÄŸÄ±dakilerden hangisi ilkel sayÄ±sal veri tiplerinden biri deÄŸildir?",
  options: [
    ["TamsayÄ± (Integer)", "Bu, ilkel sayÄ±sal veri tiplerinden biridir."],
    ["Kayan NoktalÄ± (Floating Point)", "Bu, ilkel sayÄ±sal veri tiplerinden biridir."],
    ["Onlu (Decimal)", "Bu, ilkel sayÄ±sal veri tiplerinden biridir."],
    ["MantÄ±ksal (Boolean)", "MantÄ±ksal tip, 'true' veya 'false' deÄŸerlerini alÄ±r ve sayÄ±sal bir tip olarak sÄ±nÄ±flandÄ±rÄ±lmaz."],
    ["HiÃ§biri", "Listede sayÄ±sal olmayan bir tip bulunmaktadÄ±r."]
  ],
  answer: 3,
  summary: "Ä°lkel veri tipleri kendi iÃ§inde SayÄ±sal, MantÄ±ksal, Karakter gibi gruplara ayrÄ±lÄ±r. TamsayÄ±, Kayan NoktalÄ± ve Onlu tipler 'SayÄ±sal' grubuna aittir. MantÄ±ksal tip ise ayrÄ± bir kategoridir."
},
{
  q: "8. BirÃ§ok programlama dilinde, MantÄ±ksal (Boolean) bir deÄŸerin saklanmasÄ± iÃ§in 1 bit yeterli olmasÄ±na raÄŸmen neden genellikle 1 baytlÄ±k (8 bit) bir bellek alanÄ± kullanÄ±lÄ±r?",
  options: [
    ["Ã‡Ã¼nkÃ¼ 1 bitlik deÄŸere 8 farklÄ± durum sÄ±ÄŸdÄ±rÄ±labilir.", "1 bit sadece 2 durum sÄ±ÄŸdÄ±rabilir."],
    ["Bellekteki tek bir bite doÄŸrudan eriÅŸmenin verimsiz ve zor olmasÄ± nedeniyle", "Modern bilgisayar mimarilerinde bellek, genellikle baytlar halinde adreslenir. Sadece tek bir biti okumak veya yazmak iÃ§in tÃ¼m baytÄ± alÄ±p Ã¼zerinde maskeleme iÅŸlemleri yapmak gerekir. Bu ek iÅŸlemlerden kaÃ§Ä±nmak iÃ§in, kullanÄ±m kolaylÄ±ÄŸÄ± ve verimlilik adÄ±na genellikle en kÃ¼Ã§Ã¼k adreslenebilir birim olan 1 bayt kullanÄ±lÄ±r."],
    ["DiÄŸer 7 bitin hata kontrolÃ¼ iÃ§in kullanÄ±lmasÄ± nedeniyle", "Bu, aÄŸ protokollerinde gÃ¶rÃ¼len bir tekniktir, genel boolean saklama iÃ§in geÃ§erli deÄŸildir."],
    ["Gelecekte `true` ve `false` dÄ±ÅŸÄ±nda yeni mantÄ±ksal deÄŸerler eklenebileceÄŸi iÃ§in", "MantÄ±ksal cebir iki temel deÄŸere dayanÄ±r."],
    ["Bu tamamen rastgele bir tasarÄ±m kararÄ±dÄ±r.", "HayÄ±r, donanÄ±m mimarisinden kaynaklanan pratik bir sebebi vardÄ±r."]
  ],
  answer: 1,
  summary: "Bu durum, 'teorik minimum' ile 'pratik verimlilik' arasÄ±ndaki bir Ã¶dÃ¼nleÅŸmedir. Teoride 1 bit yetsin de, pratikte bilgisayarÄ±n en rahat Ã§alÄ±ÅŸtÄ±ÄŸÄ± birim olan 1 baytÄ± kullanmak daha hÄ±zlÄ± ve kolaydÄ±r. Bu, 7 bitlik bir alanÄ±n boÅŸa harcanmasÄ± anlamÄ±na gelse de, hÄ±z kazancÄ± bu israfÄ± telafi eder."
},
{
  q: "9. Karakter dizgi (string) veri tipi iÃ§in aÅŸaÄŸÄ±dakilerden hangisi sÃ¶ylenemez?",
  options: [
    ["BazÄ± dillerde ilkel bir veri tipi olarak yer alÄ±r.", "FORTRAN77 ve BASIC gibi dillerde karakter dizgiler ilkel bir tiptir."],
    ["BazÄ± dillerde tek karakterlerden oluÅŸan bir dizi olarak ele alÄ±nÄ±r.", "Pascal, C ve C++ gibi dillerde bu yaklaÅŸÄ±m benimsenmiÅŸtir."],
    ["UzunluklarÄ± statik veya dinamik olabilir.", "FarklÄ± diller, dizgi uzunluklarÄ± iÃ§in farklÄ± stratejiler (sabit, sÄ±nÄ±rla-deÄŸiÅŸken, sÄ±nÄ±rsÄ±z-deÄŸiÅŸken) uygular."],
    ["TÃ¼m modern dillerde sadece ilkel bir veri tipi olarak bulunur.", "Bu ifade yanlÄ±ÅŸtÄ±r. Ã–rneÄŸin C++ ve Java gibi modern dillerde hem ilkel dizi yaklaÅŸÄ±mÄ± hem de daha geliÅŸmiÅŸ 'String' nesneleri bulunur."],
    ["Nesneleri, karakterler dizisidir.", "Bu, karakter dizgi veri tipinin temel tanÄ±mÄ±dÄ±r."]
  ],
  answer: 3,
  summary: "Karakter dizgilerinin nasÄ±l ele alÄ±ndÄ±ÄŸÄ±, bir dilin tasarÄ±m felsefesi hakkÄ±nda ipuÃ§larÄ± verir. Eski diller onu daha Ã§ok ilkel bir yapÄ± olarak gÃ¶rÃ¼rken, C gibi diller belleÄŸe daha yakÄ±n bir bakÄ±ÅŸ aÃ§Ä±sÄ±yla onu bir karakter dizisi olarak ele almÄ±ÅŸ, Java gibi daha modern diller ise onu gÃ¼Ã§lÃ¼ metotlara sahip bir nesne haline getirmiÅŸtir."
},
{
  q: "10. MantÄ±ksal (Boolean) veri tipinin yer almadÄ±ÄŸÄ± ve bu iÅŸlevi tamsayÄ±lar (0 ve 1) ile gÃ¶ren programlama dili hangisidir?",
  options: [
    ["Pascal", "Pascal, ALGOL 60'Ä± takip ederek `Boolean` tipini destekler."],
    ["Java", "Java, `boolean` adÄ±nda Ã¶zel bir ilkel tipe sahiptir."],
    ["C", "C dilinde ayrÄ± bir mantÄ±ksal tip yoktur. Ä°liÅŸkisel ifadeler doÄŸru ise 1, yanlÄ±ÅŸ ise 0 deÄŸeri dÃ¶ndÃ¼rÃ¼r ve `if` deyimi 0 deÄŸerini yanlÄ±ÅŸ, sÄ±fÄ±r dÄ±ÅŸÄ±ndaki tÃ¼m deÄŸerleri ise doÄŸru kabul eder."],
    ["Ada", "Ada, `Boolean` adÄ±nda bir tipe sahiptir."],
    ["ALGOL 60", "MantÄ±ksal veri tipi ilk olarak ALGOL 60 tarafÄ±ndan tanÄ±tÄ±lmÄ±ÅŸtÄ±r."]
  ],
  answer: 2,
  summary: "C dilinin bu kendine Ã¶zgÃ¼ yaklaÅŸÄ±mÄ±, onu hem esnek hem de bazen kafa karÄ±ÅŸtÄ±rÄ±cÄ± yapar. `if(sayi)` gibi bir ifade, `if(sayi != 0)` anlamÄ±na gelir. Bu, diÄŸer dillerden gelen programcÄ±lar iÃ§in alÄ±ÅŸÄ±lmasÄ± gereken bir durumdur."
},
{
  q: "11. C dilinde `char sehir[] = \"Ankara\";` ÅŸeklinde tanÄ±mlanan bir karakter dizisinin bellekte kaÃ§ elemanlÄ±k (kaÃ§ bayt) yer kapladÄ±ÄŸÄ± sÃ¶ylenebilir?",
  options: [
    ["5", "'Ankara' kelimesi 6 harflidir, 5 deÄŸil."],
    ["6", "C dilinde karakter dizgileri, dizinin sonunu belirten Ã¶zel bir 'null' karakteri (ASCII kodu 0 olan karakter) ile sona erdirilir. Bu nedenle 6 harflik 'Ankara' kelimesi, sondaki null karakteriyle birlikte bellekte 7 elemanlÄ±k yer kaplar."],
    ["7", "Bu doÄŸru cevaptÄ±r. 'Ankara' 6 karakterdir, artÄ± 1 de null karakteri iÃ§in ayrÄ±lÄ±r."],
    ["8", "Bu hatalÄ± bir hesaplamadÄ±r."],
    ["Derleyiciye baÄŸlÄ± olarak deÄŸiÅŸir.", "C standardÄ±na gÃ¶re bu durum nettir."]
  ],
  answer: 2,
  summary: "C'de bir metnin nerede bittiÄŸini anlamak iÃ§in Ã¶zel bir 'bitiÅŸ iÅŸareti' kullanÄ±lÄ±r. Bu iÅŸaret, gÃ¶rÃ¼nmez olan null karakteridir. Bu nedenle C'de bir metni saklamak iÃ§in her zaman metnin uzunluÄŸundan bir bayt daha fazla yere ihtiyaÃ§ duyulur."
},
{
  q: "12. AÅŸaÄŸÄ±dakilerden hangisi bir 'SÄ±ralÄ± Tip (Ordinal Type)' olarak kabul edilir?",
  options: [
    ["`float`", "OndalÄ±klÄ± sayÄ±lar sÄ±ralÄ± deÄŸildir."],
    ["`double`", "OndalÄ±klÄ± sayÄ±lar sÄ±ralÄ± deÄŸildir."],
    ["`string`", "Metinlerin sÄ±ralamasÄ± (alfabetik) mÃ¼mkÃ¼n olsa da, genellikle temel bir sÄ±ralÄ± tip olarak kabul edilmezler."],
    ["`char`", "Karakterler (char), temel aldÄ±klarÄ± karakter tablosundaki (Ã¶rn: ASCII) sayÄ±sal kodlarÄ±na gÃ¶re net bir sÄ±ralamaya sahiptir. 'A' dan sonra 'B' gelir. Bu yÃ¼zden sÄ±ralÄ± bir tiptir."],
    ["`array`", "Dizi, bir veri yapÄ±sÄ±dÄ±r, bir veri tipi deÄŸildir."]
  ],
  answer: 3,
  summary: "Bir tipin 'sÄ±ralÄ±' olmasÄ±, o tipin her bir deÄŸeri iÃ§in bir 'Ã¶nceki' ve 'sonraki' deÄŸerin net bir ÅŸekilde tanÄ±mlanabilmesi demektir. Bu Ã¶zellik, `FOR` dÃ¶ngÃ¼lerinde `FOR c='A' TO 'Z'` gibi yapÄ±larÄ±n kurulabilmesine olanak tanÄ±r."
},
{
  q: "13. Karakter dizgi (string) veri tipinin, ilkel bir veri tipi olarak kabul edildiÄŸi diller arasÄ±nda aÅŸaÄŸÄ±dakilerden hangisi yer alÄ±r?",
  options: [
    ["C++", "C++'da karakter dizgileri, karakterlerden oluÅŸan diziler ve Ã¶zel 'string' sÄ±nÄ±flarÄ± olarak ele alÄ±nÄ±r."],
    ["Pascal", "Pascal'da karakter dizgileri, tek karakterlerden oluÅŸan diziler ÅŸeklinde saklanÄ±r."],
    ["Ada", "Ada'da karakter dizgileri, tek karakterlerden oluÅŸan diziler ÅŸeklinde saklanÄ±r."],
    ["FORTRAN 90", "FORTRAN77, FORTRAN 90 ve BASIC gibi dillerde karakter dizgileri, kendine has iÅŸlemcileri olan ilkel bir veri tipi olarak kabul edilir."],
    ["C", "C'de karakter dizgileri, null karakteriyle sonlanan bir karakter dizisi olarak ele alÄ±nÄ±r."]
  ],
  answer: 3,
  summary: "Programlama dilleri, metinleri (string) ele almak iÃ§in farklÄ± yaklaÅŸÄ±mlar benimser. BASIC ve FORTRAN gibi diller, metni temel bir yapÄ± taÅŸÄ± (ilkel tip) olarak gÃ¶rÃ¼rken; C ve Pascal gibi diller metni, karakterlerin bir araya geldiÄŸi bir koleksiyon (dizi) olarak gÃ¶rÃ¼r."
},
{
  q: "14. SayÄ±mlama (Enumeration) tiplerinin programlara saÄŸladÄ±ÄŸÄ± en Ã¶nemli fayda nedir?",
  options: [
    ["ProgramÄ±n Ã§alÄ±ÅŸma hÄ±zÄ±nÄ± artÄ±rmak", "DoÄŸrudan bir hÄ±z artÄ±ÅŸÄ± saÄŸlamaz."],
    ["Bellek kullanÄ±mÄ±nÄ± azaltmak", "Genellikle bellek kullanÄ±mÄ±na Ã¶nemli bir etkisi yoktur."],
    ["OkunabilirliÄŸi ve gÃ¼venilirliÄŸi artÄ±rmak", "SayÄ±sal kodlar (0, 1, 2) yerine anlamlÄ± isimler (Kirmizi, Yesil, Mavi) kullanÄ±lmasÄ±nÄ± saÄŸlayarak kodun okunmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r ve geÃ§ersiz bir deÄŸer atanmasÄ±nÄ± engelleyerek gÃ¼venilirliÄŸi artÄ±rÄ±r."],
    ["Daha karmaÅŸÄ±k matematiksel hesaplamalar yapmayÄ± saÄŸlamak", "Bu bir faydasÄ± deÄŸildir."],
    ["Sadece tamsayÄ±larla Ã§alÄ±ÅŸmayÄ± zorunlu kÄ±lmak", "TamsayÄ±larÄ±n yerine geÃ§en isimler sunar."]
  ],
  answer: 2,
  summary: "SayÄ±mlama tipleri, kodu kendi kendine 'belgeleyen' bir yapÄ±ya kavuÅŸturur. `if (trafik_isigi == 0)` yerine `if (trafik_isigi == Kirmizi)` yazmak, kodun amacÄ±nÄ± anÄ±nda aÃ§Ä±klar ve olasÄ± mantÄ±k hatalarÄ±nÄ± azaltÄ±r."
},
{
  q: "15. C dilindeki `enum` yapÄ±sÄ±nÄ±n, Pascal'daki `type` deyiminden temel farkÄ± nedir?",
  options: [
    ["C'deki `enum` yeni bir tip yaratÄ±rken, Pascal'daki `type` yaratmaz.", "Tam tersi doÄŸrudur."],
    ["C'deki `enum` yapÄ±sÄ± gerÃ§ek anlamda yeni bir tip yaratmaz, sadece bir dizi isimlendirilmiÅŸ tamsayÄ± sabiti oluÅŸturur.", "Pascal'da bir sayÄ±mlama tipi tanÄ±mladÄ±ÄŸÄ±nÄ±zda, o tipe sadece tanÄ±mladÄ±ÄŸÄ±nÄ±z deÄŸerleri atayabilirsiniz. C'de ise `enum` ile oluÅŸturulan isimler aslÄ±nda birer tamsayÄ±dÄ±r (0, 1, 2...) ve tip denetimi daha zayÄ±ftÄ±r."],
    ["C'deki `enum` sadece karakterler iÃ§in, Pascal'daki `type` ise sadece sayÄ±lar iÃ§in kullanÄ±lÄ±r.", "Bu yanlÄ±ÅŸtÄ±r."],
    ["Ä°kisi arasÄ±nda iÅŸlevsel olarak hiÃ§bir fark yoktur.", "AralarÄ±nda tip gÃ¼venliÄŸi aÃ§Ä±sÄ±ndan Ã¶nemli bir felsefe farkÄ± vardÄ±r."],
    ["C'deki `enum` daha az okunabilirdir.", "Tam tersine, `define` kullanÄ±mÄ±na gÃ¶re daha okunabilir bir alternatif olarak sunulmuÅŸtur."]
  ],
  answer: 1,
  summary: "C'nin `enum`'u, bir dizi `#define` komutunu daha dÃ¼zenli bir ÅŸekilde bir araya getirme kolaylÄ±ÄŸÄ± saÄŸlar. Pascal'Ä±n `type`'Ä± ise derleyicinin katÄ± kurallar uyguladÄ±ÄŸÄ±, tamamen yeni ve gÃ¼venli bir veri tipi yaratÄ±r. Pascal'Ä±n yaklaÅŸÄ±mÄ± daha gÃ¼venilir, C'nin yaklaÅŸÄ±mÄ± ise daha esnektir."
},
{
  q: "16. Ä°lkel sayÄ±sal veri tipleri hangi Ã¼Ã§ temel tÃ¼rden oluÅŸur?",
  options: [
    ["short, int, long", "Bunlar tamsayÄ± tipinin alt tÃ¼rleridir."],
    ["tamsayÄ±, kayan noktalÄ± ve onlu", "Ä°lkel sayÄ±sal tipler genel olarak bu Ã¼Ã§ kategoriye ayrÄ±lÄ±r: tam sayÄ±lar (integer), kesirli sayÄ±lar (floating point) ve finansal hesaplamalar iÃ§in onlu sayÄ±lar (decimal)."],
    ["char, byte, int", "Char ve byte her zaman sayÄ±sal tip olarak kabul edilmez."],
    ["boolean, integer, float", "Boolean sayÄ±sal bir tip deÄŸildir."],
    ["ASCII, Unicode, UTF-8", "Bunlar karakter kodlama standartlarÄ±dÄ±r."]
  ],
  answer: 1,
  summary: "Programlama dilleri, farklÄ± sayÄ±sal ihtiyaÃ§lar iÃ§in farklÄ± Ã§Ã¶zÃ¼mler sunar. Genel tam sayÄ±lar, bilimsel/mÃ¼hendislik hassasiyeti gerektiren ondalÄ±klÄ± sayÄ±lar ve finansal doÄŸruluk gerektiren onlu sayÄ±lar bu Ã§Ã¶zÃ¼mlerin temelini oluÅŸturur."
},
{
  q: "17. `float` ve `double` gibi veri tipleri, ne tÃ¼r sayÄ±larÄ± temsil etmek iÃ§in kullanÄ±lÄ±r?",
  options: [
    ["Sadece pozitif tamsayÄ±larÄ±", "TamsayÄ±lar iÃ§in `integer` gibi tipler kullanÄ±lÄ±r."],
    ["GerÃ§el (reel) sayÄ±larÄ±, yani ondalÄ±klÄ± kÄ±smÄ± olan sayÄ±larÄ±", "Bu tipler, 3.14, -0.005, 2.5e6 gibi tam olmayan, kesirli veya bilimsel gÃ¶sterimle ifade edilen sayÄ±larÄ± temsil etmek iÃ§in kullanÄ±lÄ±r."],
    ["Sadece negatif tamsayÄ±larÄ±", "TamsayÄ±lar iÃ§in `integer` gibi tipler kullanÄ±lÄ±r."],
    ["KarmaÅŸÄ±k sayÄ±larÄ±", "KarmaÅŸÄ±k sayÄ±larÄ± temsil etmek iÃ§in genellikle Ã¶zel kÃ¼tÃ¼phaneler veya yapÄ±lar (records) gerekir."],
    ["DoÄŸal sayÄ±larÄ±", "DoÄŸal sayÄ±lar, pozitif tamsayÄ±lardÄ±r."]
  ],
  answer: 1,
  summary: "Programlamada bir Ã¶lÃ§Ã¼mÃ¼n sonucunu, bir ortalamayÄ± veya herhangi bir kesirli deÄŸeri saklamak istediÄŸinizde, `float` veya `double` gibi ondalÄ±klÄ± sayÄ± tiplerini kullanÄ±rsÄ±nÄ±z."
},
{
  q: "18. C dilinde `char` ve `int` veri tiplerinin dÃ¶nÃ¼ÅŸÃ¼mlÃ¼ olarak kullanÄ±labilmesi ne anlama gelir?",
  options: [
    ["`char` tipi `int` tipinden daha fazla yer kaplar.", "Tam tersine, `int` daha fazla yer kaplar."],
    ["Bu iki tip arasÄ±nda atama yapÄ±lamaz.", "YapÄ±labilir, Ã¶rnekte de gÃ¶sterilmiÅŸtir."],
    ["Bir karaktere sayÄ±sal bir deÄŸer eklenerek baÅŸka bir karakter elde edilebilir.", "C'de her karakterin bir ASCII sayÄ±sal karÅŸÄ±lÄ±ÄŸÄ± olduÄŸu iÃ§in, `'A' + 1` iÅŸlemi, ASCII tablosunda 'A'dan sonra gelen karakter olan 'B'yi verir. Bu, `char` ve `int` arasÄ±ndaki esnek geÃ§iÅŸkenliÄŸi gÃ¶sterir."],
    ["TÃ¼m tamsayÄ±lar aynÄ± zamanda birer karakterdir.", "Bu doÄŸru bir ifade deÄŸildir."],
    ["Bu Ã¶zellik sadece Pascal dilinde geÃ§erlidir.", "Bu Ã¶zellik C dilinde belirgindir."]
  ],
  answer: 2,
  summary: "C'nin donanÄ±ma yakÄ±n felsefesi, karakterleri aslÄ±nda kÃ¼Ã§Ã¼k tamsayÄ±lar olarak gÃ¶rmesine neden olur. Bu durum, karakterler Ã¼zerinde aritmetik iÅŸlemler yapma gibi esnek ama aynÄ± zamanda dikkatli kullanÄ±lmasÄ± gereken imkanlar sunar."
},
{
  q: "19. Karakter dizilerinin uzunluÄŸunun derleme zamanÄ±nda belirlendiÄŸi ve sonradan deÄŸiÅŸtirilemediÄŸi yaklaÅŸÄ±m hangisidir?",
  options: [
    ["DeÄŸiÅŸen Uzunluk (Ã¼st sÄ±nÄ±r var)", "Bu yaklaÅŸÄ±mda uzunluk Ã§alÄ±ÅŸma zamanÄ±nda deÄŸiÅŸebilir."],
    ["DeÄŸiÅŸen Uzunluk (Ã¼st sÄ±nÄ±r yok)", "Bu yaklaÅŸÄ±mda uzunluk tamamen dinamiktir."],
    ["DuraÄŸan Uzunluk (Static Length)", "FORTRAN 77, COBOL ve Pascal gibi dillerde kullanÄ±lan bu yaklaÅŸÄ±mda, bir karakter dizisi tanÄ±mlanÄ±rken uzunluÄŸu belirtilir ve bu uzunluk program boyunca sabit kalÄ±r."],
    ["SÄ±fÄ±rla SonlandÄ±rma (Null Termination)", "Bu, C'nin kullandÄ±ÄŸÄ± bir tekniktir ve deÄŸiÅŸen uzunluÄŸa (Ã¼st sÄ±nÄ±rla) izin verir."],
    ["Dinamik Bellek YÃ¶netimi", "Bu, genellikle deÄŸiÅŸen uzunluklu dizgiler iÃ§in gereken bir tekniktir."]
  ],
  answer: 2,
  summary: "DuraÄŸan uzunluklu karakter dizgileri, bellek yÃ¶netimi aÃ§Ä±sÄ±ndan verimli olsalar da esnek deÄŸildirler. Ã–rneÄŸin, 20 karakterlik bir alana 5 karakterlik bir metin atadÄ±ÄŸÄ±nÄ±zda, geri kalan 15 karakterlik alan boÅŸa harcanmÄ±ÅŸ olur."
},
{
  q: "20. C'deki `enum renkler {kirmizi, yesil, mavi}` tanÄ±mÄ±nda, `yesil` isminin karÅŸÄ±lÄ±k geldiÄŸi tamsayÄ± deÄŸeri nedir?",
  options: [
    ["0", "`kirmizi`'nÄ±n karÅŸÄ±lÄ±k geldiÄŸi deÄŸerdir."],
    ["1", "Bir `enum` listesinde, eÄŸer Ã¶zel bir deÄŸer atanmamÄ±ÅŸsa, ilk eleman 0 deÄŸerini alÄ±r ve sonraki her eleman bir artarak devam eder. Bu nedenle `yesil` 1 deÄŸerine karÅŸÄ±lÄ±k gelir."],
    ["2", "`mavi`'nin karÅŸÄ±lÄ±k geldiÄŸi deÄŸerdir."],
    ["'yesil'", "Bu bir karakter dizisidir, tamsayÄ± deÄŸeri deÄŸildir."],
    ["TanÄ±msÄ±zdÄ±r, bir deÄŸeri yoktur.", "HayÄ±r, varsayÄ±lan bir tamsayÄ± deÄŸeri vardÄ±r."]
  ],
  answer: 1,
  summary: "C dilindeki `enum` yapÄ±sÄ±, aslÄ±nda derleyiciye 'bu isimleri ÅŸu tamsayÄ±larla deÄŸiÅŸtir' diyen bir komut setidir. VarsayÄ±lan olarak 0'dan baÅŸlar ve birer birer artar. Bu, kodda sayÄ±lar yerine anlamlÄ± isimler kullanmayÄ± saÄŸlayan pratik bir yÃ¶ntemdir."
},
{
  q: "21. Bir dizinin indis tipi olarak aÅŸaÄŸÄ±dakilerden hangisi genellikle kullanÄ±lamaz?",
  options: [
    ["TamsayÄ± (Integer)", "Bu en yaygÄ±n indis tipidir."],
    ["Karakter (Char)", "Karakterler sÄ±ralÄ± bir tip olduÄŸu iÃ§in bazÄ± dillerde indis olarak kullanÄ±labilir."],
    ["MantÄ±ksal (Boolean)", "Boolean (TRUE/FALSE) sÄ±ralÄ± bir tip olduÄŸu iÃ§in bazÄ± dillerde (Ã¶rn: 0 ve 1 olarak) indis olarak kullanÄ±labilir."],
    ["OndalÄ±klÄ± SayÄ± (Float)", "OndalÄ±klÄ± sayÄ±lar sÄ±ralÄ± bir tip olmadÄ±ÄŸÄ± iÃ§in (Ã¶rn: 1.5 ile 1.6 arasÄ±nda sonsuz sayÄ± vardÄ±r), bir dizinin '1.5'inci elemanÄ±' gibi bir kavram anlamsÄ±zdÄ±r. Bu nedenle indis olarak kullanÄ±lamazlar."],
    ["SayÄ±mlama Tipi (Enumeration)", "SayÄ±mlama tipleri de sÄ±ralÄ± olduÄŸu iÃ§in indis olarak kullanÄ±labilir."]
  ],
  answer: 3,
  summary: "Bir dizinin indisleri, elemanlarÄ±n net bir sÄ±rasÄ±nÄ± belirtmelidir. Bu nedenle, sadece 'bir sonraki' deÄŸeri net olarak bilinen sÄ±ralÄ± (ordinal) tipler indis olarak kullanÄ±labilir. TamsayÄ±lar bu iÅŸ iÃ§in en doÄŸal seÃ§imdir."
},
{
  q: "22. Bir dilin, programcÄ±ya `type Notlar = 0..100` gibi bir altalan tipi tanÄ±mlama imkanÄ± vermesinin en Ã¶nemli faydasÄ± nedir?",
  options: [
    ["ProgramÄ±n daha esnek olmasÄ±nÄ± saÄŸlamak", "Tam tersine, deÄŸiÅŸkenin alabileceÄŸi deÄŸerleri kÄ±sÄ±tlayarak esnekliÄŸi azaltÄ±r ama gÃ¼venilirliÄŸi artÄ±rÄ±r."],
    ["ProgramÄ±n gÃ¼venilirliÄŸini artÄ±rmak", "Bir `Notlar` deÄŸiÅŸkenine yanlÄ±ÅŸlÄ±kla `101` deÄŸerinin atanmasÄ±, derleyici tarafÄ±ndan bir hata olarak algÄ±lanabilir. Bu tÃ¼r otomatik kontroller, programdaki mantÄ±k hatalarÄ±nÄ± azaltÄ±r."],
    ["ProgramÄ±n daha hÄ±zlÄ± derlenmesini saÄŸlamak", "Derleme sÃ¼resine Ã¶nemli bir etkisi yoktur, hatta ek kontroller nedeniyle bir miktar artÄ±rabilir."],
    ["Daha az bellek kullanÄ±lmasÄ±nÄ± saÄŸlamak", "Genellikle temel tiple aynÄ± miktarda bellek kullanÄ±r."],
    ["TÃ¼m dillerde bu Ã¶zelliÄŸin standart olmasÄ±", "Bu Ã¶zellik her dilde bulunmaz, Ã¶zellikle Pascal ile popÃ¼ler olmuÅŸtur."]
  ],
  answer: 1,
  summary: "Altalan tipleri, bir deÄŸiÅŸkene 'sÄ±nÄ±rlarÄ±nÄ± bilmesini' Ã¶ÄŸretir. ProgramcÄ±, bir deÄŸiÅŸkenin sadece belirli bir aralÄ±kta deÄŸer almasÄ± gerektiÄŸini biliyorsa, bu kuralÄ± derleyiciye bildirerek, bu kuralÄ±n ihlal edildiÄŸi durumlarÄ±n otomatik olarak tespit edilmesini saÄŸlayabilir."
},
{
  q: "23. C dilinde karakter dizilerinin sonunu belirtmek iÃ§in kullanÄ±lan Ã¶zel karaktere ne ad verilir?",
  options: [
    ["BoÅŸluk Karakteri (' ')", "BoÅŸluk, metnin iÃ§inde yer alabilen normal bir karakterdir."],
    ["SÄ±fÄ±rla gÃ¶sterilen Ã¶zel karakter (null)", "C, bir karakter dizisinin bittiÄŸi yeri anlamak iÃ§in dizinin sonuna ASCII kodu 0 olan ve `\\0` ile gÃ¶sterilen bir 'null' karakteri ekler."],
    ["SatÄ±r Sonu Karakteri (\\n)", "Bu, yeni bir satÄ±ra geÃ§meyi saÄŸlayan bir karakterdir."],
    ["Tab Karakteri (\\t)", "Bu, metin iÃ§inde boÅŸluk bÄ±rakmayÄ± saÄŸlayan bir karakterdir."],
    ["YÄ±ldÄ±z Karakteri (*)", "Bu bir operatÃ¶r veya normal bir karakter olabilir."]
  ],
  answer: 1,
  summary: "C'nin null ile sonlandÄ±rma tekniÄŸi, 'DeÄŸiÅŸen Uzunluk (Ã¼st sÄ±nÄ±r var)' yaklaÅŸÄ±mÄ±nÄ± verimli bir ÅŸekilde uygular. Bellekte 100 karakterlik yer ayrÄ±lmÄ±ÅŸ olsa bile, metin 5 karakter uzunluÄŸundaysa 6. karaktere null konularak metnin orada bittiÄŸi anlaÅŸÄ±lÄ±r."
},
{
  q: "24. MantÄ±ksal (boolean) veri tipini ilk olarak tanÄ±tan programlama dili hangisidir?",
  options: [
    ["C", "C dilinde Ã¶zel bir boolean tipi yoktur."],
    ["FORTRAN", "Ä°lk FORTRAN sÃ¼rÃ¼mlerinde boolean tipi bulunmuyordu."],
    ["Pascal", "Pascal, boolean tipini destekler ancak ilk tanÄ±tan dil deÄŸildir."],
    ["Java", "Java, boolean tipini destekler ancak ilk tanÄ±tan dil deÄŸildir."],
    ["ALGOL 60", "Modern programlama dillerindeki birÃ§ok yapÄ±sal Ã¶zelliÄŸin temelini atan ALGOL 60, `true` ve `false` deÄŸerlerini alabilen mantÄ±ksal veri tipini de ilk olarak tanÄ±tan dildir."]
  ],
  answer: 4,
  summary: "MantÄ±ksal veri tipi, `if` gibi koÅŸullu ifadelerin temelini oluÅŸturur. ALGOL 60'Ä±n bu tipi dile resmi olarak dahil etmesi, programlarÄ±n daha okunabilir ve yapÄ±sal olarak daha doÄŸru kurulabilmesi iÃ§in atÄ±lmÄ±ÅŸ Ã¶nemli bir adÄ±mdÄ±."
},
{
  q: "25. `short`, `int` ve `long` gibi tanÄ±mlamalar, hangi ilkel veri tipinin farklÄ± boyut ve deÄŸer aralÄ±klarÄ±na sahip alt tÃ¼rleridir?",
  options: [
    ["OndalÄ±klÄ± SayÄ±", "Bunlar ondalÄ±klÄ± sayÄ±larÄ±n alt tÃ¼rleri deÄŸildir (`float`, `double` gibi)."],
    ["TamsayÄ±", "Bu Ã¼Ã§Ã¼ de, farklÄ± bÃ¼yÃ¼klÃ¼kteki tamsayÄ±larÄ± daha verimli bir ÅŸekilde saklamak iÃ§in oluÅŸturulmuÅŸ tamsayÄ± tipinin alt kategorileridir. KÃ¼Ã§Ã¼k bir sayÄ± iÃ§in `long` kullanmak bellek israfÄ± olabilir."],
    ["Karakter", "Bunlar karakterlerin alt tÃ¼rleri deÄŸildir."],
    ["MantÄ±ksal", "MantÄ±ksal tipin genellikle alt tÃ¼rÃ¼ yoktur."],
    ["Katar", "Bunlar metinsel tipler deÄŸildir."]
  ],
  answer: 1,
  summary: "ProgramcÄ±lar, bellek kullanÄ±mÄ±nÄ± optimize etmek iÃ§in saklayacaklarÄ± tamsayÄ±nÄ±n bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne en uygun tipi seÃ§erler. Bir Ã¶ÄŸrencinin yaÅŸÄ±nÄ± saklamak iÃ§in `short` yeterliyken, bir Ã¼lkenin nÃ¼fusunu saklamak iÃ§in `long` gerekebilir. Bu, 'doÄŸru iÅŸ iÃ§in doÄŸru aleti kullanmak' gibidir."
}    
  ];

  const quizDiv = document.getElementById('quiz');
  const optionLabels = ['A)', 'B)', 'C)', 'D)', 'E)'];
  const userAnswers = new Array(questions.length).fill(null);


  questions.forEach((qObj, index) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'question-container';
    questionContainer.id = `question-${index}`;

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = qObj.q;
    questionContainer.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options-group';

    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback';
    feedbackDiv.style.display = 'none'; // Initially hidden

    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'summary';
    summaryDiv.style.display = 'none'; // Initially hidden


    qObj.options.forEach((opt, i) => {
      const optDiv = document.createElement('div');
      optDiv.className = 'option';
      optDiv.textContent = `${optionLabels[i]} ${opt[0]}`;
      optDiv.onclick = () => {
        // Clear previous selection visuals for this question
        const allOptsInGroup = optsDiv.querySelectorAll('.option');
        allOptsInGroup.forEach(el => el.classList.remove('selected'));
        optDiv.classList.add('selected'); // Mark as selected

        userAnswers[index] = i; // Store user's answer

        // Show feedback immediately
        const feedbackText = opt[1] || (i === qObj.answer ? "DoÄŸru cevap!" : "YanlÄ±ÅŸ cevap."); // Fallback feedback
        feedbackDiv.className = 'feedback ' + (i === qObj.answer ? 'correct' : 'incorrect');
        feedbackDiv.style.display = 'block';
        feedbackDiv.textContent = (i === qObj.answer ? 'âœ”ï¸ DoÄŸru: ' : 'âŒ YanlÄ±ÅŸ: ') + feedbackText;


        if (i === qObj.answer && qObj.summary) {
          summaryDiv.style.display = 'block';
          summaryDiv.textContent = 'ðŸ’¡ ' + qObj.summary;
        } else {
          summaryDiv.style.display = 'none';
        }
      };
      optsDiv.appendChild(optDiv);
    });

    questionContainer.appendChild(optsDiv);
    questionContainer.appendChild(feedbackDiv);
    questionContainer.appendChild(summaryDiv);
    quizDiv.appendChild(questionContainer);
  });

  function showResults() {
    let correctCount = 0;
    userAnswers.forEach((answer, index) => {
        if (answer !== null && answer === questions[index].answer) {
            correctCount++;
        }
    });

    const totalQuestions = questions.length;
    const scorePercentage = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(2) : 0;

    document.getElementById('total-questions').textContent = totalQuestions;
    document.getElementById('correct-answers').textContent = correctCount;
    document.getElementById('score-percentage').textContent = scorePercentage;
    document.getElementById('results-summary').style.display = 'block';

    // Scroll to results
    document.getElementById('results-summary').scrollIntoView({ behavior: 'smooth' });
  }

</script>
</body>
</html>