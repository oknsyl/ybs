<!DOCTYPE html>
<html lang="tr">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Programlama Dilleri - 7</title>
  <style>
    body { font-family: 'PT Sans', 'Trebuchet MS', sans-serif; background: #f9f9f9; padding: 20px; color: #333; }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .question-container { background: #fff; padding: 20px; margin-bottom: 25px; border-left: 5px solid #007BFF; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-text { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; }
    .option { padding: 10px; margin: 8px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; transition: background-color 0.2s ease-in-out; }
    .option:hover { background: #e9ecef; }
    .option.selected { background-color: #cce5ff; border-color: #b8daff; }
    .feedback { margin-top: 15px; padding: 12px; border-radius: 4px; display: none; font-weight: bold; }
    .correct { background: #d4edda; border-left: 5px solid #28a745; color: #155724; }
    .incorrect { background: #f8d7da; border-left: 5px solid #dc3545; color: #721c24; }
    .summary { display: none; background: #fff3cd; padding: 12px; margin-top: 10px; border-left: 5px solid #ffc107; border-radius: 4px; color: #856404; }
    button#submit-all {
        display: block;
        margin: 30px auto;
        padding: 12px 25px;
        font-size: 1.1em;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    button#submit-all:hover {
        background-color: #218838;
    }
    .results { margin-top: 30px; padding: 20px; background-color: #e9ecef; border-radius: 5px; text-align: center;}
  </style>
</head>
<body>
<h1>Programlama Dilleri - 7</h1>
<div id="quiz">
  </div>
<button id="submit-all" onclick="showResults()">TÃ¼m Testi Bitir ve SonuÃ§larÄ± GÃ¶r</button>
<div id="results-summary" class="results" style="display:none;">
    <h2>Test Sonucu</h2>
    <p>Toplam Soru: <span id="total-questions"></span></p>
    <p>DoÄŸru Cevap SayÄ±sÄ±: <span id="correct-answers"></span></p>
    <p>BaÅŸarÄ± YÃ¼zdesi: <span id="score-percentage"></span>%</p>
</div>

<script>
  const questions = [
{
  q: "1. Bilgisayar biliminde 1 Kilobayt'Ä±n, metrik sistemdeki gibi 1000 birim deÄŸil de 1024 bayt olarak kabul edilmesinin temel sebebi nedir?",
  options: [
    ["Ä°lk bilgisayarlarÄ±n belleÄŸinin 1024 bayt olmasÄ±", "Bu tarihsel bir tesadÃ¼f deÄŸildir, teknik bir sebebi vardÄ±r."],
    ["ASCII tablosunun 1024 karakter iÃ§ermesi", "ASCII tablosu 256 karakter iÃ§erir ve bu 8 bitlik bayt kavramÄ±yla ilgilidir."],
    ["Bilgisayardaki bÃ¼tÃ¼n veri saklama Ã¼nitelerinin kapasitesinin 2'nin kuvvetleri ile Ã¶lÃ§Ã¼lmesi", "Bilgisayarlar ikilik tabanda Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in, depolama birimleri 2'nin kuvvetleri olarak ifade edilir. 1000'e en yakÄ±n 2'nin kuvveti 2^10 = 1024 olduÄŸu iÃ§in bu deÄŸer standart kabul edilmiÅŸtir."],
    ["UluslararasÄ± Standartlar Ã–rgÃ¼tÃ¼'nÃ¼n (ISO) bu ÅŸekilde karar vermesi", "ISO bu standardÄ± onaylamÄ±ÅŸtÄ±r ancak standardÄ±n temelindeki neden matematikseldir."],
    ["Veri aktarÄ±m hÄ±zlarÄ±nÄ±n bu sayÄ±nÄ±n katlarÄ± olmasÄ±", "Veri aktarÄ±m hÄ±zlarÄ± da bu temel Ã¼zerine kuruludur, sebep bu deÄŸildir."]
  ],
  answer: 2,
  summary: "Bilgisayar dÃ¼nyasÄ±nda her ÅŸey ikilik taban ve 2'nin kuvvetleri etrafÄ±nda dÃ¶ner. Depolama birimleri de bu kurala uyar. 1 Kilobayt = 2^10 Bayt = 1024 Bayt'tÄ±r."
},
{
  q: "2. `SAYAÃ‡ = SAYAÃ‡ + 1` gibi bir deÄŸer aktarma ifadesinin programlamada geÃ§erli ve anlamlÄ± olmasÄ±nÄ±n sebebi nedir?",
  options: [
    ["Matematiksel olarak bir sayÄ±nÄ±n bir fazlasÄ±nÄ±n kendisine eÅŸit olabilmesi", "Bu matematiksel olarak imkansÄ±zdÄ±r, programlamadaki anlamÄ± farklÄ±dÄ±r."],
    ["DeÄŸer aktarma iÅŸleminin saÄŸdan sola doÄŸru gerÃ§ekleÅŸtirilmesi", "Program, Ã¶nce saÄŸ taraftaki `SAYAÃ‡ + 1` iÅŸlemini yapar, yeni bir sonuÃ§ bulur ve bu sonucu sol taraftaki `SAYAÃ‡` deÄŸiÅŸkeninin eski deÄŸerinin Ã¼zerine yazar. Bu nedenle iÅŸlem geÃ§erlidir."],
    ["`SAYAÃ‡` deÄŸiÅŸkeninin bir sabit olmasÄ±", "EÄŸer `SAYAÃ‡` bir sabit olsaydÄ± bu iÅŸlem geÃ§ersiz olurdu."],
    ["`=` sembolÃ¼nÃ¼n mantÄ±ksal eÅŸitlik anlamÄ±na gelmesi", "EÄŸer mantÄ±ksal eÅŸitlik olsaydÄ± bu ifade her zaman 'yanlÄ±ÅŸ' sonucunu verirdi."],
    ["Bu ifadenin sadece dÃ¶ngÃ¼ler iÃ§inde kullanÄ±labilmesi", "Bu ifade dÃ¶ngÃ¼lerde sÄ±kÃ§a kullanÄ±lsa da, herhangi bir yerde kullanÄ±labilir."]
  ],
  answer: 1,
  summary: "DeÄŸer aktarma (`=`), bir matematiksel eÅŸitlik deÄŸil, bir 'kopyala ve Ã¼zerine yaz' eylemidir. SaÄŸ taraf her zaman Ã¶nce hesaplanÄ±r. Bu kural, sayaÃ§larÄ± artÄ±rma ve azaltma gibi programlamadaki en temel iÅŸlemlerin temelini oluÅŸturur."
},
{
  q: "3. Bir bayt'Ä±n (byte) 8 bit olarak standartlaÅŸmasÄ±nÄ±n arkasÄ±ndaki temel neden nedir?",
  options: [
    ["1 baytÄ±n 8 farklÄ± rakamÄ± temsil edebilmesi", "Bu doÄŸru bir neden deÄŸildir."],
    ["Ä°lk iÅŸlemcilerin 8 Ã§ekirdekli olmasÄ±", "Bu ilgisiz bir bilgidir."],
    ["Herhangi bir karakteri (harf, rakam, sembol) kodlamak iÃ§in en fazla 8 bit'e ihtiyaÃ§ duyulmasÄ±", "Ä°lk standart karakter tablosu olan ASCII'de 256 karakter bulunur. 256 sayÄ±sÄ±, 2^8'e eÅŸittir ve bu sayÄ±yÄ± ikilik tabanda yazmak iÃ§in tam olarak 8 bit (`11111111` = 255) gerekir. Bu nedenle 8 bit, bir karakteri saklamak iÃ§in standart birim haline gelmiÅŸtir."],
    ["Bir tamsayÄ±yÄ± (integer) saklamak iÃ§in 8 bitin yeterli olmasÄ±", "Standart bir tamsayÄ± genellikle 16 veya 32 bit gerektirir."],
    ["Ä°nsan parmaklarÄ±nÄ±n sayÄ±sÄ±yla ilgili olmasÄ±", "Bu onluk taban iÃ§in geÃ§erli bir aÃ§Ä±klamadÄ±r, ikilik taban iÃ§in deÄŸil."]
  ],
  answer: 2,
  summary: "Klavyedeki her bir harf, rakam ve sembolÃ¼n bilgisayar tarafÄ±ndan anlaÅŸÄ±lmasÄ± iÃ§in sayÄ±sal bir koda ihtiyacÄ± vardÄ±r. ASCII tablosu bu kodlarÄ± iÃ§erir ve bu tablodaki en bÃ¼yÃ¼k kodu (255) saklamak iÃ§in 8 bitlik bir alan yeterlidir. Bu pratik ihtiyaÃ§, 1 Bayt = 8 Bit standardÄ±nÄ± doÄŸurmuÅŸtur."
},
{
  q: "4. A ve B adÄ±nda iki deÄŸiÅŸkenin deÄŸerlerini karÅŸÄ±lÄ±klÄ± olarak deÄŸiÅŸtirmek (takas etmek) iÃ§in Ã¼Ã§Ã¼ncÃ¼ bir C deÄŸiÅŸkeni kullanÄ±ldÄ±ÄŸÄ±nda, izlenmesi gereken doÄŸru adÄ±mlar hangisidir?",
  options: [
    ["`A = B; B = A;`", "Bu adÄ±mlar sonucunda A'nÄ±n orijinal deÄŸeri kaybolur ve her iki deÄŸiÅŸken de B'nin orijinal deÄŸerine sahip olur."],
    ["`C = A; B = A; A = C;`", "Bu adÄ±mlarda B'nin deÄŸeri yanlÄ±ÅŸ atanÄ±r."],
    ["`A = B; B = C; C = A;`", "Bu adÄ±mlarda A'nÄ±n deÄŸeri en baÅŸta kaybolur."],
    ["`C = A; A = B; B = C;`", "Ã–nce A'nÄ±n deÄŸeri C'de yedeklenir. Sonra B'nin deÄŸeri A'ya atanÄ±r (A artÄ±k B'nin deÄŸerine sahiptir). Son olarak C'de yedeklenen orijinal A'nÄ±n deÄŸeri B'ye atanÄ±r. Bu, doÄŸru takas iÅŸlemidir."],
    ["`C = B; A = C; B = A;`", "Bu adÄ±mlar sonucunda da deÄŸiÅŸkenler yanlÄ±ÅŸ deÄŸerlere sahip olur."]
  ],
  answer: 3,
  summary: "Ä°ki dolu bardaÄŸÄ±n iÃ§indeki sÄ±vÄ±larÄ± deÄŸiÅŸtirmek iÃ§in Ã¼Ã§Ã¼ncÃ¼ bir boÅŸ bardaÄŸa ihtiyaÃ§ duyulmasÄ± gibi, iki deÄŸiÅŸkenin deÄŸerini kaybetmeden takas etmek iÃ§in de genellikle Ã¼Ã§Ã¼ncÃ¼ bir geÃ§ici deÄŸiÅŸkene ihtiyaÃ§ duyulur. Bu, programlamadaki en klasik algoritmalardan biridir."
},
{
  q: "5. PHP gibi 'GevÅŸek TÃ¼rlÃ¼ (Loosely Typed)' bir programlama dilinin en belirgin Ã¶zelliÄŸi nedir?",
  options: [
    ["TÃ¼m deÄŸiÅŸkenlerin kullanÄ±lmadan Ã¶nce mutlaka bir tÃ¼r belirtilerek deklare edilmesi gerekir.", "Bu, C veya Java gibi 'KatÄ± TÃ¼rlÃ¼ (Strongly Typed)' dillerin bir Ã¶zelliÄŸidir."],
    ["DeÄŸiÅŸkenlerin tÃ¼rÃ¼, ilk deÄŸer aktarÄ±mÄ± sÄ±rasÄ±nda otomatik olarak belirlenir ve sonradan deÄŸiÅŸtirilemez.", "TÃ¼r sonradan da deÄŸiÅŸtirilebilir."],
    ["DeÄŸiÅŸkenlerin kullanÄ±lmadan Ã¶nce deklare edilmesi zorunluluÄŸu yoktur ve tÃ¼rleri Ã§alÄ±ÅŸma zamanÄ±nda deÄŸiÅŸebilir.", "GevÅŸek tÃ¼rlÃ¼ dillerde, bir deÄŸiÅŸkene Ã¶nce sayÄ±, sonraki bir adÄ±mda ise metin atayabilirsiniz. DeÄŸiÅŸkenin tÃ¼rÃ¼, iÃ§ine atanan deÄŸere gÃ¶re dinamik olarak deÄŸiÅŸir."],
    ["Sadece metin (string) ve tamsayÄ± (integer) tÃ¼rÃ¼nde deÄŸiÅŸkenlere izin verir.", "HayÄ±r, diÄŸer veri tÃ¼rlerini de desteklerler."],
    ["YazdÄ±ÄŸÄ±nÄ±z kodun her zaman daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar.", "Dinamik tipleme, genellikle Ã§alÄ±ÅŸma zamanÄ±nda ek kontrollere neden olduÄŸu iÃ§in performansÄ± bir miktar dÃ¼ÅŸÃ¼rebilir."]
  ],
  answer: 2,
  summary: "GevÅŸek tipleme, programcÄ±ya esneklik ve daha hÄ±zlÄ± kod yazma imkanÄ± sunar. Ancak, deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼n beklenmedik bir ÅŸekilde deÄŸiÅŸmesi fark edilmesi zor hatalara yol aÃ§abileceÄŸi iÃ§in dikkatli kullanÄ±lmalÄ±dÄ±r."
},
{
  q: "6. BilgisayarlarÄ±n dÃ¼nyayÄ± doÄŸru (true) ve yanlÄ±ÅŸ (false) deÄŸerlerinden ibaret gÃ¶rmesi ve tÃ¼m iÅŸlemlerini bu iki deÄŸerin ikilik tabandaki karÅŸÄ±lÄ±klarÄ± olan hangi rakamlar Ã¼zerine kurmasÄ±dÄ±r?",
  options: [
    ["1 ve 2", "Ä°kilik taban sadece 0 ve 1'i kullanÄ±r."],
    ["0 ve 1", "BilgisayarÄ±n temel mantÄ±ÄŸÄ± elektriÄŸin 'var' (1) veya 'yok' (0) olmasÄ± durumuna dayanÄ±r. Bu iki durum, sÄ±rasÄ±yla doÄŸru (true) ve yanlÄ±ÅŸ (false) mantÄ±ksal deÄŸerlerine karÅŸÄ±lÄ±k gelir."],
    ["T ve F", "Bunlar 'true' ve 'false' kelimelerinin kÄ±saltmalarÄ±dÄ±r, sistemin kullandÄ±ÄŸÄ± temel rakamlar deÄŸildir."],
    ["10 ve 01", "Bunlar ikilik tabanda yazÄ±lmÄ±ÅŸ sayÄ±lardÄ±r, temel rakamlar deÄŸildir."],
    ["-1 ve 1", "Bu da yaygÄ±n bir gÃ¶sterim deÄŸildir."]
  ],
  answer: 1,
  summary: "Ä°nsanlarÄ±n on parmaÄŸÄ±na dayalÄ± onluk sistemi gibi, bilgisayarlar da elektriksel anahtarlarÄ±n 'aÃ§Ä±k' veya 'kapalÄ±' olma durumuna dayalÄ± ikilik bir sistem Ã¼zerine kurulmuÅŸtur. TÃ¼m karmaÅŸÄ±k iÅŸlemler, bu basit 0 ve 1'lerin milyarlarcasÄ±nÄ±n bir araya gelmesiyle gerÃ§ekleÅŸir."
},
{
  q: "7. AÅŸaÄŸÄ±dakilerden hangisi 'Ä°lkel (primitive)' bir veri tÃ¼rÃ¼ deÄŸildir?",
  options: [
    ["TamsayÄ± (Integer)", "Bu, en temel ilkel tÃ¼rlerden biridir."],
    ["OndalÄ±k SayÄ± (Float)", "Bu, ilkel bir veri tipidir."],
    ["Karakter (Char)", "Bu, tek bir karakteri temsil eden ilkel bir tiptir."],
    ["Dizi (Array)", "Dizi, aynÄ± tÃ¼rden birden Ã§ok veriyi bir arada tutan bir 'BileÅŸik (composite)' veri tÃ¼rÃ¼dÃ¼r."],
    ["Long", "Long, daha bÃ¼yÃ¼k tamsayÄ±larÄ± ifade eden bir ilkel tamsayÄ± tÃ¼rÃ¼ Ã§eÅŸididir."]
  ],
  answer: 3,
  summary: "Ä°lkel tÃ¼rler, tek bir veri parÃ§asÄ±nÄ± temsil eder (bir sayÄ±, bir harf gibi). BileÅŸik tÃ¼rler ise birden Ã§ok veri parÃ§asÄ±nÄ± bir araya getiren yapÄ±lardÄ±r (bir grup sayÄ±, bir grup harf gibi)."
},
{
  q: "8. Sabitler ve deÄŸiÅŸkenler arasÄ±ndaki en temel fark nedir?",
  options: [
    ["Sabitler sayÄ±sal, deÄŸiÅŸkenler metinsel deÄŸerler tutar.", "Her ikisi de farklÄ± tÃ¼rlerde deÄŸerler tutabilir."],
    ["DeÄŸiÅŸkenlerin deÄŸeri programÄ±n Ã§alÄ±ÅŸmasÄ± sÄ±rasÄ±nda deÄŸiÅŸebilirken, sabitlerin deÄŸeri deÄŸiÅŸtirilemez.", "Bu, ikisi arasÄ±ndaki temel ve tanÄ±msal farktÄ±r. Bir sabit tanÄ±mlandÄ±ÄŸÄ±nda, deÄŸeri program sonlanana kadar kilitlenir."],
    ["Sabitler bellekte daha az yer kaplar.", "Genellikle aynÄ± tÃ¼rdeki bir deÄŸiÅŸkenle aynÄ± yeri kaplarlar."],
    ["DeÄŸiÅŸkenler programÄ±n baÅŸÄ±nda, sabitler ise sonunda tanÄ±mlanÄ±r.", "Tam tersine, sabitler genellikle programÄ±n baÅŸÄ±nda tanÄ±mlanÄ±r."],
    ["Sabitlerin bir ismi varken, deÄŸiÅŸkenlerin yoktur.", "Her ikisinin de bir ismi vardÄ±r."]
  ],
  answer: 1,
  summary: "Sabitler ve deÄŸiÅŸkenler, programda veri saklamak iÃ§in kullanÄ±lan isimlendirilmiÅŸ bellek alanlarÄ±dÄ±r. AralarÄ±ndaki tek ve en Ã¶nemli fark, deÄŸiÅŸkenlerin iÃ§eriÄŸinin 'deÄŸiÅŸebilir', sabitlerin iÃ§eriÄŸinin ise 'deÄŸiÅŸmez' olmasÄ±dÄ±r."
},
{
  q: "9. AynÄ± tÃ¼rden Ã§ok sayÄ±da deÄŸiÅŸkeni tek bir isim altÄ±nda toplayan ve her bir elemanÄ±na bir indis numarasÄ± ile eriÅŸilen bileÅŸik veri tÃ¼rÃ¼ne ne ad verilir?",
  options: [
    ["Nesne (Object)", "Nesne, farklÄ± tÃ¼rlerden verileri ve fonksiyonlarÄ± bir araya getirebilir."],
    ["Katar (String)", "Katar, karakterlerden oluÅŸan Ã¶zel bir dizidir."],
    ["Dizinli DeÄŸiÅŸken (Array)", "Dizinli deÄŸiÅŸken veya dizi, aynÄ± tÃ¼rden verileri (tamsayÄ± dizisi, karakter dizisi vb.) sÄ±ralÄ± bir ÅŸekilde saklayan ve elemanlarÄ±na `Notlar[0]`, `Notlar[1]` gibi indislerle eriÅŸilen bir yapÄ±dÄ±r."],
    ["Sabit (Constant)", "Sabit, deÄŸeri deÄŸiÅŸmeyen tek bir veridir."],
    ["Ä°lkel Tip (Primitive Type)", "Ä°lkel tipler tek bir deÄŸer tutar."]
  ],
  answer: 2,
  summary: "100 Ã¶ÄŸrencinin notunu saklamak iÃ§in 100 ayrÄ± deÄŸiÅŸken tanÄ±mlamak yerine, 100 elemanlÄ± tek bir 'notlar' dizisi tanÄ±mlamak Ã§ok daha verimli ve yÃ¶netilebilirdir. Diziler, bu tÃ¼r toplu veri iÅŸleme gÃ¶revleri iÃ§in vazgeÃ§ilmezdir."
},
{
  q: "10. Standart bir tamsayÄ± (integer) deÄŸiÅŸkeni iÃ§in bellekte genellikle ne kadar yer ayrÄ±lÄ±r?",
  options: [
    ["1 bit", "1 bit sadece 0 veya 1 deÄŸerini saklayabilir."],
    ["8 bayt", "Bu genellikle bir 'double' veya 'long long' iÃ§in ayrÄ±lan alandÄ±r."],
    ["4 bayt", "Bu genellikle bir 'float' (ondalÄ±k sayÄ±) iÃ§in ayrÄ±lan alandÄ±r."],
    ["1 bayt", "1 bayt genellikle bir 'char' (karakter) iÃ§in ayrÄ±lan alandÄ±r."],
    ["2 bayt", "Genel olarak standart bir tamsayÄ± tanÄ±mlamasÄ± (integer) bellekte 2 baytlÄ±k, yani 16 bitlik yer iÅŸgal eder."]
  ],
  answer: 4,
  summary: "Bir deÄŸiÅŸkenin tipi, bilgisayarÄ±n o deÄŸiÅŸken iÃ§in bellekte ne kadar 'sandalye' ayÄ±racaÄŸÄ±nÄ± belirler. Standart bir tamsayÄ± iÃ§in genellikle 2 baytlÄ±k (16 bit) bir alan yeterli gÃ¶rÃ¼lÃ¼r."
},
{
  q: "11. Ä°ki deÄŸiÅŸkenin deÄŸerlerini Ã¼Ã§Ã¼ncÃ¼ bir deÄŸiÅŸken kullanmadan, aritmetik iÅŸlemlerle takas etme algoritmasÄ±nda, `A=7` ve `B=12` baÅŸlangÄ±Ã§ deÄŸerleri iÃ§in `A = A + B` ilk adÄ±mÄ±ndan sonra A'nÄ±n deÄŸeri ne olur?",
  options: [
    ["7", "Bu A'nÄ±n orijinal deÄŸeridir."],
    ["12", "Bu B'nin orijinal deÄŸeridir."],
    ["5", "Bu `B - A` iÅŸleminin sonucu olurdu."],
    ["19", "Ä°lk adÄ±mda her iki sayÄ±nÄ±n toplamÄ± geÃ§ici olarak A deÄŸiÅŸkenine atanÄ±r. `A = 7 + 12 = 19`."],
    ["0", "Bu hatalÄ± bir sonuÃ§tur."]
  ],
  answer: 3,
  summary: "DeÄŸiÅŸkenleri aritmetik ile takas etme, zekice bir algoritmadÄ±r. Ä°lk adÄ±m, her iki deÄŸeri de kaybetmemek iÃ§in toplamlarÄ±nÄ± bir deÄŸiÅŸkende birleÅŸtirmektir. Sonraki adÄ±mlar, bu toplamdan yola Ã§Ä±karak diÄŸer deÄŸiÅŸkenlerin deÄŸerlerini Ã§Ä±karmaya dayanÄ±r."
},
{
  q: "12. AÅŸaÄŸÄ±dakilerden hangisi Java dilinde bir sabit tanÄ±mlama sÃ¶zdizimine Ã¶rnektir?",
  options: [
    ["`Public Const YildakiGunSayisi = 365`", "Bu, Visual Basic diline ait bir sÃ¶zdizimidir."],
    ["`#define YildakiGunSayisi 365`", "Bu, C diline ait bir sÃ¶zdizimidir."],
    ["`final int YildakiGunSayisi = 365`", "Java'da, bir deÄŸiÅŸkenin deÄŸerinin sonradan deÄŸiÅŸtirilemeyeceÄŸini belirtmek iÃ§in `final` anahtar kelimesi kullanÄ±lÄ±r."],
    ["`define('YildakiGunSayisi', '365')`", "Bu, PHP diline ait bir sÃ¶zdizimidir."],
    ["`let YildakiGunSayisi = 365`", "Bu, JavaScript'te deÄŸiÅŸken tanÄ±mlama sÃ¶zdizimidir."]
  ],
  answer: 2,
  summary: "FarklÄ± programlama dilleri, aynÄ± kavram olan 'sabit'i ifade etmek iÃ§in farklÄ± anahtar kelimeler ve sÃ¶zdizimleri kullanÄ±r. Java'nÄ±n tercihi `final` kelimesidir."
},
{
  q: "13. BilgisayarlarÄ±n kullandÄ±ÄŸÄ± en kÃ¼Ã§Ã¼k veri birimi olan ve iÃ§ine 1 ya da 0 deÄŸeri alan hÃ¼crelere ne ad verilir?",
  options: [
    ["Bayt (Byte)", "Bayt, 8 bitten oluÅŸan bir birimdir."],
    ["Bit", "BilgisayarlarÄ±n iÅŸlem yaparken ya da veri saklarken kullandÄ±klarÄ± bu en kÃ¼Ã§Ã¼k birime 'bit' adÄ± verilir."],
    ["Nibble", "Nibble, 4 bitten oluÅŸan bir birimdir."],
    ["Karakter (Char)", "Karakter, bir harf veya semboldÃ¼r ve genellikle 1 bayt (8 bit) ile temsil edilir."],
    ["HÃ¼cre (Cell)", "Bu genel bir terimdir, en kÃ¼Ã§Ã¼k birimin Ã¶zel adÄ± 'bit'tir."]
  ],
  answer: 1,
  summary: "Bit, 'Binary Digit' (Ä°kili Rakam) kelimelerinin birleÅŸiminden gelir ve bilgisayar dÃ¼nyasÄ±nÄ±n en temel atomudur. Her ÅŸey bu 0 ve 1'lerden oluÅŸur."
},
{
  q: "14. `Notlar: ARRAY(0..199) AS SHORTINT` ÅŸeklinde tanÄ±mlanan bir dizinin boyutu ve son elemanÄ±nÄ±n indisi nedir?",
  options: [
    ["Boyut: 199, Son Ä°ndis: 199", "Ä°ndis 0'dan baÅŸladÄ±ÄŸÄ± iÃ§in boyut 199 deÄŸildir."],
    ["Boyut: 200, Son Ä°ndis: 200", "Ä°ndis 199'da biter, 200'de deÄŸil."],
    ["Boyut: 200, Son Ä°ndis: 199", "Ä°ndisler 0'dan 199'a kadar gittiÄŸi iÃ§in toplamda `199 - 0 + 1 = 200` adet eleman vardÄ±r. Son elemanÄ±n indisi ise 199'dur."],
    ["Boyut: 199, Son Ä°ndis: 200", "Hem boyut hem de son indis yanlÄ±ÅŸtÄ±r."],
    ["Boyut: 201, Son Ä°ndis: 200", "Hem boyut hem de son indis yanlÄ±ÅŸtÄ±r."]
  ],
  answer: 2,
  summary: "Programlamada dizilerin indislerinin genellikle 0'dan baÅŸlamasÄ±, sÄ±kÃ§a yapÄ±lan 'off-by-one' (bir fazlalÄ±k/eksiklik) hatalarÄ±na neden olabilir. 0'dan baÅŸlayan N elemanlÄ± bir dizinin son indisinin her zaman N-1 olduÄŸunu unutmamak Ã¶nemlidir."
},
{
  q: "15. DeÄŸer aktarma iÅŸleminin yÃ¶nÃ¼ iÃ§in aÅŸaÄŸÄ±dakilerden hangisi doÄŸrudur?",
  options: [
    ["Soldan saÄŸa doÄŸrudur.", "Bu yanlÄ±ÅŸtÄ±r."],
    ["SaÄŸdan sola doÄŸrudur; Ã¶nce saÄŸ taraf hesaplanÄ±r, sonuÃ§ sol tarafa aktarÄ±lÄ±r.", "Bu, deÄŸer aktarmanÄ±n temel kuralÄ±dÄ±r."],
    ["YÃ¶nÃ¼, kullanÄ±lan programlama diline gÃ¶re deÄŸiÅŸir.", "Bu kural hemen hemen tÃ¼m imperative dillerde standarttÄ±r."],
    ["YÃ¶nÃ¼ yoktur, iki taraf eÅŸ zamanlÄ± olarak eÅŸitlenir.", "Bu fiziksel olarak mÃ¼mkÃ¼n deÄŸildir."],
    ["YukarÄ±dan aÅŸaÄŸÄ±ya doÄŸrudur.", "Bu anlamsÄ±z bir ifadedir."]
  ],
  answer: 1,
  summary: "`A = B + C` gibi bir ifadede, bilgisayar asla A'yÄ± B'ye eÅŸitleyip sonra C'yi eklemez. Her zaman Ã¶nce saÄŸdaki `B + C` iÅŸlemini bitirir, bir sonuÃ§ elde eder ve en son bu nihai sonucu A'nÄ±n iÃ§ine yazar."
},
{
  q: "16. `A=7`, `B=12`, `C=3` baÅŸlangÄ±Ã§ deÄŸerleri iÃ§in `A=A+B+C; B=A-B-C; C=A-B-C; A=A-B-C;` adÄ±mlarÄ± sonunda C deÄŸiÅŸkeninin deÄŸeri ne olur?",
  options: [
    ["7", "Bu B'nin yeni deÄŸeridir."],
    ["3", "Bu A'nÄ±n yeni deÄŸeridir."],
    ["22", "Bu A'nÄ±n ilk adÄ±mdaki geÃ§ici deÄŸeridir."],
    ["12", "Ä°kinci adÄ±mda `B = 22-12-3 = 7` olur. ÃœÃ§Ã¼ncÃ¼ adÄ±mda `C = 22-7-3 = 12` olur. C'nin son deÄŸeri 12'dir."],
    [" bilinmez, iÅŸlem hatalÄ±dÄ±r.", "Ä°ÅŸlem geÃ§erlidir."]
  ],
  answer: 3,
  summary: "Bu algoritma, Ã¼Ã§ deÄŸiÅŸkenin deÄŸerini dÃ¶rdÃ¼ncÃ¼ bir deÄŸiÅŸken kullanmadan dÃ¶ngÃ¼sel olarak deÄŸiÅŸtirmeyi saÄŸlar. A'nÄ±n deÄŸeri B'ye, B'nin deÄŸeri C'ye ve C'nin deÄŸeri A'ya geÃ§er. BaÅŸlangÄ±Ã§ta B=12 olduÄŸu iÃ§in, bu deÄŸer en sonunda C'ye aktarÄ±lÄ±r."
},
{
  q: "17. AÅŸaÄŸÄ±daki veri tÃ¼rlerinden hangisi bellekte genellikle en fazla yeri kaplar?",
  options: [
    ["integer", "Bu 2 bayt yer kaplar."],
    ["float", "Bu 4 bayt yer kaplar."],
    ["char", "Bu genellikle 1 bayt yer kaplar."],
    ["double", "`double`, `float`'a gÃ¶re daha yÃ¼ksek ondalÄ±k hassasiyeti sunduÄŸu iÃ§in genellikle onun iki katÄ±, yani 8 bayt yer kaplar."],
    ["short", "Bu da integer gibi genellikle 2 bayt yer kaplar."]
  ],
  answer: 3,
  summary: "FarklÄ± veri tipleri, farklÄ± miktarda bilgiyi saklamak iÃ§in tasarlanmÄ±ÅŸtÄ±r. `double` (Ã§ift hassasiyetli) ondalÄ±klÄ± sayÄ±lar, Ã§ok kÃ¼Ã§Ã¼k veya Ã§ok bÃ¼yÃ¼k ondalÄ±klÄ± deÄŸerleri yÃ¼ksek doÄŸrulukla saklamak iÃ§in daha fazla belleÄŸe ihtiyaÃ§ duyar."
},
{
  q: "18. Programlama dillerinde atama ve mantÄ±ksal eÅŸitlik operatÃ¶rlerinin karÄ±ÅŸmasÄ±nÄ± Ã¶nlemek iÃ§in farklÄ± yÃ¶ntemler kullanÄ±lÄ±r. Atama iÃ§in ':=', mantÄ±ksal eÅŸitlik iÃ§in ise '=' sembollerini kullanan dil hangisidir?",
  options: [
    ["C", "C dilinde atama iÃ§in '=', mantÄ±ksal eÅŸitlik iÃ§in '==' kullanÄ±lÄ±r."],
    ["Java", "Java dilinde atama iÃ§in '=', mantÄ±ksal eÅŸitlik iÃ§in '==' kullanÄ±lÄ±r."],
    ["PHP", "PHP dilinde atama iÃ§in '=', mantÄ±ksal eÅŸitlik iÃ§in '==' kullanÄ±lÄ±r."],
    ["Pascal", "Pascal, atama eylemini belirtmek iÃ§in Ã¶zel ':=', matematiksel eÅŸitliÄŸe benzeyen mantÄ±ksal kontrol iÃ§in ise '=' sembolÃ¼nÃ¼ kullanarak bu iki kavramÄ± net bir ÅŸekilde ayÄ±rÄ±r."],
    ["Python", "Python dilinde atama iÃ§in '=', mantÄ±ksal eÅŸitlik iÃ§in '==' kullanÄ±lÄ±r."]
  ],
  answer: 3,
  summary: "C ve ondan etkilenen diller, sÄ±k kullanÄ±lan atama iÅŸlemini tek karakter (`=`) ile bÄ±rakÄ±p mantÄ±ksal eÅŸitliÄŸi Ã§ift karakter (`==`) yapmÄ±ÅŸtÄ±r. Pascal ise tam tersi bir tasarÄ±m felsefesiyle, mantÄ±ksal kontrol iÃ§in tek karakteri (`=`) korumuÅŸ ve farklÄ± bir eylem olan atama iÃ§in Ã¶zel `:=` sembolÃ¼nÃ¼ kullanmÄ±ÅŸtÄ±r."
},
{
  q: "19. AÅŸaÄŸÄ±dakilerden hangisi bir 'BileÅŸik (kompozit)' veri tÃ¼rÃ¼ deÄŸildir?",
  options: [
    ["Nesne (Object)", "Bu, farklÄ± tÃ¼rden verileri ve metotlarÄ± iÃ§eren bileÅŸik bir tÃ¼rdÃ¼r."],
    ["Dizi (Array)", "Bu, aynÄ± tÃ¼rden verileri iÃ§eren bileÅŸik bir tÃ¼rdÃ¼r."],
    ["Katar/Karakter Dizisi (String)", "Bu, karakterlerden oluÅŸan bileÅŸik bir tÃ¼rdÃ¼r."],
    ["GÃ¶sterge (Pointer)", "GÃ¶sterge, bir bellek adresini tutan ve genellikle yapÄ±sal/bileÅŸik kabul edilen bir tÃ¼rdÃ¼r."],
    ["OndalÄ±k SayÄ± (Float)", "Bu, tek bir ondalÄ±klÄ± sayÄ±yÄ± temsil eden ilkel bir tÃ¼rdÃ¼r."]
  ],
  answer: 4,
  summary: "Ä°lkel tÃ¼rler (tamsayÄ±, ondalÄ±k sayÄ±, karakter) verinin kendisini doÄŸrudan tutarken; bileÅŸik tÃ¼rler (nesne, dizi, katar) diÄŸer verileri bir araya getiren bir 'koleksiyon' veya 'yapÄ±' gÃ¶revi gÃ¶rÃ¼r."
},
{
  q: "20. Bir deÄŸiÅŸkene yeni bir deÄŸer aktarÄ±ldÄ±ÄŸÄ±nda, o deÄŸiÅŸkenin eski deÄŸerine ne olur?",
  options: [
    ["Eski deÄŸer yeni deÄŸerin sonuna eklenir.", "Bu metin birleÅŸtirme iÅŸlemine benzer, atama iÅŸlemi bÃ¶yle Ã§alÄ±ÅŸmaz."],
    ["Eski deÄŸer korunur ve yeni deÄŸer bellekte baÅŸka bir yere yazÄ±lÄ±r.", "Bu, deÄŸiÅŸkenin adresinin deÄŸiÅŸmesi anlamÄ±na gelir ki bu atama iÅŸleminde olmaz."],
    ["Eski deÄŸer tamamen kaybolur ve Ã¼zerine yeni deÄŸer yazÄ±lÄ±r.", "Bir deÄŸiÅŸkene yeni bir deÄŸer atandÄ±ÄŸÄ±nda, eski deÄŸer kalÄ±cÄ± olarak silinir ve yerine yeni deÄŸer geÃ§er. DeÄŸiÅŸkenler aynÄ± anda sadece tek bir deÄŸer tutabilir."],
    ["EÄŸer yeni deÄŸer eskisinden bÃ¼yÃ¼kse deÄŸiÅŸiklik yapÄ±lÄ±r, deÄŸilse yapÄ±lmaz.", "BÃ¶yle bir koÅŸul yoktur."],
    ["Program hata verir.", "Bu geÃ§erli bir iÅŸlemdir, hata vermez."]
  ],
  answer: 2,
  summary: "Bir deÄŸiÅŸkeni, Ã¼zerine yazÄ± tahtasÄ± gibi dÃ¼ÅŸÃ¼nebilirsiniz. Tahtada '5' yazÄ±yorsa ve siz Ã¼zerine '10' yazarsanÄ±z, eski '5' rakamÄ± silinir ve artÄ±k tahtada sadece '10' yazar."
},
{
  q: "21. 4 bitten oluÅŸan ve nadiren kullanÄ±lan veri saklama biriminin adÄ± nedir?",
  options: [
    ["Bit", "Bu 1 bitten oluÅŸur."],
    ["Bayt", "Bu 8 bitten oluÅŸur."],
    ["Kilobayt", "Bu 1024 bayttan oluÅŸur."],
    ["Nibble", "4 bitlik veri birimi 'nibble' olarak adlandÄ±rÄ±lÄ±r. Bir baytÄ±n yarÄ±sÄ±dÄ±r."],
    ["Word", "'Word', iÅŸlemci mimarisine gÃ¶re deÄŸiÅŸen (16 bit, 32 bit vb.) bir veri birimidir."]
  ],
  answer: 3,
  summary: "Veri saklama birimleri hiyerarÅŸisinde 'bit' en kÃ¼Ã§Ã¼k birim, 8 bitten oluÅŸan 'bayt' ise en yaygÄ±n temel birimdir. Bu ikisinin arasÄ±nda yer alan 4 bitlik 'nibble', daha az bilinir ancak Ã¶zellikle dÃ¼ÅŸÃ¼k seviyeli programlamada ve veri iletiÅŸiminde karÅŸÄ±nÄ±za Ã§Ä±kabilir."
},
{
  q: "22. `A=7`, `B=12` baÅŸlangÄ±Ã§ deÄŸerleri iÃ§in `A = A + B; B = A â€“ B; A = A â€“ B;` adÄ±mlarÄ± sonunda A ve B'nin son deÄŸerleri ne olur?",
  options: [
    ["A = 7, B = 12", "DeÄŸerler deÄŸiÅŸmemiÅŸtir, bu yanlÄ±ÅŸtÄ±r."],
    ["A = 19, B = 7", "Bu ara adÄ±mdaki bir deÄŸerdir, sonuÃ§ deÄŸildir."],
    ["A = 12, B = 7", "AdÄ±m adÄ±m: 1) A=7+12=19. 2) B=19-12=7. 3) A=19-7=12. SonuÃ§ olarak A=12 ve B=7 olur, yani deÄŸerler takas edilmiÅŸtir."],
    ["A = 7, B = 19", "Bu hatalÄ± bir sonuÃ§tur."],
    ["A = 12, B = 12", "Bu hatalÄ± bir sonuÃ§tur."]
  ],
  answer: 2,
  summary: "Bu Ã¼Ã§ adÄ±mlÄ± aritmetik algoritma, Ã¼Ã§Ã¼ncÃ¼ bir geÃ§ici deÄŸiÅŸken kullanmadan iki deÄŸiÅŸkenin deÄŸerlerini takas etmenin klasik bir yoludur. Programlama mÃ¼lakatlarÄ±nda ve yetenek testlerinde sÄ±kÃ§a sorulan bir mantÄ±k bulmacasÄ±dÄ±r."
},
{
  q: "23. Dizinli deÄŸiÅŸkenlerin (array) iÅŸlevselliÄŸinin Ã¶zellikle hangi programlama yapÄ±sÄ±yla kullanÄ±ldÄ±ÄŸÄ±nda daha iyi ortaya Ã§Ä±ktÄ±ÄŸÄ± belirtilmiÅŸtir?",
  options: [
    ["Sabitler (Constants)", "Sabitler dizilerle kullanÄ±labilir ama asÄ±l iÅŸlevselliÄŸini ortaya Ã§Ä±karan yapÄ± bu deÄŸildir."],
    ["SeÃ§imli Deyimler (if/case)", "`if` ile dizi elemanlarÄ± kontrol edilebilir ancak bu da asÄ±l gÃ¼cÃ¼nÃ¼ gÃ¶stermez."],
    ["DÃ¶ngÃ¼ YapÄ±larÄ± (while, for)", "Bir dizinin yÃ¼zlerce elemanÄ±nÄ± tek tek iÅŸlemek yerine, bir `for` dÃ¶ngÃ¼sÃ¼ kurarak sadece birkaÃ§ satÄ±r kodla tÃ¼m elemanlarÄ± gezmek ve iÅŸlemek mÃ¼mkÃ¼ndÃ¼r. Dizilerin asÄ±l gÃ¼cÃ¼ dÃ¶ngÃ¼lerle birleÅŸtiÄŸinde ortaya Ã§Ä±kar."],
    ["Altprogramlar (Subprograms)", "Diziler altprogramlara parametre olarak gÃ¶nderilebilir ama bu da temel kullanÄ±m sinerjisi deÄŸildir."],
    ["DeÄŸer Aktarma", "Dizi elemanlarÄ±na deÄŸer aktarÄ±lÄ±r, ancak bu da dÃ¶ngÃ¼ler kadar gÃ¼Ã§lÃ¼ bir sinerji oluÅŸturmaz."]
  ],
  answer: 2,
  summary: "Diziler ve dÃ¶ngÃ¼ler, programlamanÄ±n en gÃ¼Ã§lÃ¼ ikililerinden biridir. Diziler veriyi toplu halde saklar, dÃ¶ngÃ¼ler ise bu toplu veriyi otomatik olarak iÅŸler. Bu ikili olmadan bÃ¼yÃ¼k veri setleriyle Ã§alÄ±ÅŸmak neredeyse imkansÄ±z olurdu."
},
{
  q: "24. BilgisayarlarÄ±n onluk taban yerine ikilik taban aritmetiÄŸini kullanmasÄ±nÄ±n temel nedeni nedir?",
  options: [
    ["Ä°kilik tabanÄ±n daha az bellek kullanmasÄ±", "Bu doÄŸrudan bir neden deÄŸildir."],
    ["BilgisayarÄ±n temelindeki elektronik devrelerin 'aÃ§Ä±k' ve 'kapalÄ±' gibi iki duruma dayanmasÄ±", "Bilgisayar donanÄ±mÄ±, temelde elektrik akÄ±mÄ±nÄ±n geÃ§tiÄŸi (1) veya geÃ§mediÄŸi (0) durumlara dayanan transistÃ¶rlerden oluÅŸur. Bu iki durumlu yapÄ±, ikilik taban sistemini doÄŸal ve verimli bir seÃ§im haline getirir."],
    ["Onluk tabanÄ±n patentli bir sistem olmasÄ±", "Bu doÄŸru deÄŸildir."],
    ["Ä°kilik tabandaki hesaplamalarÄ±n insanlar iÃ§in daha kolay olmasÄ±", "Tam tersine, insanlar iÃ§in daha zordur."],
    ["TÃ¼m programlama dillerinin ikilik tabanda yazÄ±lmasÄ±", "Programlama dillerinin Ã§oÄŸu yÃ¼ksek seviyelidir, ikilik tabanda yazÄ±lmaz."]
  ],
  answer: 1,
  summary: "DonanÄ±m ve yazÄ±lÄ±m arasÄ±nda bir uyum vardÄ±r. BilgisayarÄ±n en temel donanÄ±m birimi olan transistÃ¶r sadece iki durumu (aÃ§Ä±k/kapalÄ±) bildiÄŸi iÃ§in, Ã¼zerine kurulan tÃ¼m yazÄ±lÄ±m mantÄ±ÄŸÄ± da bu iki duruma karÅŸÄ±lÄ±k gelen 0 ve 1'ler Ã¼zerine inÅŸa edilmiÅŸtir."
},
{
  q: "25. Veri tÃ¼rlerinin, deÄŸiÅŸkenler ve fonksiyonlar gibi elemanlar iÃ§in bellekte ne kadar alan ayrÄ±lacaÄŸÄ±nÄ± Ã¶nceden belirlemesinin en Ã¶nemli faydasÄ± nedir?",
  options: [
    ["ProgramÄ±n daha yavaÅŸ Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak", "Bu bir fayda deÄŸildir."],
    ["Fiziksel kaynaklarÄ±n (belleÄŸin) verimli kullanÄ±lmasÄ±nÄ± saÄŸlamak", "Bir deÄŸiÅŸkenin tamsayÄ± olduÄŸunu bildiÄŸimizde, ona tam olarak ihtiyacÄ± kadar (Ã¶rn: 2 bayt) yer ayÄ±rÄ±rÄ±z. EÄŸer tip kavramÄ± olmasaydÄ±, her deÄŸiÅŸken iÃ§in en kÃ¶tÃ¼ senaryoya gÃ¶re Ã§ok bÃ¼yÃ¼k bir alan ayÄ±rmak gerekirdi, bu da bÃ¼yÃ¼k bir bellek israfÄ±na yol aÃ§ardÄ±."],
    ["ProgramcÄ±larÄ±n daha az kod yazmasÄ±nÄ± saÄŸlamak", "DoÄŸrudan bir etkisi yoktur."],
    ["ProgramÄ±n her zaman hatasÄ±z olmasÄ±nÄ± garantilemek", "HatalarÄ± azaltmaya yardÄ±mcÄ± olur ama garantilemez."],
    ["Sadece sayÄ±sal verilerin saklanabilmesini saÄŸlamak", "HayÄ±r, farklÄ± tÃ¼rde verilerin saklanmasÄ±nÄ± dÃ¼zenler."]
  ],
  answer: 1,
  summary: "Veri tipleri, bilgisayarÄ±n kÄ±sÄ±tlÄ± olan bellek kaynaÄŸÄ±nÄ± akÄ±llÄ±ca yÃ¶netmesine yardÄ±mcÄ± olur. Her veriye tam olarak 'ihtiyacÄ± kadar' yer ayrÄ±larak belleÄŸin israf edilmesi Ã¶nlenir ve programlarÄ±n daha verimli Ã§alÄ±ÅŸmasÄ± saÄŸlanÄ±r."
}    
  ];

  const quizDiv = document.getElementById('quiz');
  const optionLabels = ['A)', 'B)', 'C)', 'D)', 'E)'];
  const userAnswers = new Array(questions.length).fill(null);


  questions.forEach((qObj, index) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'question-container';
    questionContainer.id = `question-${index}`;

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = qObj.q;
    questionContainer.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options-group';

    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback';
    feedbackDiv.style.display = 'none'; // Initially hidden

    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'summary';
    summaryDiv.style.display = 'none'; // Initially hidden


    qObj.options.forEach((opt, i) => {
      const optDiv = document.createElement('div');
      optDiv.className = 'option';
      optDiv.textContent = `${optionLabels[i]} ${opt[0]}`;
      optDiv.onclick = () => {
        // Clear previous selection visuals for this question
        const allOptsInGroup = optsDiv.querySelectorAll('.option');
        allOptsInGroup.forEach(el => el.classList.remove('selected'));
        optDiv.classList.add('selected'); // Mark as selected

        userAnswers[index] = i; // Store user's answer

        // Show feedback immediately
        const feedbackText = opt[1] || (i === qObj.answer ? "DoÄŸru cevap!" : "YanlÄ±ÅŸ cevap."); // Fallback feedback
        feedbackDiv.className = 'feedback ' + (i === qObj.answer ? 'correct' : 'incorrect');
        feedbackDiv.style.display = 'block';
        feedbackDiv.textContent = (i === qObj.answer ? 'âœ”ï¸ DoÄŸru: ' : 'âŒ YanlÄ±ÅŸ: ') + feedbackText;


        if (i === qObj.answer && qObj.summary) {
          summaryDiv.style.display = 'block';
          summaryDiv.textContent = 'ðŸ’¡ ' + qObj.summary;
        } else {
          summaryDiv.style.display = 'none';
        }
      };
      optsDiv.appendChild(optDiv);
    });

    questionContainer.appendChild(optsDiv);
    questionContainer.appendChild(feedbackDiv);
    questionContainer.appendChild(summaryDiv);
    quizDiv.appendChild(questionContainer);
  });

  function showResults() {
    let correctCount = 0;
    userAnswers.forEach((answer, index) => {
        if (answer !== null && answer === questions[index].answer) {
            correctCount++;
        }
    });

    const totalQuestions = questions.length;
    const scorePercentage = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(2) : 0;

    document.getElementById('total-questions').textContent = totalQuestions;
    document.getElementById('correct-answers').textContent = correctCount;
    document.getElementById('score-percentage').textContent = scorePercentage;
    document.getElementById('results-summary').style.display = 'block';

    // Scroll to results
    document.getElementById('results-summary').scrollIntoView({ behavior: 'smooth' });
  }

</script>
</body>
</html>