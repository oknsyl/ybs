<!DOCTYPE html>
<html lang="tr">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Programlama Dilleri - 6</title>
  <style>
    body { font-family: 'PT Sans', 'Trebuchet MS', sans-serif; background: #f9f9f9; padding: 20px; color: #333; }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .question-container { background: #fff; padding: 20px; margin-bottom: 25px; border-left: 5px solid #007BFF; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-text { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; }
    .option { padding: 10px; margin: 8px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; transition: background-color 0.2s ease-in-out; }
    .option:hover { background: #e9ecef; }
    .option.selected { background-color: #cce5ff; border-color: #b8daff; }
    .feedback { margin-top: 15px; padding: 12px; border-radius: 4px; display: none; font-weight: bold; }
    .correct { background: #d4edda; border-left: 5px solid #28a745; color: #155724; }
    .incorrect { background: #f8d7da; border-left: 5px solid #dc3545; color: #721c24; }
    .summary { display: none; background: #fff3cd; padding: 12px; margin-top: 10px; border-left: 5px solid #ffc107; border-radius: 4px; color: #856404; }
    button#submit-all {
        display: block;
        margin: 30px auto;
        padding: 12px 25px;
        font-size: 1.1em;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    button#submit-all:hover {
        background-color: #218838;
    }
    .results { margin-top: 30px; padding: 20px; background-color: #e9ecef; border-radius: 5px; text-align: center;}
  </style>
</head>
<body>
<h1>Programlama Dilleri - 6</h1>
<div id="quiz">
  </div>
<button id="submit-all" onclick="showResults()">T√ºm Testi Bitir ve Sonu√ßlarƒ± G√∂r</button>
<div id="results-summary" class="results" style="display:none;">
    <h2>Test Sonucu</h2>
    <p>Toplam Soru: <span id="total-questions"></span></p>
    <p>Doƒüru Cevap Sayƒ±sƒ±: <span id="correct-answers"></span></p>
    <p>Ba≈üarƒ± Y√ºzdesi: <span id="score-percentage"></span>%</p>
</div>

<script>
  const questions = [
{
  q: "1. Bir i≈ülemcinin anlamƒ±nƒ±n, i≈ülenenlerinin sayƒ±sƒ±na ve tipine baƒülƒ± olarak belirlenmesi durumuna ne ad verilir?",
  options: [
    ["ƒ∞≈ülemci √ñnceliƒüi (Operator Precedence)", "Bu, i≈ülem sƒ±rasƒ±nƒ± belirleyen bir kuraldƒ±r."],
    ["ƒ∞≈ülemci ƒ∞li≈ükiselliƒüi (Operator Associativity)", "Bu, aynƒ± √∂ncelikli i≈ülemcilerin i≈ülenme y√∂n√ºn√º belirleyen kuraldƒ±r."],
    ["ƒ∞≈ülemci Y√ºklemesi (Operator Overloading)", "Bir i≈ülemcinin, i≈ülenenlerinin tipine g√∂re farklƒ± g√∂revler yapmasƒ± (√∂rn: '+' nƒ±n hem sayƒ±larƒ± toplamasƒ± hem de metinleri birle≈ütirmesi) i≈ülemci y√ºklemesidir."],
    ["ƒ∞≈ülemci Atamasƒ± (Operator Assignment)", "Bu, atama i≈ülemiyle ilgili bir kavramdƒ±r."],
    ["ƒ∞≈ülemci Soyutlamasƒ± (Operator Abstraction)", "Bu genel bir programlama kavramƒ±dƒ±r, bu duruma verilen √∂zel isim deƒüildir."]
  ],
  answer: 2,
  summary: "ƒ∞≈ülemci y√ºklemesi, `+` gibi tek bir sembol√ºn birden √ßok anlama gelmesini saƒülar. Bu, dilin ifade yeteneƒüini artƒ±rƒ±r ancak bazen hangi i≈ülemin yapƒ±ldƒ±ƒüƒ±nƒ±n anƒ±nda anla≈üƒ±lamamasƒ± nedeniyle kodun okunabilirliƒüini ve g√ºvenilirliƒüini azaltabilir."
},
{
  q: "2. `NOT`, `AND` ve `OR` mantƒ±ksal i≈ülemcileri i√ßin √ßoƒüu dilde ge√ßerli olan √∂ncelik sƒ±ralamasƒ± a≈üaƒüƒ±dakilerden hangisidir?",
  options: [
    ["OR > AND > NOT", "Bu sƒ±ralama yanlƒ±≈ütƒ±r, en d√º≈ü√ºk √∂ncelikli olan genellikle OR'dur."],
    ["AND > OR > NOT", "Bu sƒ±ralama yanlƒ±≈ütƒ±r."],
    ["NOT > AND > OR", "Bir√ßok dilde, en y√ºksek √∂ncelik tek i≈ülenen alan `NOT` i≈ülemcisine, ardƒ±ndan `AND` i≈ülemcisine ve en son `OR` i≈ülemcisine aittir."],
    ["AND = OR = NOT", "Bu i≈ülemcilerin √∂ncelikleri genellikle birbirinden farklƒ±dƒ±r."],
    ["OR > NOT > AND", "Bu sƒ±ralama yanlƒ±≈ütƒ±r."]
  ],
  answer: 2,
  summary: "Bu √∂ncelik sƒ±ralamasƒ±, karma≈üƒ±k mantƒ±ksal ifadelerin doƒüru deƒüerlendirilmesi i√ßin kritiktir. `false OR true AND true` gibi bir ifadenin sonucu, √∂nce `true AND true` i≈üleminin yapƒ±lmasƒ±yla `true` olarak bulunur."
},
{
  q: "3. Sayƒ±sal, ili≈ükisel ve mantƒ±ksal i≈ülemci gruplarƒ± arasƒ±ndaki genel √∂ncelik kuralƒ± nasƒ±ldƒ±r?",
  options: [
    ["Mantƒ±ksal > ƒ∞li≈ükisel > Sayƒ±sal", "Bu sƒ±ralama genellikle yanlƒ±≈ütƒ±r. Pascal'da bunun bir istisnasƒ± vardƒ±r."],
    ["Sayƒ±sal > ƒ∞li≈ükisel > Mantƒ±ksal", "Genellikle, bir ifadede √∂nce matematiksel i≈ülemler (sayƒ±sal), sonra kar≈üƒ±la≈ütƒ±rmalar (ili≈ükisel) ve en son olarak da bu kar≈üƒ±la≈ütƒ±rmalarƒ±n sonu√ßlarƒ±nƒ±n mantƒ±ksal olarak birle≈ütirilmesi yapƒ±lƒ±r."],
    ["ƒ∞li≈ükisel > Sayƒ±sal > Mantƒ±ksal", "Bu sƒ±ralama yanlƒ±≈ütƒ±r."],
    ["Hepsinin √∂nceliƒüi e≈üittir.", "Hayƒ±r, aralarƒ±nda net bir √∂ncelik hiyerar≈üisi vardƒ±r."],
    ["Sayƒ±sal > Mantƒ±ksal > ƒ∞li≈ükisel", "Bu sƒ±ralama yanlƒ±≈ütƒ±r."]
  ],
  answer: 1,
  summary: "`a*5 + 2 > b AND c` gibi karma≈üƒ±k bir ifadede, i≈ülem sƒ±rasƒ± bu genel √∂ncelik kuralƒ±na g√∂re belirlenir: √ñnce `a*5` hesaplanƒ±r, sonra `+ 2` eklenir (sayƒ±sal), sonra sonu√ß `b` ile kar≈üƒ±la≈ütƒ±rƒ±lƒ±r (ili≈ükisel), ve en son bu kar≈üƒ±la≈ütƒ±rmanƒ±n sonucu `c` ile `AND` i≈ülemine tabi tutulur (mantƒ±ksal)."
},
{
  q: "4. Bir programdaki i≈ülemleri g√∂stermek ve programƒ±n akƒ±≈üƒ±nƒ± y√∂nlendirmek i√ßin kullanƒ±lan `if`, `while`, `a:=b` gibi yapƒ±lara genel olarak ne ad verilir?",
  options: [
    ["ƒ∞fadeler (Expressions)", "ƒ∞fadeler bir deƒüer √ºretir (√∂rn: `a+b`). Deyimler ise bir eylem ger√ßekle≈ütirir."],
    ["Deyimler (Statements)", "Deyimler, bir programdaki eylemleri (atama gibi) veya akƒ±≈ü kontrol√ºn√º (se√ßim, yineleme gibi) belirleyen komutlardƒ±r."],
    ["Deƒüi≈ükenler (Variables)", "Deƒüi≈ükenler veri tutan bellek konumlarƒ±dƒ±r."],
    ["ƒ∞≈ülemciler (Operators)", "ƒ∞≈ülemciler, ifadelerin i√ßinde deƒüerler √ºzerinde i≈ülem yapan sembollerdir."],
    ["Tipler (Types)", "Tipler, verilerin t√ºr√ºn√º belirler."]
  ],
  answer: 1,
  summary: "Programlar temelde deyimlerden olu≈üur. Bir program, bilgisayara '≈üunu yap, sonra bunu yap, eƒüer ≈üu doƒüruysa bunu yap, deƒüilse diƒüerini yap' diyen bir dizi deyimdir."
},
{
  q: "5. `5 MOD 2` i≈üleminin sonucu nedir?",
  options: [
    ["2.5", "Bu, `/` (b√∂lme) i≈üleminin sonucudur."],
    ["2", "Bu, `\` (tam b√∂lme) i≈üleminin sonucudur."],
    ["1", "`MOD` (mod√ºl) i≈ülemcisi, bir sayƒ±nƒ±n ba≈üka bir sayƒ±ya b√∂l√ºnmesinden elde edilen kalanƒ± verir. 5'in 2'ye b√∂l√ºm√ºnden kalan 1'dir."],
    ["0", "Eƒüer ilk sayƒ± ikinciye tam b√∂l√ºn√ºyorsa sonu√ß 0 olurdu (√∂rn: `4 MOD 2`)."],
    ["3", "Bu anlamsƒ±z bir sonu√ßtur."]
  ],
  answer: 2,
  summary: "`MOD` i≈ülemcisi, √∂zellikle bir sayƒ±nƒ±n √ßift mi tek mi olduƒüunu kontrol etmek (sayi MOD 2), d√∂ng√ºsel i≈ülemlerde belirli bir aralƒ±kta kalmak gibi bir√ßok algoritmik durumda kullanƒ±lan √ßok faydalƒ± bir sayƒ±sal i≈ülemcidir."
},
{
  q: "6. Pascal dilinde `a>0 or b<100` gibi bir ifadenin parantezsiz kullanƒ±mƒ±nƒ±n ge√ßersiz olmasƒ±nƒ±n sebebi nedir?",
  options: [
    ["Pascal'da 'or' i≈ülemcisinin bulunmamasƒ±", "Hayƒ±r, Pascal'da 'or' i≈ülemcisi vardƒ±r."],
    ["Pascal'da mantƒ±ksal i≈ülemcilerin √∂nceliƒüinin ili≈ükisel i≈ülemcilerden y√ºksek olmasƒ±", "Diƒüer bir√ßok dilden farklƒ± olarak Pascal'da `or` gibi mantƒ±ksal i≈ülemcilerin √∂nceliƒüi `>` gibi ili≈ükisel i≈ülemcilerden daha y√ºksektir. Bu nedenle derleyici ifadeyi `(a > (0 or b)) < 100` gibi anlamaya √ßalƒ±≈üƒ±r ve bu da anlamsƒ±z olduƒüu i√ßin hata verir."],
    ["Pascal'da sayƒ±sal ve mantƒ±ksal ifadelerin bir arada kullanƒ±lamamasƒ±", "Kullanƒ±labilirler, ancak doƒüru √∂ncelik ve gruplama ile."],
    ["Pascal'da b√ºy√ºkt√ºr `>` sembol√ºn√ºn farklƒ± bir anlama gelmesi", "Hayƒ±r, anlamƒ± aynƒ±dƒ±r."],
    ["ƒ∞fadede en fazla iki deƒüi≈üken kullanƒ±lmasƒ±na izin verilmesi", "B√∂yle bir kural yoktur."]
  ],
  answer: 1,
  summary: "Bu, diller arasƒ±ndaki √∂ncelik kuralƒ± farklƒ±lƒ±klarƒ±na g√ºzel bir √∂rnektir. √áoƒüu dilde sorunsuz √ßalƒ±≈üacak bu ifade, Pascal'ƒ±n kendine √∂zg√º i≈ülemci √∂ncelik sƒ±rasƒ± nedeniyle `(a>0) or (b<100)` ≈üeklinde parantezlerle gruplanmayƒ± zorunlu kƒ±lar."
},
{
  q: "7. `if-then-else` ve `case (switch)` gibi yapƒ±lar, belirli bir ifadenin deƒüerine g√∂re programda izlenecek yolu belirledikleri i√ßin ne t√ºr deyimler olarak sƒ±nƒ±flandƒ±rƒ±lƒ±rlar?",
  options: [
    ["Yinelemeli Deyimler (Iterative Statements)", "Yinelemeli deyimler (`while`, `for`) bir kod bloƒüunu tekrarlamak i√ßin kullanƒ±lƒ±r."],
    ["Atama Deyimleri (Assignment Statements)", "Atama deyimleri bir deƒüi≈ükene deƒüer aktarƒ±r."],
    ["Se√ßimli Deyimler (Selection Statements)", "`if` ve `case` yapƒ±larƒ±, bir veya daha fazla ko≈üula baƒülƒ± olarak, programƒ±n hangi kod bloƒüunu √ßalƒ±≈ütƒ±racaƒüƒ±nƒ± 'se√ßmesini' saƒülar."],
    ["Basit Deyimler (Simple Statements)", "`if` ve `case` genellikle i√ßlerinde ba≈üka deyimler barƒ±ndƒ±ran birle≈üik deyimlerdir."],
    ["Altprogram √áaƒürƒ±larƒ± (Subprogram Calls)", "Bu, bir fonksiyonu veya yordamƒ± √ßalƒ±≈ütƒ±rma i≈ülemidir."]
  ],
  answer: 2,
  summary: "Se√ßimli deyimler, programlara karar verme yeteneƒüi kazandƒ±rƒ±r. Programƒ±n akƒ±≈üƒ±, bu deyimler sayesinde tek bir doƒürusal yol yerine, kar≈üƒ±la≈üƒ±lan durumlara g√∂re farklƒ± yollara sapan bir yol aƒüƒ±na d√∂n√º≈ü√ºr."
},
{
  q: "8. C dilinde 'e≈üitlik' kontrol√º i√ßin `==` sembol√º kullanƒ±lƒ±rken, Pascal dilinde hangi sembol kullanƒ±lƒ±r?",
  options: [
    ["!=", "`!=` sembol√º C'de 'e≈üit deƒüil' anlamƒ±na gelir."],
    ["<>", "`<>` sembol√º Pascal'da 'e≈üit deƒüil' anlamƒ±na gelir."],
    ["=", "Pascal dilinde, hem atama i√ßin (`:=`) hem de e≈üitlik kontrol√º i√ßin (`=`) farklƒ± semboller kullanƒ±lƒ±r. E≈üitlik kontrol√º tek bir `=` i≈üareti ile yapƒ±lƒ±r."],
    [":=", "`:=` sembol√º Pascal'da atama i≈ülemi i√ßin kullanƒ±lƒ±r."],
    ["equals", "Bu genellikle bir fonksiyon adƒ±dƒ±r, bir i≈ülemci deƒüildir."]
  ],
  answer: 2,
  summary: "Programlama dillerinin s√∂zdizimleri arasƒ±ndaki k√º√ß√ºk farklar, programcƒ±lar i√ßin kafa karƒ±≈ütƒ±rƒ±cƒ± olabilir. C'de atama i√ßin `=`, kar≈üƒ±la≈ütƒ±rma i√ßin `==` kullanƒ±lƒ±rken; Pascal'da atama i√ßin `:=`, kar≈üƒ±la≈ütƒ±rma i√ßin `=` kullanƒ±lƒ±r. Bu, dillerin tasarƒ±m felsefelerindeki farklƒ±lƒ±klarƒ± yansƒ±tƒ±r."
},
{
  q: "9. ƒ∞≈ülemcilerin, i≈ülenenlerin niteliƒüine (t√ºr√ºne) g√∂re sƒ±nƒ±flandƒ±rƒ±ldƒ±ƒüƒ± √º√ß temel grup hangisidir?",
  options: [
    ["Prefix, Infix, Postfix", "Bu, i≈ülemcinin konumuna g√∂re sƒ±nƒ±flandƒ±rmadƒ±r."],
    ["Unary, Binary, Ternary", "Bu, i≈ülemcinin i≈ülenen sayƒ±sƒ±na g√∂re sƒ±nƒ±flandƒ±rmadƒ±r."],
    ["Sayƒ±sal, ƒ∞li≈ükisel, Mantƒ±ksal", "ƒ∞≈ülemciler; √ºzerinde √ßalƒ±≈ütƒ±klarƒ± veri t√ºr√ºne ve √ºrettikleri sonuca g√∂re sayƒ±sal (aritmetik), ili≈ükisel (kar≈üƒ±la≈ütƒ±rma) ve mantƒ±ksal (Boolean) olarak √º√ße ayrƒ±lƒ±r."],
    ["Basit, Birle≈üik, Yapƒ±sal", "Bunlar deyimler ve tiplerle ilgili kavramlardƒ±r."],
    ["Keyword, Reserved, Identifier", "Bunlar dildeki isimlerle ilgili kavramlardƒ±r."]
  ],
  answer: 2,
  summary: "Bir i≈ülemcinin ne yaptƒ±ƒüƒ±nƒ± anlamak i√ßin hangi t√ºr verilerle √ßalƒ±≈ütƒ±ƒüƒ±na bakƒ±lƒ±r. Sayƒ±larla mƒ± (`+`, `*`), kar≈üƒ±la≈ütƒ±rmalarla mƒ± (`>`, `<`), yoksa doƒüru/yanlƒ±≈ü deƒüerleriyle mi (`AND`, `OR`) √ßalƒ±≈ütƒ±ƒüƒ±na g√∂re sƒ±nƒ±flandƒ±rƒ±lƒ±r."
},
{
  q: "10. Bir programda bir dizi deyimin `begin` ve `end` anahtar kelimeleri arasƒ±nda gruplanarak tek bir deyim gibi davranmasƒ±nƒ±n saƒülanmasƒ±, ne t√ºr bir deyim olu≈üturur?",
  options: [
    ["Basit Deyim", "Basit deyimler genellikle tek bir i≈ülemden olu≈üur (√∂rn: atama)."],
    ["Yinelemeli Deyim", "Bu, d√∂ng√º yapƒ±larƒ±dƒ±r."],
    ["Se√ßimli Deyim", "Bu, `if` veya `case` gibi karar yapƒ±larƒ±dƒ±r."],
    ["Birle≈üik Deyim (Compound Statement)", "Birle≈üik deyimler, birden √ßok basit veya birle≈üik deyimin bir araya getirilerek mantƒ±ksal bir b√ºt√ºn olu≈üturmasƒ±nƒ± saƒülar. Pascal'daki `begin...end` bloƒüu bunun en tipik √∂rneƒüidir."],
    ["Atama Deyimi", "Atama deyimi genellikle basit bir deyimdir."]
  ],
  answer: 3,
  summary: "Birle≈üik deyimler, `if` veya `while` gibi kontrol yapƒ±larƒ±nƒ±n tek bir eylem yerine birden √ßok eylemi kontrol etmesine olanak tanƒ±r. Bu, yapƒ±sal programlamanƒ±n temel ta≈ülarƒ±ndan biridir."
},
{
  q: "11. `while`, `until` ve `for` gibi yapƒ±lar, belirli bir ko≈üul saƒülandƒ±ƒüƒ± s√ºrece bir kod bloƒüunu tekrarladƒ±klarƒ± i√ßin ne t√ºr deyimler olarak adlandƒ±rƒ±lƒ±rlar?",
  options: [
    ["Se√ßimli Deyimler", "Se√ßimli deyimler bir kod bloƒüunu bir kez √ßalƒ±≈ütƒ±rmayƒ± veya atlamayƒ± se√ßer."],
    ["Yinelemeli Deyimler (Iterative Statements)", "`while`, `for` gibi d√∂ng√ºler, bir kod bloƒüunun tekrar tekrar √ßalƒ±≈ütƒ±rƒ±lmasƒ±nƒ± saƒülayan yinelemeli deyimlerdir."],
    ["Atama Deyimleri", "Atama deyimleri deƒüer aktarƒ±r."],
    ["Birle≈üik Deyimler", "D√∂ng√ºler genellikle bir birle≈üik deyimi tekrarlar, ancak kendileri yinelemeli deyim olarak sƒ±nƒ±flandƒ±rƒ±lƒ±r."],
    ["Altprogramlar", "Altprogramlar, √ßaƒürƒ±ldƒ±klarƒ±nda √ßalƒ±≈üan isimlendirilmi≈ü kod bloklarƒ±dƒ±r."]
  ],
  answer: 1,
  summary: "Yinelemeli deyimler veya d√∂ng√ºler, programlarƒ±n en g√º√ßl√º √∂zelliklerinden biridir. Binlerce kaydƒ± i≈ülemek veya bir animasyonu s√ºrekli oynatmak gibi tekrarlƒ± g√∂revleri, sadece birka√ß satƒ±r kodla otomatikle≈ütirmeyi saƒülarlar."
},
{
  q: "12. `+` i≈ülemcisinin, `2 + 3` ifadesinde tamsayƒ± toplama, `\"a\" + \"b\"` ifadesinde ise karakter dizisi birle≈ütirme anlamƒ±na gelmesi hangi kavrama √∂rnektir?",
  options: [
    ["ƒ∞≈ülemci √ñnceliƒüi", "Bu, farklƒ± i≈ülemciler arasƒ±ndaki i≈ülem sƒ±rasƒ±dƒ±r."],
    ["ƒ∞≈ülemci Y√ºklemesi (Operator Overloading)", "Aynƒ± i≈ülemci sembol√ºn√ºn (`+`), farklƒ± veri tipleriyle (tamsayƒ±, karakter dizisi) kullanƒ±ldƒ±ƒüƒ±nda farklƒ± i≈ülemler yapmasƒ±, i≈ülemci y√ºklemesinin klasik bir √∂rneƒüidir."],
    ["ƒ∞≈ülemci ƒ∞li≈ükiselliƒüi (Associativity)", "Bu, aynƒ± √∂ncelikli i≈ülemcilerin i≈ülenme y√∂n√ºd√ºr."],
    ["Tip D√∂n√º≈ü√ºm√º (Type Casting)", "Tip d√∂n√º≈ü√ºm√º, bir veriyi bir tipten diƒüerine √ßevirme i≈ülemidir, i≈ülemcinin anlamƒ±nƒ±n deƒüi≈ümesi deƒüildir."],
    ["S√∂zdizim Hatasƒ±", "Bu bir hata deƒüil, dilin bir √∂zelliƒüidir."]
  ],
  answer: 1,
  summary: "Operat√∂r y√ºklemesi, operat√∂rlere 'baƒülama g√∂re konu≈üma' yeteneƒüi verir. `+` operat√∂r√º, yanƒ±nda sayƒ±lar g√∂r√ºnce toplama yapacaƒüƒ±nƒ±, metinler g√∂r√ºnce ise birle≈ütirme yapacaƒüƒ±nƒ± anlar."
},
{
  q: "13. Bir dizi deyimin gruplanarak bir isim ile g√∂sterilmesini saƒülayan ve bir ba≈ülƒ±k ile g√∂vdeden olu≈üan yapƒ±ya ne denir?",
  options: [
    ["D√∂ng√º (Loop)", "D√∂ng√º, kod tekrarƒ± i√ßin kullanƒ±lƒ±r."],
    ["Deƒüi≈üken (Variable)", "Deƒüi≈üken, veri saklar."],
    ["Altprogram (Subprogram)", "Altprogramlar (fonksiyonlar veya yordamlar), belirli bir i≈üi yapan ve bir isimle √ßaƒürƒ±labilen, yeniden kullanƒ±labilir kod bloklarƒ±dƒ±r. Bir ba≈ülƒ±klarƒ± (isim, parametreler) ve bir g√∂vdeleri (i≈ülemler) vardƒ±r."],
    ["ƒ∞fade (Expression)", "ƒ∞fade, bir deƒüer √ºretir."],
    ["Sabit (Constant)", "Sabit, deƒüeri deƒüi≈ümeyen bir veridir."]
  ],
  answer: 2,
  summary: "Altprogramlar, 'bir kere yaz, her yerden √ßaƒüƒ±r' prensibiyle √ßalƒ±≈üƒ±r. Karma≈üƒ±k programlarƒ± daha k√º√ß√ºk, y√∂netilebilir ve yeniden kullanƒ±labilir par√ßalara ayƒ±rmanƒ±n temel yoludur."
},
{
  q: "14. `XOR` (dƒ±≈ülayan veya) mantƒ±ksal i≈ülemcisinin tanƒ±mƒ± nedir?",
  options: [
    ["ƒ∞≈ülenenlerden en az birinin doƒüru olmasƒ± durumunda DOƒûRU d√∂nd√ºr√ºr.", "Bu, OR i≈ülemcisinin tanƒ±mƒ±dƒ±r."],
    ["Sadece t√ºm i≈ülenenlerin doƒüru olduƒüu durumda DOƒûRU d√∂nd√ºr√ºr.", "Bu, AND i≈ülemcisinin tanƒ±mƒ±dƒ±r."],
    ["ƒ∞≈ülenen deƒüerinin tersini verir.", "Bu, NOT i≈ülemcisinin tanƒ±mƒ±dƒ±r."],
    ["Aynƒ± deƒüere sahip i≈ülenenler i√ßin YANLI≈û, diƒüer durumlarda DOƒûRU d√∂nd√ºr√ºr.", "`XOR`, i≈ülenenler birbirinden farklƒ±ysa DOƒûRU, aynƒ±ysa YANLI≈û sonu√ß verir. 'ƒ∞kisinden sadece biri doƒüruysa doƒüru' olarak da d√º≈ü√ºn√ºlebilir."],
    ["Her zaman YANLI≈û deƒüerini d√∂nd√ºr√ºr.", "Bu anlamsƒ±z bir i≈ülemci olurdu."]
  ],
  answer: 3,
  summary: "`XOR` (exclusive OR), 'ya o ya da bu, ama ikisi birden deƒüil' mantƒ±ƒüƒ±nƒ± temsil eder. √ñrneƒüin, bir ƒ±≈üƒ±k anahtarƒ± ya a√ßƒ±k ya da kapalƒ± olabilir, ikisi birden olamaz. Bu t√ºr durumlar i√ßin `XOR` mantƒ±ƒüƒ± kullanƒ±lƒ±r."
},
{
  q: "15. ƒ∞li≈ükisel i≈ülemciler (`>`, `<`, `==` vb.) ile yapƒ±lan bir kar≈üƒ±la≈ütƒ±rma i≈ülemi sonucunda ne t√ºr bir deƒüer olu≈üur?",
  options: [
    ["Sayƒ±sal (integer veya float)", "Sayƒ±sal deƒüerler aritmetik i≈ülemler sonucunda olu≈üur."],
    ["Mantƒ±ksal (Boolean - doƒüru veya yanlƒ±≈ü)", "Bir ili≈ükisel ifade, √∂rneƒüin `sayac >= 10`, her zaman bir kar≈üƒ±la≈ütƒ±rma yapar ve bu kar≈üƒ±la≈ütƒ±rmanƒ±n sonucu 'evet, doƒüru' veya 'hayƒ±r, yanlƒ±≈ü' ≈üeklinde bir mantƒ±ksal deƒüerdir."],
    ["Karakter Dizisi (String)", "Karakter dizileri metinsel verilerdir."],
    ["Hi√ßbir deƒüer olu≈ümaz, sadece bir eylem ger√ßekle≈üir.", "Hayƒ±r, ili≈ükisel ifadeler mutlaka bir deƒüer √ºretir."],
    ["ƒ∞≈ülenenlerin tipine baƒülƒ± olarak herhangi bir tipte deƒüer olu≈üabilir.", "Hayƒ±r, sonu√ß her zaman mantƒ±ksal bir deƒüerdir."]
  ],
  answer: 1,
  summary: "ƒ∞li≈ükisel i≈ülemciler, programlara soru sorma yeteneƒüi kazandƒ±rƒ±r. 'x, 10'dan b√ºy√ºk m√º?' sorusunun cevabƒ± sayƒ±sal bir deƒüer deƒüil, 'evet' (doƒüru) veya 'hayƒ±r' (yanlƒ±≈ü) olabilir. Bu mantƒ±ksal sonu√ß, `if` gibi karar yapƒ±larƒ±nda kullanƒ±lƒ±r."
},
{
  q: "16. `5 \ 2` (tam b√∂lme) i≈üleminin sonucu nedir?",
  options: [
    ["2.5", "Bu, `/` (ondalƒ±klƒ± b√∂lme) i≈üleminin sonucudur."],
    ["1", "Bu, `MOD` (kalan) i≈üleminin sonucudur."],
    ["2", "`\` (tam b√∂lme) i≈ülemcisi, b√∂lme i≈üleminin ondalƒ±k kƒ±smƒ±nƒ± atarak sadece tam sayƒ± kƒ±smƒ±nƒ± sonu√ß olarak verir. 5'in i√ßinde 2, tam olarak 2 kez vardƒ±r."],
    ["0", "Bu hatalƒ± bir sonu√ßtur."],
    ["3", "Bu hatalƒ± bir sonu√ßtur."]
  ],
  answer: 2,
  summary: "Tam b√∂lme, bir miktarƒ±n i√ßinden ba≈üka bir miktarƒ±n 'ka√ß tam adet' √ßƒ±ktƒ±ƒüƒ±nƒ± bulmak i√ßin kullanƒ±lƒ±r. √ñrneƒüin, 25 ki≈üilik bir sƒ±nƒ±fta 3'erli ka√ß tam grup olu≈üturulabilir sorusunun cevabƒ± `25 \ 3 = 8`'dir."
},
{
  q: "17. ƒ∞≈ülemci y√ºklemesinin (operator overloading) potansiyel bir dezavantajƒ± olarak ne belirtilmi≈ütir?",
  options: [
    ["Programlarƒ±n ifade yeteneƒüini artƒ±rmasƒ±", "Bu, bir avantajƒ±dƒ±r."],
    ["Programlarƒ±n daha yava≈ü √ßalƒ±≈ümasƒ±na neden olmasƒ±", "Bu her zaman ge√ßerli bir dezavantaj deƒüildir."],
    ["Okunabilirliƒüi ve g√ºvenilirliƒüi azaltabilmesi", "Bir i≈ülemci birden √ßok anlama geldiƒüinde, programcƒ±nƒ±n o anki baƒülamda hangi i≈ülemin yapƒ±ldƒ±ƒüƒ±nƒ± anlamasƒ± zorla≈üabilir. Bu durum, fark edilmesi g√º√ß hatalara yol a√ßarak kodun okunabilirliƒüini ve g√ºvenilirliƒüini azaltabilir."],
    ["Sadece sayƒ±sal i≈ülemcilerle sƒ±nƒ±rlƒ± olmasƒ±", "Hayƒ±r, `+`'nƒ±n metin birle≈ütirmesi gibi farklƒ± t√ºrlerde de uygulanabilir."],
    ["Derleme s√ºresini √ßok uzatmasƒ±", "Derleme s√ºresine etkisi genellikle ihmal edilebilir d√ºzeydedir."]
  ],
  answer: 2,
  summary: "ƒ∞≈ülemci y√ºklemesi g√º√ßl√º bir √∂zellik olsa da, 'k√∂t√ºye kullanƒ±ldƒ±ƒüƒ±nda' kafa karƒ±≈ütƒ±rƒ±cƒ± kodlara yol a√ßabilir. Bir sembol√ºn beklenmedik bir i≈ü yapmasƒ±, programdaki hatalarƒ± bulmayƒ± zorla≈ütƒ±rƒ±r. Bu nedenle dikkatli kullanƒ±lmalƒ±dƒ±r."
},
{
  q: "18. Bir altprogramƒ±n ismini ve varsa tipleriyle birlikte parametrelerini belirten kƒ±smƒ±na ne denir?",
  options: [
    ["Altprogram G√∂vdesi", "G√∂vde, altprogram √ßalƒ±≈ütƒ±ƒüƒ±nda y√ºr√ºt√ºlecek olan deyimleri i√ßerir."],
    ["Altprogram Ba≈ülƒ±ƒüƒ±", "Altprogram ba≈ülƒ±ƒüƒ±, o altprogramƒ±n 'kimliƒüini' ve 'dƒ±≈ü d√ºnyadan ne beklediƒüini' tanƒ±mlar. ƒ∞smi ve alacaƒüƒ± parametreler bu ba≈ülƒ±kta belirtilir."],
    ["Altprogram Deƒüi≈ükeni", "Bu, altprogram i√ßinde tanƒ±mlanmƒ±≈ü yerel bir deƒüi≈ükendir."],
    ["Altprogram D√∂ng√ºs√º", "D√∂ng√º, altprogram i√ßinde yer alabilen bir yapƒ±dƒ±r, ba≈ülƒ±ƒüƒ±n kendisi deƒüildir."],
    ["Altprogram Kapsamƒ±", "Kapsam, altprogramƒ±n ge√ßerlilik alanƒ±dƒ±r."]
  ],
  answer: 1,
  summary: "Bir altprogram iki ana b√∂l√ºmden olu≈üur. Ba≈ülƒ±k, altprogramƒ±n 'imzasƒ±' gibidir; nasƒ±l √ßaƒürƒ±lacaƒüƒ±nƒ± belirtir. G√∂vde ise bu imzanƒ±n arkasƒ±ndaki 'i≈ü mantƒ±ƒüƒ±'dƒ±r; √ßaƒürƒ±ldƒ±ƒüƒ±nda ne yapacaƒüƒ±nƒ± belirtir."
},
{
  q: "19. A≈üaƒüƒ±dakilerden hangisi bir 'ifade (expression)' deƒüildir?",
  options: [
    ["`a + b`", "Bu, bir toplama i≈ülemi sonucu yeni bir sayƒ±sal deƒüer √ºreten bir ifadedir."],
    ["`sayac >= 10`", "Bu, bir kar≈üƒ±la≈ütƒ±rma sonucu `true` veya `false` deƒüeri √ºreten bir ifadedir."],
    ["`'Merhaba'`", "Bu, kendi ba≈üƒ±na bir karakter dizisi deƒüeri olan bir ifadedir (sabit ifade)."],
    ["`x = 5;`", "Bu, bir eylem ger√ßekle≈ütiren (atama) bir 'deyim (statement)'dir. Kendi ba≈üƒ±na yeni bir deƒüer √ºretmez, var olan bir deƒüi≈ükenin deƒüerini deƒüi≈ütirir."],
    ["`hesapla()`", "Bu, bir fonksiyon √ßaƒürƒ±sƒ±dƒ±r ve eƒüer `hesapla` fonksiyonu bir deƒüer d√∂nd√ºr√ºyorsa, bu da bir ifadedir."]
  ],
  answer: 3,
  summary: "ƒ∞fade ve deyim arasƒ±ndaki temel fark ≈üudur: ƒ∞fadeler 'deƒüerlendirilir' ve bir sonuca ula≈üƒ±r (sonu√ß bir sayƒ±, metin veya mantƒ±ksal deƒüer olabilir). Deyimler ise 'y√ºr√ºt√ºl√ºr' ve bir eylem ger√ßekle≈ütirir."
},
{
  q: "20. `-` sembol√ºn√ºn, `-5` ifadesinde tekli (unary) i≈ülemci, `10 - 5` ifadesinde ise ikili (binary) i≈ülemci olarak kullanƒ±lmasƒ±, hangi kavrama doƒürudan bir √∂rnektir?",
  options: [
    ["ƒ∞≈ülemci √ñnceliƒüi", "Bu durum √∂ncelikle ilgili deƒüildir."],
    ["ƒ∞≈ülemci Y√ºklemesi (Operator Overloading)", "Aynƒ± sembol√ºn (`-`), i≈ülenen sayƒ±sƒ±na baƒülƒ± olarak farklƒ± g√∂revler (negatif yapma ve √ßƒ±karma) √ºstlenmesi, i≈ülemci y√ºklemesinin bir ba≈üka tipik √∂rneƒüidir."],
    ["S√∂zdizim Hatasƒ±", "Bu bir hata deƒüil, dilin ge√ßerli bir √∂zelliƒüidir."],
    ["Saƒü Associativity", "Bu durum birle≈üme y√∂n√ºyle ilgili deƒüildir."],
    ["Tip Uyumsuzluƒüu", "Bu durum tip uyumsuzluƒüu ile ilgili deƒüildir."]
  ],
  answer: 1,
  summary: "Bir√ßok dilde `-` i≈ülemcisi, hem bir sayƒ±nƒ±n i≈üaretini deƒüi≈ütirmek hem de iki sayƒ±yƒ± birbirinden √ßƒ±karmak i√ßin 'y√ºklenmi≈ütir'. Derleyici, i≈ülemcinin yanƒ±nda bir mi yoksa iki mi i≈ülenen olduƒüuna bakarak hangi g√∂revi yapacaƒüƒ±na karar verir."
},
{
  q: "21. Birle≈üik deyimlerin temel amacƒ± nedir?",
  options: [
    ["Programƒ± daha yava≈ü hale getirmek", "B√∂yle bir amacƒ± yoktur."],
    ["Sadece bir deyimin √ßalƒ±≈ümasƒ±nƒ± saƒülamak", "Tam tersine, birden √ßok deyimin bir b√ºt√ºn olarak √ßalƒ±≈ümasƒ±nƒ± saƒülar."],
    ["Bir dizi deyimin mantƒ±ksal olarak tek bir deyim gibi soyutlanmasƒ±nƒ± saƒülamak", "Bir `if` ko≈üulu saƒülandƒ±ƒüƒ±nda sadece tek bir satƒ±rƒ±n deƒüil, bir dizi i≈ülemin yapƒ±lmasƒ±nƒ± istiyorsak, o i≈ülemleri birle≈üik bir deyim (√∂rn: `begin...end` bloƒüu) i√ßine alƒ±rƒ±z."],
    ["T√ºm basit deyimleri ortadan kaldƒ±rmak", "Basit deyimlerin gruplanmasƒ± i√ßin kullanƒ±lƒ±rlar, onlarƒ± ortadan kaldƒ±rmazlar."],
    ["Programƒ±n bellek kullanƒ±mƒ±nƒ± azaltmak", "Doƒürudan bir bellek azaltma amacƒ± yoktur."]
  ],
  answer: 2,
  summary: "Birle≈üik deyimler, programlamada 'paketleme' i≈ülevi g√∂r√ºr. Birden √ßok komutu tek bir paket haline getirerek, bu paketin kontrol yapƒ±larƒ± (`if`, `while` vb.) tarafƒ±ndan tek bir birim olarak y√∂netilmesini saƒülarlar."
},
{
  q: "22. `(a>0) and (b<100)` gibi bir yapƒ±, hangi ifade t√ºr√ºne girer?",
  options: [
    ["Sayƒ±sal ƒ∞fade", "Sonucu sayƒ±sal bir deƒüer deƒüildir."],
    ["ƒ∞li≈ükisel ƒ∞fade", "Bu yapƒ±, iki ili≈ükisel ifadenin birle≈üiminden olu≈üur, ancak kendisi daha genel bir kategoriye aittir."],
    ["Mantƒ±ksal ƒ∞fade", "ƒ∞ki veya daha fazla ili≈ükisel ifadenin `AND`, `OR` gibi mantƒ±ksal i≈ülemcilerle birle≈ütirilmesiyle olu≈üan ve sonu√ßta `true` veya `false` deƒüeri √ºreten yapƒ±lara mantƒ±ksal ifade denir."],
    ["Basit ƒ∞fade", "Bu, birden √ßok par√ßa i√ßerdiƒüi i√ßin basit bir ifade deƒüildir."],
    ["Atama ƒ∞fadesi", "Bu bir atama i≈ülemi deƒüildir."]
  ],
  answer: 2,
  summary: "Mantƒ±ksal ifadeler, programlarƒ±n karma≈üƒ±k kararlar almasƒ±nƒ± saƒülar. Sadece tek bir ko≈üula deƒüil, 'hem bu doƒüruysa hem de ≈üu doƒüruysa' gibi birden √ßok ko≈üulun aynƒ± anda deƒüerlendirilmesine olanak tanƒ±rlar."
},
{
  q: "23. A≈üaƒüƒ±dakilerden hangisi bir yinelemeli (iterative) deyim √∂rneƒüi deƒüildir?",
  options: [
    ["`while`", "While d√∂ng√ºs√º, bir ko≈üul doƒüru olduƒüu s√ºrece tekrarlanan bir yinelemeli deyimdir."],
    ["`for`", "For d√∂ng√ºs√º, genellikle belirli bir sayƒ±da tekrarlanan bir yinelemeli deyimdir."],
    ["`until`", "Until d√∂ng√ºs√º, bir ko≈üul doƒüru olana kadar tekrarlanan bir yinelemeli deyimdir."],
    ["`case` (`switch`)", "`case`, bir deƒüi≈ükenin deƒüerine g√∂re farklƒ± kod yollarƒ±ndan birini se√ßen bir se√ßimli deyimdir, yineleme yapmaz."],
    ["T√ºm√º yinelemeli deyimdir.", "Hayƒ±r, `case` se√ßimli bir deyimdir."]
  ],
  answer: 3,
  summary: "Program akƒ±≈üƒ±nƒ± kontrol eden deyimler temel olarak ikiye ayrƒ±lƒ±r: Karar verenler (se√ßimli deyimler) ve tekrar edenler (yinelemeli deyimler). `if` ve `case` karar verirken, `while` ve `for` tekrar eder."
},
{
  q: "24. C dilinde 'e≈üit deƒüil' kontrol√º i√ßin `!=` sembol√º kullanƒ±lƒ±rken, Pascal dilinde hangi sembol kullanƒ±lƒ±r?",
  options: [
    ["=", "Bu, Pascal'da 'e≈üit' kontrol√º i√ßin kullanƒ±lƒ±r."],
    ["==", "Bu, C'de 'e≈üit' kontrol√º i√ßin kullanƒ±lƒ±r."],
    ["<>", "Pascal dilinde, 'e≈üit deƒüil' anlamƒ± i√ßin k√º√ß√ºkt√ºr ve b√ºy√ºkt√ºr i≈üaretlerinden olu≈üan `<>` sembol√º kullanƒ±lƒ±r."],
    ["NOT=", "Bu genellikle bir dil i≈ülemcisi deƒüildir."],
    [":=", "Bu, Pascal'da atama i√ßin kullanƒ±lƒ±r."]
  ],
  answer: 2,
  summary: "Dillerin s√∂zdizimsel farklƒ±lƒ±klarƒ±, 'e≈üit deƒüil' gibi temel bir i≈ülemde bile kendini g√∂sterir. C ve ondan t√ºreyen bir√ßok dil `!=` kullanƒ±rken, Pascal ve SQL gibi diller `<>` sembol√ºn√º tercih eder."
},
{
  q: "25. `a + b > c` ifadesindeki i≈ülem sƒ±rasƒ± nasƒ±ldƒ±r?",
  options: [
    ["√ñnce `b > c` kar≈üƒ±la≈ütƒ±rmasƒ±, sonra `a` ile toplama yapƒ±lƒ±r.", "Bu, √∂ncelik kurallarƒ±na aykƒ±rƒ±dƒ±r."],
    ["√ñnce `a + b` toplamasƒ±, sonra `c` ile kar≈üƒ±la≈ütƒ±rma yapƒ±lƒ±r.", "Sayƒ±sal i≈ülemcilerin (`+`) √∂nceliƒüi, ili≈ükisel i≈ülemcilerden (`>`) daha y√ºksek olduƒüu i√ßin, √∂nce toplama i≈ülemi yapƒ±lƒ±r, ardƒ±ndan √ßƒ±kan sonu√ß `c` ile kar≈üƒ±la≈ütƒ±rƒ±lƒ±r."],
    ["ƒ∞≈ülemler soldan saƒüa sƒ±rayla yapƒ±lƒ±r.", "Bu sadece aynƒ± √∂ncelikli i≈ülemciler i√ßin ge√ßerlidir."],
    ["ƒ∞fade ge√ßersizdir, √ß√ºnk√º sayƒ±sal ve ili≈ükisel i≈ülemciler bir arada kullanƒ±lamaz.", "Hayƒ±r, bu ge√ßerli bir ifadedir."],
    ["√ñnce `a > c` kar≈üƒ±la≈ütƒ±rmasƒ± yapƒ±lƒ±r.", "Bu mantƒ±ksal olarak hatalƒ±dƒ±r."]
  ],
  answer: 1,
  summary: "Derleyicinin bir ifadeyi nasƒ±l 'g√∂rd√ºƒü√ºn√º' anlamak √∂nemlidir. `a + b > c` ifadesini g√∂rd√ºƒü√ºnde, √∂nce daha y√ºksek √∂ncelikli olan `+` i≈ülemini yapmak i√ßin `(a + b)`'yi gruplar, daha sonra bu grubun sonucunu `> c` ile kar≈üƒ±la≈ütƒ±rƒ±r."
}    
  ];

  const quizDiv = document.getElementById('quiz');
  const optionLabels = ['A)', 'B)', 'C)', 'D)', 'E)'];
  const userAnswers = new Array(questions.length).fill(null);


  questions.forEach((qObj, index) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'question-container';
    questionContainer.id = `question-${index}`;

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = qObj.q;
    questionContainer.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options-group';

    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback';
    feedbackDiv.style.display = 'none'; // Initially hidden

    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'summary';
    summaryDiv.style.display = 'none'; // Initially hidden


    qObj.options.forEach((opt, i) => {
      const optDiv = document.createElement('div');
      optDiv.className = 'option';
      optDiv.textContent = `${optionLabels[i]} ${opt[0]}`;
      optDiv.onclick = () => {
        // Clear previous selection visuals for this question
        const allOptsInGroup = optsDiv.querySelectorAll('.option');
        allOptsInGroup.forEach(el => el.classList.remove('selected'));
        optDiv.classList.add('selected'); // Mark as selected

        userAnswers[index] = i; // Store user's answer

        // Show feedback immediately
        const feedbackText = opt[1] || (i === qObj.answer ? "Doƒüru cevap!" : "Yanlƒ±≈ü cevap."); // Fallback feedback
        feedbackDiv.className = 'feedback ' + (i === qObj.answer ? 'correct' : 'incorrect');
        feedbackDiv.style.display = 'block';
        feedbackDiv.textContent = (i === qObj.answer ? '‚úîÔ∏è Doƒüru: ' : '‚ùå Yanlƒ±≈ü: ') + feedbackText;


        if (i === qObj.answer && qObj.summary) {
          summaryDiv.style.display = 'block';
          summaryDiv.textContent = 'üí° ' + qObj.summary;
        } else {
          summaryDiv.style.display = 'none';
        }
      };
      optsDiv.appendChild(optDiv);
    });

    questionContainer.appendChild(optsDiv);
    questionContainer.appendChild(feedbackDiv);
    questionContainer.appendChild(summaryDiv);
    quizDiv.appendChild(questionContainer);
  });

  function showResults() {
    let correctCount = 0;
    userAnswers.forEach((answer, index) => {
        if (answer !== null && answer === questions[index].answer) {
            correctCount++;
        }
    });

    const totalQuestions = questions.length;
    const scorePercentage = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(2) : 0;

    document.getElementById('total-questions').textContent = totalQuestions;
    document.getElementById('correct-answers').textContent = correctCount;
    document.getElementById('score-percentage').textContent = scorePercentage;
    document.getElementById('results-summary').style.display = 'block';

    // Scroll to results
    document.getElementById('results-summary').scrollIntoView({ behavior: 'smooth' });
  }

</script>
</body>
</html>