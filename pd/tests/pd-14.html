<!DOCTYPE html>
<html lang="tr">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Programlama Dilleri - 14</title>
  <style>
    body { font-family: 'PT Sans', 'Trebuchet MS', sans-serif; background: #f9f9f9; padding: 20px; color: #333; }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .question-container { background: #fff; padding: 20px; margin-bottom: 25px; border-left: 5px solid #007BFF; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-text { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; }
    .option { padding: 10px; margin: 8px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; transition: background-color 0.2s ease-in-out; }
    .option:hover { background: #e9ecef; }
    .option.selected { background-color: #cce5ff; border-color: #b8daff; }
    .feedback { margin-top: 15px; padding: 12px; border-radius: 4px; display: none; font-weight: bold; }
    .correct { background: #d4edda; border-left: 5px solid #28a745; color: #155724; }
    .incorrect { background: #f8d7da; border-left: 5px solid #dc3545; color: #721c24; }
    .summary { display: none; background: #fff3cd; padding: 12px; margin-top: 10px; border-left: 5px solid #ffc107; border-radius: 4px; color: #856404; }
    button#submit-all {
        display: block;
        margin: 30px auto;
        padding: 12px 25px;
        font-size: 1.1em;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    button#submit-all:hover {
        background-color: #218838;
    }
    .results { margin-top: 30px; padding: 20px; background-color: #e9ecef; border-radius: 5px; text-align: center;}
  </style>
</head>
<body>
<h1>Programlama Dilleri - 14</h1>
<div id="quiz">
  </div>
<button id="submit-all" onclick="showResults()">TÃ¼m Testi Bitir ve SonuÃ§larÄ± GÃ¶r</button>
<div id="results-summary" class="results" style="display:none;">
    <h2>Test Sonucu</h2>
    <p>Toplam Soru: <span id="total-questions"></span></p>
    <p>DoÄŸru Cevap SayÄ±sÄ±: <span id="correct-answers"></span></p>
    <p>BaÅŸarÄ± YÃ¼zdesi: <span id="score-percentage"></span>%</p>
</div>

<script>
  const questions = [
{
  q: "1. Bir programlama dilinin 'tam (pure) nesneye yÃ¶nelik' olarak kabul edilmesinin temel gereksinimi nedir?",
  options: [
    ["Ã‡oklu kalÄ±tÄ±mÄ± desteklemesi", "Bu bir gereksinim deÄŸildir, Ã¶rneÄŸin Java tam nesneye yÃ¶neliktir ama Ã§oklu kalÄ±tÄ±mÄ± desteklemez."],
    ["Dildeki tÃ¼m verilerin nesne ÅŸeklinde gÃ¶sterilebilmesi", "Tam nesneye yÃ¶nelik bir dilde, `int` gibi ilkel veri tipleri bile aslÄ±nda birer nesnedir. Her ÅŸeyin nesne olduÄŸu bu yaklaÅŸÄ±m, dilin tutarlÄ±lÄ±ÄŸÄ±nÄ± artÄ±rÄ±r."],
    ["GÃ¶sterge (pointer) veri tipinin bulunmasÄ±", "Tam tersine, Java gibi bazÄ± tam nesneye yÃ¶nelik dillerde gÃ¶stergeler bulunmaz."],
    ["Sadece imperative paradigmayÄ± desteklemesi", "Nesneye yÃ¶nelik paradigma esastÄ±r."],
    ["Derleyiciye sahip olmasÄ±", "Bu, dilin gerÃ§ekleÅŸtirim ÅŸeklidir, paradigmasÄ±yla ilgili deÄŸildir."]
  ],
  answer: 1,
  summary: "C++ gibi hibrit dillerde `int` bir nesne deÄŸilken, Smalltalk veya Java gibi tam nesneye yÃ¶nelik dillerde her ÅŸey bir nesnedir. Bu, tam nesneye yÃ¶nelikliÄŸin en temel ayÄ±rt edici Ã¶zelliÄŸidir."
},
{
  q: "2. SOLID prensiplerinin temel amacÄ± aÅŸaÄŸÄ±dakilerden hangisidir?",
  options: [
    ["ProgramlarÄ±n her zaman en hÄ±zlÄ± ÅŸekilde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak.", "Performans bir sonuÃ§ olabilir ama temel amaÃ§ deÄŸildir."],
    ["SÃ¼rdÃ¼rÃ¼lebilir, anlaÅŸÄ±labilir, esnek ve yeniden kullanÄ±labilir yazÄ±lÄ±mlar geliÅŸtirmek.", "SOLID prensipleri, kodun zamanla karmaÅŸÄ±klaÅŸmasÄ±nÄ± ('Spaghetti Code') Ã¶nleyerek, bakÄ±mÄ±nÄ±n ve geliÅŸtirilmesinin kolay olduÄŸu 'Temiz Kod' (Clean Code) yazmak iÃ§in bir dizi kural sunar."],
    ["Sadece tek bir programcÄ±nÄ±n anlayabileceÄŸi kodlar yazmak.", "Tam tersine, takÄ±m Ã§alÄ±ÅŸmasÄ±nÄ± ve kodun anlaÅŸÄ±lÄ±rlÄ±ÄŸÄ±nÄ± artÄ±rmayÄ± hedefler."],
    ["YazÄ±lÄ±m geliÅŸtirme sÃ¼recini kÄ±saltmak.", "BaÅŸlangÄ±Ã§ta sÃ¼reci biraz uzatabilir ama uzun vadede bakÄ±m ve geliÅŸtirme sÃ¼resini kÄ±saltÄ±r."],
    ["Programdaki hata sayÄ±sÄ±nÄ± sÄ±fÄ±ra indirmek.", "HatalarÄ± azaltmayÄ± hedefler ama sÄ±fÄ±ra indirmeyi garanti edemez."]
  ],
  answer: 1,
  summary: "SOLID, iyi bir yazÄ±lÄ±m mimarisi kurmanÄ±n beÅŸ temel taÅŸÄ±dÄ±r. Bu prensipler, yazÄ±lan kodun bugÃ¼nÃ¼ kurtarmasÄ±nÄ± deÄŸil, gelecekteki deÄŸiÅŸikliklere ve yeni ihtiyaÃ§lara kolayca adapte olabilmesini hedefler."
},
{
  q: "3. 'Tek Sorumluluk Prensibi' (Single Responsibility Principle) neyi ifade eder?",
  options: [
    ["Bir projedeki tÃ¼m iÅŸlerden tek bir programcÄ±nÄ±n sorumlu olmasÄ± gerektiÄŸini.", "Bu, proje yÃ¶netimi ile ilgili bir konudur."],
    ["Bir sÄ±nÄ±fÄ±n veya metodun deÄŸiÅŸmesi iÃ§in sadece tek bir nedenin olmasÄ± gerektiÄŸini.", "Bu prensibe gÃ¶re, bir sÄ±nÄ±fÄ±n veya metodun birden Ã§ok sorumluluÄŸu olmamalÄ±dÄ±r. Her sÄ±nÄ±f veya metot, sadece bir iÅŸ yapmalÄ± ve o iÅŸi iyi yapmalÄ±dÄ±r."],
    ["Bir sÄ±nÄ±fÄ±n sadece tek bir alt sÄ±nÄ±fÄ± olabileceÄŸini.", "Bu kalÄ±tÄ±mla ilgili bir kÄ±sÄ±tlama deÄŸildir."],
    ["Bir projenin sadece tek bir programlama diliyle yazÄ±lmasÄ± gerektiÄŸini.", "Bu bir zorunluluk deÄŸildir."],
    ["Bir metodun sadece tek bir satÄ±r kod iÃ§ermesi gerektiÄŸini.", "Bu gerÃ§ekÃ§i bir beklenti deÄŸildir."]
  ],
  answer: 1,
  summary: "Tek Sorumluluk Prensibi, 'Herkes kendi iÅŸini yapsÄ±n' der. Bir metodun hem veritabanÄ±na kayÄ±t ekleyip hem de kullanÄ±cÄ±ya e-posta gÃ¶ndermesi bu prensibin ihlalidir. Bu iki iÅŸ, ayrÄ± ayrÄ± metotlara bÃ¶lÃ¼nmelidir."
},
{
  q: "4. C++ dilini, C dilinden ayÄ±ran ve ona eklenen ilk nesneye yÃ¶nelik Ã¶zellikler arasÄ±nda hangisi yer almaz?",
  options: [
    ["SÄ±nÄ±f tanÄ±mlama ve tÃ¼retme", "Bu, C'ye eklenen temel OOP Ã¶zelliÄŸidir."],
    ["Public/private eriÅŸim kontrolÃ¼", "Bu, kapsÃ¼lleme iÃ§in eklenen temel bir Ã¶zelliktir."],
    ["Constructor / destructor metotlarÄ±", "Bunlar, nesne yaratÄ±ldÄ±ÄŸÄ±nda ve yok edildiÄŸinde Ã§alÄ±ÅŸan Ã¶zel metotlardÄ±r."],
    ["Metod yÃ¼kleme (overloading)", "Bu da C++'Ä±n ilk sÃ¼rÃ¼mlerinde C'ye eklenen bir Ã¶zelliktir."],
    ["Ã‡oklu kalÄ±tÄ±m ve sanal metotlar", "Ã‡oklu kalÄ±tÄ±m ve sanal metotlar gibi daha geliÅŸmiÅŸ Ã¶zellikler, C++'a daha sonraki aÅŸamalarda eklenmiÅŸtir."]
  ],
  answer: 4,
  summary: "C++, C dilinin Ã¼zerine bir 'nesneye yÃ¶nelik katman' eklenerek doÄŸmuÅŸtur. Ä°lk baÅŸta sÄ±nÄ±f, temel kalÄ±tÄ±m, eriÅŸim kontrolÃ¼ ve constructor/destructor gibi temel OOP yapÄ±larÄ± eklenmiÅŸ, zamanla Ã§oklu kalÄ±tÄ±m gibi daha karmaÅŸÄ±k Ã¶zellikler dahil edilmiÅŸtir."
},
{
  q: "5. 'AÃ§Ä±k/KapalÄ± Prensibi' (Open/Closed Principle) ne anlama gelir?",
  options: [
    ["Bir sÄ±nÄ±fÄ±n kaynak kodunun herkese aÃ§Ä±k, ancak deÄŸiÅŸtirilmesinin yasak olmasÄ± gerektiÄŸini.", "Bu, aÃ§Ä±k kaynak lisanslarÄ±yla ilgili bir konudur."],
    ["Bir nesnenin geliÅŸtirilmeye (yeni Ã¶zellikler eklemeye) aÃ§Ä±k, ancak deÄŸiÅŸtirilmeye (mevcut kodunu bozmaya) kapalÄ± olmasÄ± gerektiÄŸini.", "Bu prensip, var olan ve Ã§alÄ±ÅŸan bir kodu deÄŸiÅŸtirmeden sisteme yeni iÅŸlevler ekleyebilmemiz gerektiÄŸini sÃ¶yler. Bu genellikle kalÄ±tÄ±m veya arayÃ¼zler aracÄ±lÄ±ÄŸÄ±yla saÄŸlanÄ±r."],
    ["Bir projenin hem aÃ§Ä±k hem de kapalÄ± kaynak kodlu olabileceÄŸini.", "Bu, lisanslama ile ilgili bir konudur."],
    ["SÄ±nÄ±flarÄ±n kapÄ±larÄ±nÄ±n yeni Ã¶zelliklere kapalÄ± olmasÄ± gerektiÄŸini.", "Tam tersine, yeni Ã¶zelliklere 'aÃ§Ä±k' olmalÄ±dÄ±r."],
    ["TÃ¼m metotlarÄ±n public (aÃ§Ä±k) olmasÄ± gerektiÄŸini.", "Bu, kapsÃ¼lleme ilkesini ihlal eder."]
  ],
  answer: 1,
  summary: "AÃ§Ä±k/KapalÄ± Prensibi, 'Mevcut sisteme dokunma, ona eklentiler yaparak geniÅŸlet' der. Bu, Ã§alÄ±ÅŸan bir sistemin yeni bir Ã¶zellik eklenirken bozulma riskini ortadan kaldÄ±rÄ±r."
},
{
  q: "6. Java ve C++ dilleri arasÄ±ndaki temel farklardan biri aÅŸaÄŸÄ±dakilerden hangisidir?",
  options: [
    ["C++, nesneye yÃ¶nelik programlamayÄ± desteklerken Java desteklemez.", "Her ikisi de nesneye yÃ¶nelik programlamayÄ± gÃ¼Ã§lÃ¼ bir ÅŸekilde destekler."],
    ["Java gÃ¶sterge (pointer) tipini desteklerken C++ desteklemez.", "Tam tersi doÄŸrudur. C++ gÃ¶stergeleri desteklerken, Java gÃ¼venlik nedenleriyle doÄŸrudan gÃ¶sterge kullanÄ±mÄ±na izin vermez."],
    ["C++ platformdan baÄŸÄ±msÄ±zken Java deÄŸildir.", "Tam tersi doÄŸrudur. Java, JVM sayesinde platformdan baÄŸÄ±msÄ±zdÄ±r."],
    ["Java tekli kalÄ±tÄ±ma izin verirken C++ Ã§oklu kalÄ±tÄ±mÄ± da destekler.", "Bu, iki dil arasÄ±ndaki en temel mimari farklardan biridir. Java, Ã§oklu kalÄ±tÄ±mÄ±n karmaÅŸÄ±klÄ±ÄŸÄ±ndan arayÃ¼zler (interfaces) kullanarak kaÃ§Ä±nÄ±r."],
    ["Java'da otomatik Ã§Ã¶p toplayÄ±cÄ± (garbage collection) yoktur.", "Tam tersine, otomatik Ã§Ã¶p toplayÄ±cÄ± Java'nÄ±n en Ã¶nemli Ã¶zelliklerinden biridir."]
  ],
  answer: 3,
  summary: "Java ve C++ benzer sÃ¶zdizimlerine sahip olsalar da, felsefi olarak Ã¶nemli noktalarda ayrÄ±lÄ±rlar. Java gÃ¼venliÄŸi ve taÅŸÄ±nabilirliÄŸi Ã¶n planda tutarken (gÃ¶sterge yok, tekli kalÄ±tÄ±m, Ã§Ã¶p toplayÄ±cÄ± var), C++ performansÄ± ve donanÄ±ma yakÄ±nlÄ±ÄŸÄ± (gÃ¶sterge var, Ã§oklu kalÄ±tÄ±m, manuel bellek yÃ¶netimi) Ã¶n planda tutar."
},
{
  q: "7. 'Liskov Yerine GeÃ§me Prensibi' (Liskov Substitution Principle) temel olarak neyi ÅŸart koÅŸar?",
  options: [
    ["Ãœst sÄ±nÄ±flarÄ±n, alt sÄ±nÄ±flarÄ±n yerine kullanÄ±labilmesi gerektiÄŸini.", "Tam tersi doÄŸrudur."],
    ["TÃ¼retilmiÅŸ alt sÄ±nÄ±flarÄ±n, miras aldÄ±klarÄ± Ã¼st sÄ±nÄ±fÄ±n yerine, programÄ±n doÄŸruluÄŸunu bozmadan kullanÄ±labilmesi gerektiÄŸini.", "Bu prensip, bir alt sÄ±nÄ±fÄ±n, Ã¼st sÄ±nÄ±fÄ±n 'sÃ¶zleÅŸmesine' tamamen uymasÄ± gerektiÄŸini sÃ¶yler. `Kare` sÄ±nÄ±fÄ±, eÄŸer `DikdÃ¶rtgen` sÄ±nÄ±fÄ±nÄ±n yerine geÃ§tiÄŸinde programda beklenmedik hatalara yol aÃ§Ä±yorsa, bu prensip ihlal edilmiÅŸ demektir."],
    ["TÃ¼m sÄ±nÄ±flarÄ±n birbirinden baÄŸÄ±msÄ±z olmasÄ± gerektiÄŸini.", "Bu, kalÄ±tÄ±m kavramÄ±na aykÄ±rÄ±dÄ±r."],
    ["ArayÃ¼zlerin, sÄ±nÄ±flarÄ±n yerine kullanÄ±lmasÄ± gerektiÄŸini.", "Bu, BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±n Ters Ã‡evrilmesi Prensibi ile ilgilidir."],
    ["Sadece aynÄ± isimli metotlarÄ±n birbirinin yerine geÃ§ebileceÄŸini.", "Bu Ã§ok dar bir tanÄ±mdÄ±r."]
  ],
  answer: 1,
  summary: "Liskov Yerine GeÃ§me Prensibi, 'EÄŸer bir Ã¶rdeÄŸe benziyor, Ã¶rdek gibi yÃ¼zÃ¼yor ve Ã¶rdek gibi vaklÄ±yorsa, o zaman muhtemelen bir Ã¶rdektir' sÃ¶zÃ¼nÃ¼n programlamadaki karÅŸÄ±lÄ±ÄŸÄ±dÄ±r. Bir alt sÄ±nÄ±f, Ã¼st sÄ±nÄ±fÄ±nÄ±n tÃ¼m davranÄ±ÅŸlarÄ±nÄ± eksiksiz sergileyebilmelidir."
},
{
  q: "8. Bir nesne yaratÄ±ldÄ±ÄŸÄ±nda bir kez Ã§alÄ±ÅŸtÄ±rÄ±lan Ã¶zel metoda ne denir?",
  options: [
    ["Destructor (Yok Edici)", "Bu metot, bir nesne yok edildiÄŸi zaman Ã§alÄ±ÅŸÄ±r."],
    ["Virtual Metod", "Bu, dinamik baÄŸlama iÃ§in kullanÄ±lan bir metottur."],
    ["Static Metod", "Bu, nesne yaratÄ±lmadan da Ã§aÄŸrÄ±labilen bir metottur."],
    ["Constructor (YapÄ±cÄ±)", "Constructor, bir sÄ±nÄ±ftan yeni bir nesne oluÅŸturulduÄŸu anda otomatik olarak Ã§aÄŸrÄ±lan ve genellikle nesnenin baÅŸlangÄ±Ã§ ayarlarÄ±nÄ± (ilk deÄŸer atamalarÄ±nÄ±) yapan Ã¶zel bir metottur."],
    ["Abstract Metod", "Bu, gÃ¶vdesi olmayan ve alt sÄ±nÄ±flar tarafÄ±ndan gerÃ§ekleÅŸtirilmesi gereken bir metottur."]
  ],
  answer: 3,
  summary: "Constructor (YapÄ±cÄ± Metot), bir nesnenin 'doÄŸum anÄ±nda' Ã§alÄ±ÅŸan bir koddur. Bir araba nesnesi yaratÄ±ldÄ±ÄŸÄ±nda, rengini, modelini ve baÅŸlangÄ±Ã§ hÄ±zÄ±nÄ± ayarlayan kod yapÄ±cÄ± metot iÃ§inde yer alÄ±r."
},
{
  q: "9. 'ArayÃ¼z AyÄ±rÄ±mÄ± Prensibi' (Interface Segregation Principle) neyi savunur?",
  options: [
    ["TÃ¼m sÄ±nÄ±flarÄ±n tek bir bÃ¼yÃ¼k arayÃ¼zÃ¼ gerÃ§ekleÅŸtirmesi gerektiÄŸini.", "Tam tersini savunur."],
    ["Nesnelerin, ihtiyaÃ§larÄ± olmayan metotlarÄ± iÃ§eren arayÃ¼zleri gerÃ§ekleÅŸtirmeye zorlanmamasÄ± gerektiÄŸini.", "Bu prensip, genel amaÃ§lÄ±, bÃ¼yÃ¼k arayÃ¼zler yerine, her birinin belirli bir yeteneÄŸi tanÄ±mladÄ±ÄŸÄ± daha kÃ¼Ã§Ã¼k ve Ã¶zel arayÃ¼zler oluÅŸturmayÄ± Ã¶nerir."],
    ["ArayÃ¼zlerin sadece tek bir metot iÃ§ermesi gerektiÄŸini.", "Birden fazla metot iÃ§erebilir, ancak bu metotlar mantÄ±ksal bir bÃ¼tÃ¼n oluÅŸturmalÄ±dÄ±r."],
    ["SÄ±nÄ±flar yerine sadece arayÃ¼zlerin kullanÄ±lmasÄ± gerektiÄŸini.", "Bu gerÃ§ekÃ§i bir yaklaÅŸÄ±m deÄŸildir."],
    ["ArayÃ¼zlerin birbirinden kalÄ±tÄ±m alamayacaÄŸÄ±nÄ±.", "ArayÃ¼zler birbirinden kalÄ±tÄ±m alabilir."]
  ],
  answer: 1,
  summary: "ArayÃ¼z AyÄ±rÄ±mÄ± Prensibi, 'kimseyi istemediÄŸi bir iÅŸi yapmaya zorlama' der. Bir `Bisiklet` sÄ±nÄ±fÄ±nÄ±, `kapilariAc()` gibi anlamsÄ±z bir metodu iÃ§eren genel bir `Tasit` arayÃ¼zÃ¼nÃ¼ gerÃ§ekleÅŸtirmeye zorlamak yerine, `Surulebilir` ve `Kapili` gibi iki ayrÄ± arayÃ¼z oluÅŸturmak daha doÄŸru bir tasarÄ±mdÄ±r."
},
{
  q: "10. C++'Ä±n 'tam (pure) nesneye yÃ¶nelik' bir programlama dili olarak kabul edilmemesinin sebebi nedir?",
  options: [
    ["Ã‡oklu kalÄ±tÄ±mÄ± desteklemesi", "Bu bir tasarÄ±m tercihidir, tam nesneye yÃ¶neliklikle doÄŸrudan ilgili deÄŸildir."],
    ["Dilde var olan (built-in) ilkel veri tiplerinin (int, char vb.) nesne olarak gÃ¶sterilememesi.", "Tam nesneye yÃ¶nelik bir dilde her ÅŸey bir nesnedir. C++'da `int` gibi ilkel tiplerin nesne olmamasÄ±, onun hem imperative hem de OOP Ã¶zelliklerini barÄ±ndÄ±ran bir hibrit dil olduÄŸunu gÃ¶sterir."],
    ["Dinamik baÄŸlamanÄ±n `virtual` metotlar gerektirmesi", "Bu, dinamik baÄŸlamanÄ±n gerÃ§ekleÅŸtirim ÅŸeklidir, sebepten Ã§ok sonuÃ§tur."],
    ["Constructor ve destructor metotlarÄ±nÄ±n olmasÄ±", "Bu, OOP dillerinde yaygÄ±n bir Ã¶zelliktir."],
    ["C dilinin sÃ¶zdizimini kullanmasÄ±", "SÃ¶zdizimi, dilin paradigmasÄ±nÄ± belirlemez."]
  ],
  answer: 1,
  summary: "C++, C'nin Ã¼zerine kurulduÄŸu iÃ§in onun ilkel veri tiplerini de miras almÄ±ÅŸtÄ±r. Bu durum, C ile uyumluluk ve performans gibi avantajlar saÄŸlarken, dilin 'her ÅŸey bir nesnedir' felsefesine tam olarak uymasÄ±nÄ± engeller."
},
{
  q: "11. 'BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±n Ters Ã‡evrilmesi Prensibi' (Dependency Inversion Principle) neyi Ã¶nerir?",
  options: [
    ["Alt seviye sÄ±nÄ±flarÄ±n, Ã¼st seviye sÄ±nÄ±flara baÄŸÄ±mlÄ± olmasÄ± gerektiÄŸini.", "Tam tersini Ã¶nerir."],
    ["Ãœst seviye sÄ±nÄ±flarÄ±n, alt seviye sÄ±nÄ±flara doÄŸrudan baÄŸÄ±mlÄ± olmamasÄ± gerektiÄŸini.", "Bu prensibe gÃ¶re, hem Ã¼st seviye hem de alt seviye sÄ±nÄ±flar doÄŸrudan birbirlerine deÄŸil, ikisinin de ortak olarak kullandÄ±ÄŸÄ± 'soyutlamalara' (genellikle arayÃ¼zlere) baÄŸÄ±mlÄ± olmalÄ±dÄ±r."],
    ["TÃ¼m sÄ±nÄ±flarÄ±n birbirinden tamamen baÄŸÄ±msÄ±z olmasÄ± gerektiÄŸini.", "Bu, iÅŸ birliÄŸini imkansÄ±z kÄ±lar."],
    ["ArayÃ¼zlerin sÄ±nÄ±flara baÄŸÄ±mlÄ± olmasÄ± gerektiÄŸini.", "Tam tersine, sÄ±nÄ±flar arayÃ¼zlere baÄŸÄ±mlÄ± olmalÄ±dÄ±r."],
    ["BaÄŸÄ±mlÄ±lÄ±klarÄ±n derleme zamanÄ±nda deÄŸil, Ã§alÄ±ÅŸma zamanÄ±nda Ã§Ã¶zÃ¼lmesi gerektiÄŸini.", "Bu, dinamik baÄŸlama ile ilgili bir konudur."]
  ],
  answer: 1,
  summary: "Bu prensip, 'detaylara deÄŸil, soyut kavramlara baÄŸlan' der. Bir `Araba` sÄ±nÄ±fÄ±, doÄŸrudan bir `MichelinLastik` sÄ±nÄ±fÄ±na deÄŸil, genel bir `Lastik` arayÃ¼zÃ¼ne baÄŸÄ±mlÄ± olmalÄ±dÄ±r. Bu sayede gelecekte `PirelliLastik` sÄ±nÄ±fÄ± eklendiÄŸinde `Araba` sÄ±nÄ±fÄ±nÄ± deÄŸiÅŸtirmek gerekmez."
},
{
  q: "12. Nesneye yÃ¶nelik programlamayÄ± popÃ¼lerleÅŸtiren ilk programlama dili olarak kabul edilen ve tÃ¼m baÄŸlamalarÄ±n dinamik olarak yapÄ±ldÄ±ÄŸÄ± dil hangisidir?",
  options: [
    ["C++", "C++'da baÄŸlama genellikle statiktir, `virtual` ile dinamik hale getirilir."],
    ["Java", "Java da dinamik baÄŸlamayÄ± yoÄŸun olarak kullanÄ±r ancak bu Ã¶zelliÄŸiyle tanÄ±nan ilk popÃ¼ler dil Smalltalk'tÄ±r."],
    ["SIMULA 67", "SIMULA 67, OOP'nin temelini atmÄ±ÅŸtÄ±r ancak onu popÃ¼lerleÅŸtiren dil deÄŸildir."],
    ["Eiffel", "Eiffel de Ã¶nemli bir OOP dilidir ancak ilk popÃ¼lerleÅŸen deÄŸildir."],
    ["Smalltalk", "Smalltalk, nesneye yÃ¶nelik programlamanÄ±n sadece bir laboratuvar kavramÄ± olmadÄ±ÄŸÄ±nÄ±, aynÄ± zamanda gÃ¼Ã§lÃ¼ ve dinamik uygulamalar geliÅŸtirmek iÃ§in kullanÄ±labileceÄŸini gÃ¶steren ilk yaygÄ±n dildir. Saf nesne yÃ¶nelimli yapÄ±sÄ± ve dinamik baÄŸlamasÄ± ile bilinir."]
  ],
  answer: 4,
  summary: "SIMULA 67 OOP fikrini ortaya atarken, Smalltalk bu fikri alÄ±p onu yaÅŸayan, nefes alan, tamamen dinamik ve etkileÅŸimli bir programlama ortamÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmÃ¼ÅŸtÃ¼r. GÃ¼nÃ¼mÃ¼zdeki birÃ§ok modern programlama dili ondan ilham almÄ±ÅŸtÄ±r."
},
{
  q: "13. C++'da dinamik baÄŸlamanÄ±n (Ã§okyapÄ±lÄ±lÄ±ÄŸÄ±n) etkinleÅŸtirilebilmesi iÃ§in, Ã¼st sÄ±nÄ±ftaki metodun hangi anahtar kelime ile tanÄ±mlanmasÄ± gerekir?",
  options: [
    ["`static`", "`static` metotlar yeniden tanÄ±mlanamaz ve statik olarak baÄŸlanÄ±r."],
    ["`final`", "`final` metotlar yeniden tanÄ±mlanamaz."],
    ["`abstract`", "`abstract` metotlar gÃ¶vdesizdir, bu farklÄ± bir kavramdÄ±r."],
    ["`virtual`", "Bir Ã¼st sÄ±nÄ±f metodu `virtual` olarak iÅŸaretlendiÄŸinde, derleyiciye 'bu metodun hangi versiyonunun Ã§aÄŸrÄ±lacaÄŸÄ±na Ã§alÄ±ÅŸma zamanÄ±nda, nesnenin gerÃ§ek tipine bakarak karar ver' talimatÄ± verilmiÅŸ olur. Bu, dinamik baÄŸlamayÄ± etkinleÅŸtirir."],
    ["`override`", "`override` anahtar kelimesi, bir metodun Ã¼zerine yazÄ±ldÄ±ÄŸÄ±nÄ± belirtmek iÃ§in kullanÄ±lÄ±r, dinamik baÄŸlamayÄ± etkinleÅŸtirmez."]
  ],
  answer: 3,
  summary: "C++'da performans nedeniyle varsayÄ±lan olarak statik baÄŸlama kullanÄ±lÄ±r. ProgramcÄ±, bir metodun Ã§okyapÄ±lÄ± davranmasÄ±nÄ± istediÄŸinde, bu isteÄŸini `virtual` anahtar kelimesiyle derleyiciye aÃ§Ä±kÃ§a belirtmek zorundadÄ±r."
},
{
  q: "14. Java'da `final` olarak tanÄ±mlanmÄ±ÅŸ bir sÄ±nÄ±f (class) iÃ§in aÅŸaÄŸÄ±dakilerden hangisi doÄŸrudur?",
  options: [
    ["Bu sÄ±nÄ±ftan nesne Ã¼retilemez.", "Bu, `abstract` olarak tanÄ±mlanmÄ±ÅŸ sÄ±nÄ±flar iÃ§in geÃ§erlidir."],
    ["Bu sÄ±nÄ±fÄ±n tÃ¼m metotlarÄ± `static` olmak zorundadÄ±r.", "BÃ¶yle bir zorunluluk yoktur."],
    ["Bu sÄ±nÄ±ftan baÅŸka bir sÄ±nÄ±f tÃ¼retilemez (kalÄ±tÄ±mla alÄ±namaz).", "`final` anahtar kelimesi, bir sÄ±nÄ±fÄ±n kalÄ±tÄ±m hiyerarÅŸisinin 'sonu' olduÄŸunu belirtir. Bu, o sÄ±nÄ±ftan yeni alt sÄ±nÄ±flar oluÅŸturulmasÄ±nÄ± engeller."],
    ["Bu sÄ±nÄ±f sadece tek bir metot iÃ§erebilir.", "BÃ¶yle bir kÄ±sÄ±tlama yoktur."],
    ["Bu sÄ±nÄ±fÄ±n bir arayÃ¼zÃ¼ gerÃ§ekleÅŸtirmesi zorunludur.", "BÃ¶yle bir zorunluluk yoktur."]
  ],
  answer: 2,
  summary: "`final` anahtar kelimesi, 'bu iÅŸin son hali budur, daha fazla deÄŸiÅŸtirilemez' anlamÄ± taÅŸÄ±r. Bir sÄ±nÄ±fa uygulandÄ±ÄŸÄ±nda, o sÄ±nÄ±fÄ±n kalÄ±tÄ±mla geniÅŸletilmesini; bir metoda uygulandÄ±ÄŸÄ±nda ise o metodun alt sÄ±nÄ±flarda Ã¼zerine yazÄ±lmasÄ±nÄ± engeller."
},
{
  q: "15. AÅŸaÄŸÄ±dakilerden hangisi C++ ve Java'da bir nesne yok edildiÄŸi zaman otomatik olarak Ã§aÄŸrÄ±lan Ã¶zel metodun adÄ±dÄ±r?",
  options: [
    ["Constructor (YapÄ±cÄ±)", "Bu, nesne yaratÄ±ldÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lÄ±r."],
    ["Destructor (Yok Edici)", "Bir nesnenin yaÅŸam sÃ¼resi sona erdiÄŸinde (Ã¶rneÄŸin bellekten silinmeden Ã¶nce), kaynaklarÄ± temizlemek veya son iÅŸlemleri yapmak iÃ§in otomatik olarak Ã§aÄŸrÄ±lan metoda destructor denir."],
    ["Finalizer", "Bu, Java'nÄ±n Ã§Ã¶p toplayÄ±cÄ±sÄ± tarafÄ±ndan Ã§aÄŸrÄ±lan, destructor'a benzer bir kavramdÄ±r ancak kullanÄ±mÄ± daha farklÄ±dÄ±r."],
    ["Garbage Collector", "Bu, destructor'Ä± Ã§aÄŸÄ±ran mekanizmanÄ±n adÄ±dÄ±r, metodun kendisi deÄŸil."],
    ["`delete` metodu", "`delete` bir operatÃ¶rdÃ¼r, bir metot adÄ± deÄŸildir."]
  ],
  answer: 1,
  summary: "YapÄ±cÄ± metotlar (constructors) bir nesnenin 'doÄŸumunu' yÃ¶netirken, yok edici metotlar (destructors) o nesnenin 'Ã¶lÃ¼mÃ¼nÃ¼' yÃ¶netir. Ã–zellikle manuel bellek yÃ¶netimi olan C++'da, nesnenin ayÄ±rdÄ±ÄŸÄ± belleÄŸi serbest bÄ±rakmak iÃ§in destructor'lar hayati Ã¶neme sahiptir."
},
{
  q: "16. Java'da Ã§oklu kalÄ±tÄ±mÄ±n getirdiÄŸi sorunlarÄ± yaÅŸamadan benzer bir esneklik saÄŸlamak iÃ§in kullanÄ±lan yapÄ± nedir?",
  options: [
    ["Paketler (Packages)", "Paketler, sÄ±nÄ±flarÄ± gruplamak iÃ§in kullanÄ±lÄ±r."],
    ["Soyut SÄ±nÄ±flar (Abstract Classes)", "Soyut sÄ±nÄ±flar kalÄ±tÄ±m hiyerarÅŸisinin temelini oluÅŸturur ancak tekli kalÄ±tÄ±m kuralÄ±na tabidirler."],
    ["ArayÃ¼zler (Interfaces)", "Java, bir sÄ±nÄ±fÄ±n sadece tek bir Ã¼st sÄ±nÄ±ftan kalÄ±tÄ±m almasÄ±na izin verirken, birden Ã§ok arayÃ¼zÃ¼ 'gerÃ§ekleÅŸtirmesine' (`implements`) olanak tanÄ±r. Bu sayede, farklÄ± kaynaklardan yetenekler kazanarak Ã§oklu kalÄ±tÄ±ma benzer bir yapÄ± daha gÃ¼venli bir ÅŸekilde elde edilir."],
    ["`final` SÄ±nÄ±flar", "`final` sÄ±nÄ±flar kalÄ±tÄ±mÄ± engeller."],
    ["Jenerikler (Generics)", "Jenerikler, tip-gÃ¼venli koleksiyonlar oluÅŸturmak iÃ§in kullanÄ±lÄ±r."]
  ],
  answer: 2,
  summary: "Java'nÄ±n arayÃ¼z (interface) mekanizmasÄ±, Ã§oklu kalÄ±tÄ±mÄ±n 'ne yapabildiÄŸini miras alma' gÃ¼cÃ¼nÃ¼, onun 'nasÄ±l yapÄ±ldÄ±ÄŸÄ±nÄ± miras alma' karmaÅŸÄ±klÄ±ÄŸÄ±ndan ayÄ±rÄ±r. Bir sÄ±nÄ±f, birden Ã§ok 'sÃ¶zleÅŸmeyi' (arayÃ¼zÃ¼) imzalayarak farklÄ± yeteneklere sahip olabilir."
},
{
  q: "17. Bir Java programÄ±, Ã§alÄ±ÅŸmak iÃ§in bir web tarayÄ±cÄ±sÄ±na (browser) ihtiyaÃ§ duyuyorsa ne tÃ¼r bir programdÄ±r?",
  options: [
    ["Uygulama (Application)", "Uygulamalar, `main()` metodu olan ve doÄŸrudan iÅŸletim sistemi Ã¼zerinde Ã§alÄ±ÅŸan programlardÄ±r."],
    ["Paket (Package)", "Paket, bir sÄ±nÄ±f kÃ¼tÃ¼phanesidir."],
    ["ArayÃ¼z (Interface)", "ArayÃ¼z, metot imzalarÄ±nÄ± iÃ§eren bir tanÄ±mdÄ±r."],
    ["Applet", "Applet'ler, bir web sayfasÄ±nÄ±n iÃ§ine gÃ¶mÃ¼lerek Ã§alÄ±ÅŸan ve bir tarayÄ±cÄ± ortamÄ±na ihtiyaÃ§ duyan kÃ¼Ã§Ã¼k Java programlarÄ±dÄ±r."],
    ["Servis (Service)", "Servis, genellikle arka planda Ã§alÄ±ÅŸan bir uygulamadÄ±r."]
  ],
  answer: 3,
  summary: "Java'nÄ±n ilk popÃ¼ler olduÄŸu yÄ±llarda, web sayfalarÄ±na dinamik ve interaktif iÃ§erik eklemek iÃ§in 'Applet' teknolojisi Ã§ok yaygÄ±ndÄ±. Bu kÃ¼Ã§Ã¼k programlar, tarayÄ±cÄ± sayesinde platformdan baÄŸÄ±msÄ±z bir ÅŸekilde Ã§alÄ±ÅŸabiliyordu."
},
{
  q: "18. C++ dilinde `static` olarak tanÄ±mlanmÄ±ÅŸ bir veri sahasÄ±nÄ±n (deÄŸiÅŸkenin) temel Ã¶zelliÄŸi nedir?",
  options: [
    ["Sadece constructor metodu iÃ§inden eriÅŸilebilir.", "EriÅŸim belirtecine baÄŸlÄ± olarak farklÄ± yerlerden eriÅŸilebilir."],
    ["DeÄŸeri program boyunca asla deÄŸiÅŸtirilemez.", "Bu `const` Ã¶zelliÄŸidir."],
    ["O sÄ±nÄ±fÄ±n tÃ¼m nesneleri arasÄ±nda paylaÅŸÄ±lÄ±r.", "`static` olmayan bir deÄŸiÅŸken her nesne iÃ§in ayrÄ± ayrÄ± oluÅŸturulurken, `static` bir deÄŸiÅŸken o sÄ±nÄ±ftan Ã¼retilen tÃ¼m nesneler iÃ§in tek bir ortak kopyadÄ±r. Bir nesnenin bu deÄŸiÅŸkeni deÄŸiÅŸtirmesi, diÄŸer tÃ¼m nesneleri de etkiler."],
    ["Sadece tamsayÄ± tipinde olabilir.", "Herhangi bir tipte olabilir."],
    ["Sadece alt sÄ±nÄ±flar tarafÄ±ndan gÃ¶rÃ¼lebilir.", "Bu `protected` Ã¶zelliÄŸidir."]
  ],
  answer: 2,
  summary: "`static` deÄŸiÅŸkenler, bir sÄ±nÄ±fa ait 'genel duyuru panosu' gibidir. O sÄ±nÄ±ftan kaÃ§ tane nesne Ã¼retilirse Ã¼retilsin, hepsi aynÄ± panoya bakar ve o panoya yazar."
},
{
  q: "19. SOLID prensiplerinden hangisi, bir sÄ±nÄ±fÄ±n veya metodun sadece tek bir sorumluluÄŸu olmasÄ± ve deÄŸiÅŸmesi iÃ§in tek bir nedeni olmasÄ± gerektiÄŸini savunur?",
  options: [
    ["Open/Closed Principle", "Bu prensip, nesnelerin deÄŸiÅŸime kapalÄ±, geniÅŸlemeye aÃ§Ä±k olmasÄ± gerektiÄŸini sÃ¶yler."],
    ["Liskov Substitution Principle", "Bu prensip, alt sÄ±nÄ±flarÄ±n Ã¼st sÄ±nÄ±flarÄ±n yerine geÃ§ebilmesi gerektiÄŸini sÃ¶yler."],
    ["Single Responsibility Principle", "Bu prensip, her modÃ¼lÃ¼n veya sÄ±nÄ±fÄ±n sadece bir iÅŸe odaklanmasÄ± gerektiÄŸini, bÃ¶ylece bir deÄŸiÅŸiklik gerektiÄŸinde sadece o iÅŸle ilgili sÄ±nÄ±fÄ±n etkilenmesini hedefler."],
    ["Interface Segregation Principle", "Bu prensip, bÃ¼yÃ¼k arayÃ¼zler yerine kÃ¼Ã§Ã¼k ve Ã¶zel arayÃ¼zler kullanÄ±lmasÄ± gerektiÄŸini sÃ¶yler."],
    ["Dependency Inversion Principle", "Bu prensip, Ã¼st seviye modÃ¼llerin alt seviye modÃ¼llere baÄŸÄ±mlÄ± olmamasÄ± gerektiÄŸini sÃ¶yler."]
  ],
  answer: 2,
  summary: "Tek Sorumluluk Prensibi, yazÄ±lÄ±m tasarÄ±mÄ±nda 'iÅŸ bÃ¶lÃ¼mÃ¼' yapmaktÄ±r. Her sÄ±nÄ±fÄ±n sadece bir uzmanlÄ±k alanÄ± olmalÄ±dÄ±r. Bu, kodun anlaÅŸÄ±lmasÄ±nÄ±, test edilmesini ve bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r."
},
{
  q: "20. C++'dan farklÄ± olarak Java'da bulunmayan ve bu nedenle bellek yÃ¶netimini daha gÃ¼venli hale getiren Ã¶zellik hangisidir?",
  options: [
    ["KalÄ±tÄ±m", "Java'da tekli kalÄ±tÄ±m vardÄ±r."],
    ["SÄ±nÄ±flar", "Java tamamen sÄ±nÄ±flar Ã¼zerine kuruludur."],
    ["GÃ¶stergeler (Pointers)", "Java, bellek sÄ±zÄ±ntÄ±sÄ± ve sallanan gÃ¶sterge gibi sorunlarÄ± Ã¶nlemek iÃ§in programcÄ±nÄ±n belleÄŸe doÄŸrudan eriÅŸimini saÄŸlayan gÃ¶stergelere izin vermez."],
    ["Metotlar", "Java'da metotlar vardÄ±r."],
    ["DÃ¶ngÃ¼ler", "Java'da dÃ¶ngÃ¼ler vardÄ±r."]
  ],
  answer: 2,
  summary: "Java'nÄ±n tasarÄ±mcÄ±larÄ±, C++'da programcÄ±larÄ±n en Ã§ok zorlandÄ±ÄŸÄ± ve en Ã§ok hata yaptÄ±ÄŸÄ± konulardan ikisinin 'gÃ¶stergeler' ve 'manuel bellek yÃ¶netimi' olduÄŸunu gÃ¶rmÃ¼ÅŸlerdir. Java'yÄ± tasarlarken bu iki Ã¶zelliÄŸi de dilden Ã§Ä±kararak daha gÃ¼venli bir programlama ortamÄ± yaratmayÄ± hedeflemiÅŸlerdir."
},
{
  q: "21. Bir alt sÄ±nÄ±fÄ±n, Ã¼st sÄ±nÄ±fÄ±nÄ±n tÃ¼m Ã¶zelliklerini ve metotlarÄ±nÄ± alÄ±p, Ã¼st sÄ±nÄ±fÄ±n davranÄ±ÅŸÄ±nÄ± hiÃ§ deÄŸiÅŸtirmeden sadece yeni davranÄ±ÅŸlar eklemesi, kalÄ±tÄ±mÄ±n hangi kullanÄ±m amacÄ±na Ã¶rnektir?",
  options: [
    ["Ã–zelleÅŸme iÃ§in kalÄ±tÄ±m", "Ã–zelleÅŸmede, alt sÄ±nÄ±f Ã¼st sÄ±nÄ±fÄ±n bir alttipi olur ama davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirebilir."],
    ["KÄ±sÄ±tlama iÃ§in kalÄ±tÄ±m", "KÄ±sÄ±tlamada, alt sÄ±nÄ±f Ã¼st sÄ±nÄ±fÄ±n bazÄ± davranÄ±ÅŸlarÄ±nÄ± engeller."],
    ["Spesifikasyon iÃ§in kalÄ±tÄ±m", "Spesifikasyonda, alt sÄ±nÄ±f Ã¼st sÄ±nÄ±fÄ±n eksik bÄ±raktÄ±ÄŸÄ± bir davranÄ±ÅŸÄ± tamamlar."],
    ["GeniÅŸletme iÃ§in kalÄ±tÄ±m", "Bu tÃ¼r kalÄ±tÄ±mda, var olan bir sÄ±nÄ±fa dokunmadan, ondan yeni bir sÄ±nÄ±f tÃ¼retip bu yeni sÄ±nÄ±fa yeni metotlar veya Ã¶zellikler eklenir."],
    ["BirleÅŸtirme iÃ§in kalÄ±tÄ±m", "Bu, Ã§oklu kalÄ±tÄ±mla ilgilidir."]
  ],
  answer: 3,
  summary: "GeniÅŸletme iÃ§in kalÄ±tÄ±m, bir eve dokunmadan ona yeni bir 'oda' eklemeye benzer. Mevcut yapÄ± bozulmaz, sadece yeni iÅŸlevler kazanÄ±r."
},
{
  q: "22. `public class Araba implements Tasit, Kapi` gibi bir tanÄ±mÄ±n mÃ¼mkÃ¼n olduÄŸu Java gibi dillerde, `Tasit` ve `Kapi` ne tÃ¼r yapÄ±lardÄ±r?",
  options: [
    ["Ä°kisi de Ã¼st sÄ±nÄ±ftÄ±r.", "Java'da sadece tek bir Ã¼st sÄ±nÄ±ftan kalÄ±tÄ±m alÄ±nabilir."],
    ["Ä°kisi de pakettir.", "Paketler `import` ile dahil edilir."],
    ["Ä°kisi de arayÃ¼zdÃ¼r (interface).", "Java, bir sÄ±nÄ±fÄ±n birden Ã§ok 'sÃ¶zleÅŸmeyi' veya 'yetenek setini' gerÃ§ekleÅŸtirmesine olanak tanÄ±yan arayÃ¼zler aracÄ±lÄ±ÄŸÄ±yla Ã§oklu kalÄ±tÄ±ma benzer bir esneklik saÄŸlar."],
    ["`Tasit` bir Ã¼st sÄ±nÄ±f, `Kapi` bir metottur.", "Bu sÃ¶zdizimsel olarak yanlÄ±ÅŸtÄ±r."],
    ["`Tasit` bir arayÃ¼z, `Kapi` bir pakettir.", "Bu sÃ¶zdizimsel olarak yanlÄ±ÅŸtÄ±r."]
  ],
  answer: 2,
  summary: "Java'da bir sÄ±nÄ±fÄ±n 'kim olduÄŸu' (kalÄ±tÄ±m aldÄ±ÄŸÄ± Ã¼st sÄ±nÄ±f) tekildir, ancak 'neler yapabildiÄŸi' (gerÃ§ekleÅŸtirdiÄŸi arayÃ¼zler) Ã§oÄŸul olabilir. Bir `Araba` sÄ±nÄ±fÄ± bir `Tasit`'tÄ±r, ama aynÄ± zamanda `KapilariOlan` ve `KlimasiOlan` gibi birden Ã§ok yeteneÄŸe (arayÃ¼ze) sahip olabilir."
},
{
  q: "23. Bir sÄ±nÄ±f hiyerarÅŸisinde, `TaÅŸÄ±t` gibi doÄŸrudan nesnesi oluÅŸturulmayan ancak `Otomobil` ve `UÃ§ak` gibi alt sÄ±nÄ±flar iÃ§in ortak bir ÅŸablon gÃ¶revi gÃ¶ren sÄ±nÄ±flara ne denir?",
  options: [
    ["Somut SÄ±nÄ±f (Concrete Class)", "Somut sÄ±nÄ±flarÄ±n nesnesi oluÅŸturulabilir."],
    ["Final SÄ±nÄ±f (Final Class)", "Final sÄ±nÄ±flardan kalÄ±tÄ±m yapÄ±lamaz."],
    ["Statik SÄ±nÄ±f (Static Class)", "Statik sÄ±nÄ±flarÄ±n nesnesi oluÅŸturulmaz ama kullanÄ±m amacÄ± farklÄ±dÄ±r."],
    ["ArayÃ¼z (Interface)", "ArayÃ¼zler hiÃ§ gerÃ§ekleÅŸtirim iÃ§ermez, soyut sÄ±nÄ±flar iÃ§erebilir."],
    ["Soyut SÄ±nÄ±f (Abstract Class)", "Soyut sÄ±nÄ±flar, bir kalÄ±tÄ±m hiyerarÅŸisindeki ortak Ã¶zellikleri ve davranÄ±ÅŸlarÄ± tanÄ±mlayan, ancak kendileri doÄŸrudan kullanÄ±lamayan 'kavramsal' sÄ±nÄ±flardÄ±r."]
  ],
  answer: 4,
  summary: "Soyut sÄ±nÄ±flar, 'Ne olmalÄ±?' sorusunu cevaplar ama 'NasÄ±l olmalÄ±?' sorusunu alt sÄ±nÄ±flara bÄ±rakÄ±r. Bir 'TaÅŸÄ±t' sÄ±nÄ±fÄ±, tÃ¼m taÅŸÄ±tlarÄ±n bir `hiz` Ã¶zelliÄŸi olmasÄ± gerektiÄŸini sÃ¶yler, ancak bu hÄ±zÄ±n nasÄ±l arttÄ±rÄ±lacaÄŸÄ±nÄ± 'Otomobil' ve 'UÃ§ak' alt sÄ±nÄ±flarÄ±nÄ±n kendileri belirler."
},
{
  q: "24. C++'da `static` olarak tanÄ±mlanmÄ±ÅŸ bir metodun temel Ã¶zelliÄŸi nedir?",
  options: [
    ["Sadece o sÄ±nÄ±fÄ±n constructor'Ä± tarafÄ±ndan Ã§aÄŸrÄ±labilir.", "Bu doÄŸru deÄŸildir."],
    ["Mutlaka bir nesne Ã¶rneÄŸi Ã¼zerinden Ã§aÄŸrÄ±lmalÄ±dÄ±r.", "Tam tersine, nesne Ã¶rneÄŸi yaratÄ±lmadan da Ã§aÄŸrÄ±labilir."],
    ["SÄ±nÄ±fÄ±n bir Ã¶rneÄŸi (nesnesi) yaratÄ±lmadan da doÄŸrudan sÄ±nÄ±f ismi Ã¼zerinden Ã§aÄŸrÄ±labilir.", "`static` bir metot, belirli bir nesneye deÄŸil, sÄ±nÄ±fÄ±n kendisine aittir. Bu nedenle, bir nesne oluÅŸturmaya gerek kalmadan `SinifAdi::MetotAdi()` ÅŸeklinde Ã§aÄŸrÄ±labilir."],
    ["Bir alt sÄ±nÄ±fta mutlaka Ã¼zerine yazÄ±lmalÄ±dÄ±r (override).", "Statik metotlar Ã¼zerine yazÄ±lamaz."],
    ["Sadece `private` olabilir.", "FarklÄ± eriÅŸim belirteÃ§lerine sahip olabilir."]
  ],
  answer: 2,
  summary: "`static` metotlar, bir sÄ±nÄ±fla ilgili ama belirli bir nesnenin durumuna baÄŸlÄ± olmayan 'yardÄ±mcÄ±' veya 'genel' iÅŸlevler iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin, bir `Matematik` sÄ±nÄ±fÄ±nÄ±n, nesne oluÅŸturmaya gerek kalmadan kullanÄ±labilen `Matematik::karesiniAl(5)` gibi bir statik metodu olabilir."
},
{
  q: "25. Nesneye yÃ¶nelik tasarÄ±mÄ±n geleneksel iÅŸlevsel tasarÄ±ma gÃ¶re temel avantajÄ± olarak ne gÃ¶sterilmektedir?",
  options: [
    ["Her zaman daha az kod yazÄ±lmasÄ±nÄ± saÄŸlamasÄ±", "Bu bir garanti deÄŸildir."],
    ["ProgramlarÄ±n her zaman daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±", "Bu bir garanti deÄŸildir, bazen tam tersi olabilir."],
    ["Veri paylaÅŸÄ±mÄ±nÄ±n azalmasÄ± ve deÄŸiÅŸikliklere daha uygun yazÄ±lÄ±mlar oluÅŸturulmasÄ±", "Nesneye yÃ¶nelik tasarÄ±mda veri ve o veriyi iÅŸleyen metotlar bir arada (kapsÃ¼llenmiÅŸ) olduÄŸu iÃ§in, bir deÄŸiÅŸiklik yapÄ±ldÄ±ÄŸÄ±nda sadece o nesne etkilenir. Bu da sistemin bakÄ±mÄ±nÄ± ve geniÅŸletilmesini Ã§ok daha kolay hale getirir."],
    ["Sadece tek bir programcÄ±nÄ±n Ã§alÄ±ÅŸmasÄ±na izin vermesi", "Tam tersine, modÃ¼ler yapÄ±sÄ± takÄ±m Ã§alÄ±ÅŸmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r."],
    ["TÃ¼m hatalarÄ± ortadan kaldÄ±rmasÄ±", "HatalarÄ± azaltÄ±r ama ortadan kaldÄ±rmaz."]
  ],
  answer: 2,
  summary: "Geleneksel tasarÄ±mda bir veri yapÄ±sÄ±nÄ± deÄŸiÅŸtirmek, bir depremin birÃ§ok farklÄ± binayÄ± (fonksiyonu) etkilemesi gibidir. Nesneye yÃ¶nelik tasarÄ±mda ise her nesne kendi deprem izolatÃ¶rÃ¼ne sahiptir; bir nesnede yapÄ±lan deÄŸiÅŸiklik genellikle diÄŸerlerini etkilemez."
}    
  ];

  const quizDiv = document.getElementById('quiz');
  const optionLabels = ['A)', 'B)', 'C)', 'D)', 'E)'];
  const userAnswers = new Array(questions.length).fill(null);


  questions.forEach((qObj, index) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'question-container';
    questionContainer.id = `question-${index}`;

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = qObj.q;
    questionContainer.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options-group';

    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback';
    feedbackDiv.style.display = 'none'; // Initially hidden

    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'summary';
    summaryDiv.style.display = 'none'; // Initially hidden


    qObj.options.forEach((opt, i) => {
      const optDiv = document.createElement('div');
      optDiv.className = 'option';
      optDiv.textContent = `${optionLabels[i]} ${opt[0]}`;
      optDiv.onclick = () => {
        // Clear previous selection visuals for this question
        const allOptsInGroup = optsDiv.querySelectorAll('.option');
        allOptsInGroup.forEach(el => el.classList.remove('selected'));
        optDiv.classList.add('selected'); // Mark as selected

        userAnswers[index] = i; // Store user's answer

        // Show feedback immediately
        const feedbackText = opt[1] || (i === qObj.answer ? "DoÄŸru cevap!" : "YanlÄ±ÅŸ cevap."); // Fallback feedback
        feedbackDiv.className = 'feedback ' + (i === qObj.answer ? 'correct' : 'incorrect');
        feedbackDiv.style.display = 'block';
        feedbackDiv.textContent = (i === qObj.answer ? 'âœ”ï¸ DoÄŸru: ' : 'âŒ YanlÄ±ÅŸ: ') + feedbackText;


        if (i === qObj.answer && qObj.summary) {
          summaryDiv.style.display = 'block';
          summaryDiv.textContent = 'ðŸ’¡ ' + qObj.summary;
        } else {
          summaryDiv.style.display = 'none';
        }
      };
      optsDiv.appendChild(optDiv);
    });

    questionContainer.appendChild(optsDiv);
    questionContainer.appendChild(feedbackDiv);
    questionContainer.appendChild(summaryDiv);
    quizDiv.appendChild(questionContainer);
  });

  function showResults() {
    let correctCount = 0;
    userAnswers.forEach((answer, index) => {
        if (answer !== null && answer === questions[index].answer) {
            correctCount++;
        }
    });

    const totalQuestions = questions.length;
    const scorePercentage = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(2) : 0;

    document.getElementById('total-questions').textContent = totalQuestions;
    document.getElementById('correct-answers').textContent = correctCount;
    document.getElementById('score-percentage').textContent = scorePercentage;
    document.getElementById('results-summary').style.display = 'block';

    // Scroll to results
    document.getElementById('results-summary').scrollIntoView({ behavior: 'smooth' });
  }

</script>
</body>
</html>