<!DOCTYPE html>
<html lang="tr">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Programlama Dilleri - 5</title>
  <style>
    body { font-family: 'PT Sans', 'Trebuchet MS', sans-serif; background: #f9f9f9; padding: 20px; color: #333; }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .question-container { background: #fff; padding: 20px; margin-bottom: 25px; border-left: 5px solid #007BFF; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-text { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; }
    .option { padding: 10px; margin: 8px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; transition: background-color 0.2s ease-in-out; }
    .option:hover { background: #e9ecef; }
    .option.selected { background-color: #cce5ff; border-color: #b8daff; }
    .feedback { margin-top: 15px; padding: 12px; border-radius: 4px; display: none; font-weight: bold; }
    .correct { background: #d4edda; border-left: 5px solid #28a745; color: #155724; }
    .incorrect { background: #f8d7da; border-left: 5px solid #dc3545; color: #721c24; }
    .summary { display: none; background: #fff3cd; padding: 12px; margin-top: 10px; border-left: 5px solid #ffc107; border-radius: 4px; color: #856404; }
    button#submit-all {
        display: block;
        margin: 30px auto;
        padding: 12px 25px;
        font-size: 1.1em;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    button#submit-all:hover {
        background-color: #218838;
    }
    .results { margin-top: 30px; padding: 20px; background-color: #e9ecef; border-radius: 5px; text-align: center;}
  </style>
</head>
<body>
<h1>Programlama Dilleri - 5</h1>
<div id="quiz">
  </div>
<button id="submit-all" onclick="showResults()">TÃ¼m Testi Bitir ve SonuÃ§larÄ± GÃ¶r</button>
<div id="results-summary" class="results" style="display:none;">
    <h2>Test Sonucu</h2>
    <p>Toplam Soru: <span id="total-questions"></span></p>
    <p>DoÄŸru Cevap SayÄ±sÄ±: <span id="correct-answers"></span></p>
    <p>BaÅŸarÄ± YÃ¼zdesi: <span id="score-percentage"></span>%</p>
</div>

<script>
  const questions = [
{
  q: "1. Bir ifadede birden Ã§ok iÅŸlemci parantez kullanÄ±lmadan yer aldÄ±ÄŸÄ±nda, hangi iÅŸlemcinin Ã¶nce deÄŸerlendirileceÄŸini belirleyen kurala ne ad verilir?",
  options: [
    ["Ä°ÅŸlemcinin Yeri (Placement)", "Bu, iÅŸlemcinin iÅŸlenenlere gÃ¶re nerede durduÄŸunu (prefix, infix, postfix) belirtir."],
    ["Associativity (Ä°liÅŸkililik)", "Bu, aynÄ± Ã¶ncelik seviyesindeki iÅŸlemcilerin hangi sÄ±rayla deÄŸerlendirileceÄŸini belirler."],
    ["Ä°ÅŸlenen SayÄ±sÄ± (Arity)", "Bu, bir iÅŸlemcinin kaÃ§ tane iÅŸlenen aldÄ±ÄŸÄ±nÄ± (unary, binary) belirtir."],
    ["Ã–ncelik (Precedence)", "Ä°ÅŸlemcilerin Ã¶ncelikleri, farklÄ± Ã¶ncelik seviyelerindeki iÅŸlemcilerden hangisinin iÅŸlenenlerini Ã¶nce alacaÄŸÄ±nÄ±, yani iÅŸlem sÄ±rasÄ±nÄ± belirler."],
    ["Kapsam (Scope)", "Bu, bir deÄŸiÅŸkenin programÄ±n hangi bÃ¶lÃ¼mÃ¼nde geÃ§erli olduÄŸunu belirten bir kavramdÄ±r."]
  ],
  answer: 3,
  summary: "Bir ifadenin sonucunun belirsiz olmasÄ±nÄ± Ã¶nlemek iÃ§in dillerde iÅŸlemci Ã¶ncelik kurallarÄ± vardÄ±r. Geleneksel olarak Ã§arpma ve bÃ¶lme, toplama ve Ã§Ä±karmadan daha yÃ¼ksek Ã¶nceliÄŸe sahiptir. Bu nedenle `3 + 5 * 2` ifadesinin sonucu 13'tÃ¼r, 16 deÄŸil."
},
{
  q: "2. AÅŸaÄŸÄ±dakilerden hangisi bir deÄŸiÅŸkenin temel Ã¶zelliklerinden biri deÄŸildir?",
  options: [
    ["Ä°sim", "DeÄŸiÅŸkenin program iÃ§inde Ã§aÄŸrÄ±lmasÄ±nÄ± saÄŸlayan Ã¶zelliÄŸidir."],
    ["Adres", "DeÄŸiÅŸkenin bellekteki konumunu belirten Ã¶zelliÄŸidir."],
    ["DeÄŸer", "DeÄŸiÅŸkenin ilgili bellek hÃ¼cresinde tuttuÄŸu iÃ§eriktir."],
    ["Tip", "DeÄŸiÅŸkenin alabileceÄŸi deÄŸer aralÄ±ÄŸÄ±nÄ± ve iÅŸlemlerini belirleyen Ã¶zelliÄŸidir."],
    ["Algoritma", "Algoritma, bir problemin Ã§Ã¶zÃ¼m yoludur; bir deÄŸiÅŸkenin doÄŸrudan bir Ã¶zelliÄŸi deÄŸildir."]
  ],
  answer: 4,
  summary: "Bir deÄŸiÅŸken; Ä°sim, Adres, DeÄŸer, Tip, YaÅŸam SÃ¼resi ve Kapsam olmak Ã¼zere altÄ± temel Ã¶zelliÄŸe sahiptir. Bu Ã¶zellikler, deÄŸiÅŸkenin program iÃ§indeki davranÄ±ÅŸÄ±nÄ± ve rolÃ¼nÃ¼ tanÄ±mlar."
},
{
  q: "3. 'Anahtar Kelime (Keyword)' ile 'AyrÄ±lmÄ±ÅŸ Kelime (Reserved Word)' arasÄ±ndaki temel fark nedir?",
  options: [
    ["Anahtar kelimeler bÃ¼yÃ¼k, ayrÄ±lmÄ±ÅŸ kelimeler kÃ¼Ã§Ã¼k harfle yazÄ±lÄ±r.", "Bu bir kural deÄŸildir; harf duyarlÄ±lÄ±ÄŸÄ± dilin genel Ã¶zelliÄŸidir."],
    ["Anahtar kelimeler asla deÄŸiÅŸken ismi olarak kullanÄ±lamaz, ayrÄ±lmÄ±ÅŸ kelimeler kullanÄ±labilir.", "Tam tersi doÄŸrudur."],
    ["Anahtar kelime sadece belirli bir iÃ§erikte Ã¶zel anlam taÅŸÄ±rken, ayrÄ±lmÄ±ÅŸ kelime hiÃ§bir zaman isim olarak kullanÄ±lamaz.", "FORTRAN'daki `REAL` bir anahtar kelimedir; hem tip belirtir hem de deÄŸiÅŸken adÄ± olabilir. Pascal'daki `begin` ise ayrÄ±lmÄ±ÅŸ bir kelimedir ve asla deÄŸiÅŸken adÄ± olamaz. Bu, aralarÄ±ndaki temel farktÄ±r."],
    ["Anahtar kelimeler sadece dÃ¶ngÃ¼lerde, ayrÄ±lmÄ±ÅŸ kelimeler sadece fonksiyonlarda kullanÄ±lÄ±r.", "Bu yanlÄ±ÅŸ bir sÄ±nÄ±flandÄ±rmadÄ±r."],
    ["Ä°kisi arasÄ±nda hiÃ§bir fark yoktur, aynÄ± anlama gelirler.", "HayÄ±r, aralarÄ±nda dilin okunabilirliÄŸini etkileyen Ã¶nemli bir fark vardÄ±r."]
  ],
  answer: 2,
  summary: "AyrÄ±lmÄ±ÅŸ kelimeler (`reserved word`) daha katÄ± bir kuraldÄ±r ve programcÄ± tarafÄ±ndan isim olarak kullanÄ±lmasÄ± kesinlikle yasaktÄ±r. Anahtar kelimeler (`keyword`) ise baÄŸlama gÃ¶re anlamÄ± deÄŸiÅŸebilen, daha esnek ama potansiyel olarak kafa karÄ±ÅŸtÄ±rÄ±cÄ± kelimelerdir."
},
{
  q: "4. `a - b - c` gibi bir ifadenin `(a - b) - c` ÅŸeklinde soldan saÄŸa doÄŸru gruplanarak iÅŸlenmesi, `-` iÅŸlemcisinin hangi Ã¶zelliÄŸini gÃ¶sterir?",
  options: [
    ["SaÄŸ associative olma", "SaÄŸ associative olsaydÄ± `a - (b - c)` ÅŸeklinde iÅŸlenirdi."],
    ["YÃ¼ksek Ã¶ncelikli olma", "Ã–ncelik, farklÄ± iÅŸlemciler arasÄ±ndaki sÄ±rayÄ± belirler; bu ise aynÄ± iÅŸlemcinin sÄ±rasÄ±yla ilgilidir."],
    ["Tekli (unary) iÅŸlemci olma", "Buradaki `-` iÅŸlemcisi iki iÅŸlenen aldÄ±ÄŸÄ± iÃ§in ikili (binary) bir iÅŸlemcidir."],
    ["Sol associative olma", "Bir iÅŸlemcinin birden Ã§ok kez yer aldÄ±ÄŸÄ± bir ifadedeki alt ifadeler soldan saÄŸa doÄŸru gruplanÄ±yorsa, o iÅŸlemci 'sol associative'dir. Aritmetik iÅŸlemcilerin Ã§oÄŸu bu Ã¶zelliktedir."],
    ["Postfix gÃ¶sterimde olma", "Bu gÃ¶sterim infix (arada) bir gÃ¶sterimdir."]
  ],
  answer: 3,
  summary: "Associativity (Ä°liÅŸkililik/BirleÅŸme YÃ¶nÃ¼), aynÄ± Ã¶ncelikteki operatÃ¶rlerin hangi sÄ±rayla uygulanacaÄŸÄ±nÄ± belirler. `a-b-c` gibi bir ifadede Ã¶nce `a-b` iÅŸleminin yapÄ±lmasÄ±, Ã§Ä±karma operatÃ¶rÃ¼nÃ¼n sola birleÅŸmeli (sol associative) olduÄŸunu gÃ¶sterir."
},
{
  q: "5. Bir deÄŸiÅŸkenin sadece tanÄ±mlandÄ±ÄŸÄ± fonksiyon veya blok iÃ§inde geÃ§erli olmasÄ± ve fonksiyonun Ã§alÄ±ÅŸmasÄ± bittiÄŸinde bellekten silinmesi, o deÄŸiÅŸkenin hangi Ã¶zelliÄŸiyle ilgilidir?",
  options: [
    ["Tip", "Tip, deÄŸiÅŸkenin deÄŸer aralÄ±ÄŸÄ±nÄ± belirtir."],
    ["DeÄŸer", "DeÄŸer, deÄŸiÅŸkenin iÃ§eriÄŸidir."],
    ["YaÅŸam SÃ¼resi ve Kapsam", "DeÄŸiÅŸkenin geÃ§erli olduÄŸu program bÃ¶lgesi 'kapsam'Ä±nÄ±, bellekte kaldÄ±ÄŸÄ± sÃ¼re ise 'yaÅŸam sÃ¼resi'ni belirtir. Fonksiyona Ã¶zel yerel deÄŸiÅŸkenler bu iki kavramÄ±n en tipik Ã¶rneÄŸidir."],
    ["Adres", "Adres, deÄŸiÅŸkenin bellekteki yeridir."],
    ["Ä°sim", "Ä°sim, deÄŸiÅŸkene eriÅŸmek iÃ§in kullanÄ±lan etikettir."]
  ],
  answer: 2,
  summary: "Kapsam (scope) 'nerede geÃ§erli?' sorusuna, yaÅŸam sÃ¼resi (lifetime) ise 'ne kadar sÃ¼re yaÅŸar?' sorusuna cevap verir. Bir fonksiyonun yerel deÄŸiÅŸkeninin kapsamÄ± o fonksiyonun iÃ§idir ve yaÅŸam sÃ¼resi de fonksiyonun Ã§alÄ±ÅŸma sÃ¼resi kadardÄ±r."
},
{
  q: "6. DiÄŸer veri tiplerinden oluÅŸmamÄ±ÅŸ, bir dilin temel yapÄ± taÅŸÄ± olan veri tiplerine ne ad verilir?",
  options: [
    ["YapÄ±sal Tipler", "YapÄ±sal tipler, tam tersine, diÄŸer tiplerin bir araya gelmesiyle oluÅŸur (Ã¶rn: diziler)."],
    ["KullanÄ±cÄ± TanÄ±mlÄ± Tipler", "Bu, ilkel tiplerden biri olabilir ancak tÃ¼m ilkel tipleri kapsamaz."],
    ["Ä°lkel (Primitive) Tipler", "Ä°lkel tipler, bir dilin en temel veri tÃ¼rleridir ve baÅŸka tiplere bÃ¶lÃ¼nemezler. TamsayÄ± (integer), mantÄ±ksal (boolean) ve karakter (char) buna Ã¶rnektir."],
    ["GÃ¶sterge (Pointer) Tipleri", "GÃ¶stergeler, bellek adreslerini tutan ve genellikle yapÄ±sal tip olarak kabul edilen bir veri tipidir."],
    ["Dizi (Array) Tipleri", "Diziler, aynÄ± tÃ¼rden birden Ã§ok veriyi bir arada tutan yapÄ±sal tiplerdir."]
  ],
  answer: 2,
  summary: "Ä°lkel tipler, bir evin tuÄŸlalarÄ± gibidir. YapÄ±sal tipler ise bu tuÄŸlalardan inÅŸa edilen duvarlar, odalar gibi daha bÃ¼yÃ¼k yapÄ±lardÄ±r. Tam sayÄ±, karakter, mantÄ±ksal gibi tipler Ã§oÄŸu dilde ilkel olarak bulunur."
},
{
  q: "7. C, C++ ve Java gibi dillerin isimler konusunda 'bÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harfe duyarlÄ± (case-sensitive)' olmasÄ± ne anlama gelir?",
  options: [
    ["TÃ¼m deÄŸiÅŸken isimleri bÃ¼yÃ¼k harfle yazÄ±lmalÄ±dÄ±r.", "Bu bir zorunluluk deÄŸildir."],
    ["`TOPLAM`, `toplam` ve `ToPlaM` isimlerinin hepsi aynÄ± deÄŸiÅŸkeni ifade eder.", "Bu, bÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harfe duyarlÄ± olmayan diller iÃ§in geÃ§erlidir."],
    ["`TOPLAM`, `toplam` ve `ToPlaM` isimleri derleyici tarafÄ±ndan Ã¼Ã§ ayrÄ± ve farklÄ± deÄŸiÅŸken olarak algÄ±lanÄ±r.", "BÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harfe duyarlÄ± bir dilde, harflerin kasasÄ± deÄŸiÅŸtiÄŸinde isim de tamamen farklÄ± bir isim olarak kabul edilir."],
    ["DeÄŸiÅŸken isimlerinde rakam kullanÄ±lamaz.", "Harf duyarlÄ±lÄ±ÄŸÄ±nÄ±n rakam kullanÄ±mÄ±yla bir ilgisi yoktur."],
    ["DeÄŸiÅŸken isimleri sadece 8 karakter olabilir.", "Harf duyarlÄ±lÄ±ÄŸÄ±nÄ±n isim uzunluÄŸuyla bir ilgisi yoktur."]
  ],
  answer: 2,
  summary: "BÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ±lÄ±ÄŸÄ±, programlamada sÄ±kÃ§a yapÄ±lan hatalardan birinin kaynaÄŸÄ± olabilir. Bu Ã¶zelliÄŸe sahip dillerde 'sayi' adÄ±nda bir deÄŸiÅŸken tanÄ±mlayÄ±p daha sonra 'Sayi' olarak kullanmaya Ã§alÄ±ÅŸmak hataya yol aÃ§ar Ã§Ã¼nkÃ¼ derleyici iÃ§in bu ikisi farklÄ± deÄŸiÅŸkenlerdir."
},
{
  q: "8. AÅŸaÄŸÄ±dakilerden hangisi bir 'isimlendirilmiÅŸ sabit (named constant)' kullanmanÄ±n avantajlarÄ±ndan biri deÄŸildir?",
  options: [
    ["ProgramÄ±n okunabilirliÄŸini artÄ±rmasÄ±", "Sihirli bir sayÄ± olan `3.14159` yerine `pi` ismini kullanmak kodu daha okunabilir kÄ±lar."],
    ["ProgramÄ±n bakÄ±mÄ±nÄ± ve deÄŸiÅŸtirilebilirliÄŸini kolaylaÅŸtÄ±rmasÄ±", "Bir dizi boyutu gibi programÄ±n birÃ§ok yerinde kullanÄ±lan bir deÄŸeri deÄŸiÅŸtirmek gerektiÄŸinde, sadece sabit tanÄ±mÄ±nÄ± deÄŸiÅŸtirmek yeterli olur."],
    ["ProgramÄ±n Ã§alÄ±ÅŸma zamanÄ±nda deÄŸerinin deÄŸiÅŸtirilebilmesi", "Bu bir avantaj deÄŸil, tanÄ±mÄ±n tam tersidir. Sabitlerin deÄŸeri program Ã§alÄ±ÅŸÄ±rken deÄŸiÅŸtirilemez."],
    ["YazÄ±m hatalarÄ±nÄ± azaltmasÄ±", "Uzun ve karmaÅŸÄ±k bir sayÄ±yÄ± tekrar tekrar yazmak yerine kÄ±sa bir isim kullanmak hata riskini azaltÄ±r."],
    ["ProgramÄ±n gÃ¼venilirliÄŸini artÄ±rmasÄ±", "Bir deÄŸerin yanlÄ±ÅŸlÄ±kla deÄŸiÅŸtirilmesini Ã¶nleyerek programÄ± daha gÃ¼venilir hale getirir."]
  ],
  answer: 2,
  summary: "Ä°simlendirilmiÅŸ sabitler, program iÃ§inde deÄŸeri hiÃ§ deÄŸiÅŸmeyecek olan Ã¶nemli verileri (pi sayÄ±sÄ±, vergi oranÄ±, maksimum kullanÄ±cÄ± sayÄ±sÄ± vb.) bir isimle etiketlemektir. Bu, hem kodu daha anlaÅŸÄ±lÄ±r kÄ±lar hem de gelecekteki deÄŸiÅŸiklikleri Ã§ok kolaylaÅŸtÄ±rÄ±r."
},
{
  q: "9. PHP'de `$sayi++` veya C'de `sayi++` gibi bir ifadede, `++` iÅŸlemcisi iÅŸlenenden sonra geldiÄŸi iÃ§in hangi konumda kullanÄ±lmÄ±ÅŸtÄ±r?",
  options: [
    ["Infix", "Infix gÃ¶sterimde iÅŸlemci iki iÅŸlenenin arasÄ±nda yer alÄ±r (Ã¶rn: `a + b`)."],
    ["Prefix", "Prefix gÃ¶sterimde iÅŸlemci iÅŸlenenden Ã¶nce yer alÄ±r (Ã¶rn: `++sayi`)."],
    ["Postfix", "Postfix gÃ¶sterimde iÅŸlemci iÅŸlenenden sonra yer alÄ±r. `sayi++` buna bir Ã¶rnektir."],
    ["Unary", "Bu, iÅŸlemcinin iÅŸlenen sayÄ±sÄ±nÄ± (tek iÅŸlenenli) belirtir, konumunu deÄŸil."],
    ["Binary", "Bu iÅŸlemci tek iÅŸlenen aldÄ±ÄŸÄ± iÃ§in binary (iki iÅŸlenenli) deÄŸildir."]
  ],
  answer: 2,
  summary: "Ä°ÅŸlemcinin yeri, ifadenin nasÄ±l yazÄ±ldÄ±ÄŸÄ±nÄ± ve bazen de nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± belirler. Ä°ÅŸlemcinin iÅŸlenenden sonra geldiÄŸi bu gÃ¶sterim 'postfix' veya 'art-ek' olarak adlandÄ±rÄ±lÄ±r."
},
{
  q: "10. AÅŸaÄŸÄ±daki veri tiplerinden hangisi 'yapÄ±sal (structural)' bir veri tipidir?",
  options: [
    ["TamsayÄ± (Integer)", "Bu, ilkel bir veri tipidir."],
    ["MantÄ±ksal (Boolean)", "Bu, ilkel bir veri tipidir."],
    ["Karakter (Char)", "Bu, ilkel bir veri tipidir."],
    ["Diziler (Arrays)", "Diziler, aynÄ± tÃ¼rden birden Ã§ok ilkel veya yapÄ±sal tipi bir araya getiren bileÅŸik yapÄ±lardÄ±r. Bu nedenle yapÄ±sal bir veri tipidir."],
    ["KullanÄ±cÄ± TanÄ±mlÄ± SÄ±ralÄ± Tipler", "Bu, ilkel bir veri tipidir."]
  ],
  answer: 3,
  summary: "YapÄ±sal tipler, ilkel tiplerden oluÅŸan daha karmaÅŸÄ±k veri kaplarÄ± olarak dÃ¼ÅŸÃ¼nÃ¼lebilir. Bir dizi, birden Ã§ok tamsayÄ±yÄ±; bir kayÄ±t ise farklÄ± tiplerden (tamsayÄ±, karakter dizisi vb.) verileri bir arada tutabilir."
},
{
  q: "11. Imperative programlama paradigmasÄ±nÄ±n temelini oluÅŸturan ve her bellek hÃ¼cresinin Ã¶zgÃ¼n bir adres ile tanÄ±mlandÄ±ÄŸÄ± bilgisayar mimarisine ne ad verilir?",
  options: [
    ["Harvard Mimarisi", "Harvard mimarisi, komut ve veri belleklerini ayÄ±ran farklÄ± bir mimaridir."],
    ["von Neumann Mimarisi", "Geleneksel bilgisayar mimarisi olan von Neumann, programlarÄ±n ve verilerin aynÄ± bellekte tutulmasÄ± ve iÅŸlem deyimlerinin bu bellekteki deÄŸerleri deÄŸiÅŸtirmesi prensibine dayanÄ±r. Imperative programlama bu mimariye Ã§ok uygundur."],
    ["ARM Mimarisi", "ARM, Ã¶zellikle mobil cihazlarda kullanÄ±lan bir iÅŸlemci mimarisidir."],
    ["Paralel Mimarisi", "Bu, birden Ã§ok iÅŸlemcinin aynÄ± anda Ã§alÄ±ÅŸtÄ±ÄŸÄ± genel bir mimari tÃ¼rÃ¼dÃ¼r."],
    ["Bulut Mimarisi", "Bu, biliÅŸim hizmetlerinin internet Ã¼zerinden sunulduÄŸu bir sistem tasarÄ±mÄ±dÄ±r."]
  ],
  answer: 1,
  summary: "Imperative dillerin 'git ÅŸu bellek adresindeki deÄŸeri al, Ã¼zerine bunu ekle, sonucu ÅŸu adrese yaz' ÅŸeklindeki komutlarÄ±, doÄŸrudan von Neumann mimarisinin Ã§alÄ±ÅŸma ÅŸeklini yansÄ±tÄ±r. Bu nedenle bu paradigma, modern bilgisayarlarÄ±n temel donanÄ±m yapÄ±sÄ±yla doÄŸal bir uyum iÃ§indedir."
},
{
  q: "12. Bir deÄŸiÅŸkenin tipi neyi belirler?",
  options: [
    ["Sadece bellekteki adresini", "Adres, tipten baÄŸÄ±msÄ±z bir Ã¶zelliktir."],
    ["Sadece programcÄ± tarafÄ±ndan verilen ismini", "Ä°sim, programcÄ± tarafÄ±ndan belirlenir."],
    ["ProgramÄ±n ne kadar hÄ±zlÄ± Ã§alÄ±ÅŸacaÄŸÄ±nÄ±", "Tip seÃ§imi performansÄ± etkileyebilir ama temel tanÄ±mÄ± bu deÄŸildir."],
    ["DeÄŸiÅŸkenin alabileceÄŸi deÄŸerler kÃ¼mesini ve o deÄŸerlere uygulanabilecek iÅŸlemleri", "Bir deÄŸiÅŸkenin 'tamsayÄ±' olmasÄ±, onun ondalÄ±klÄ± deÄŸerler alamayacaÄŸÄ±nÄ± ve Ã¼zerine toplama, Ã§Ä±karma gibi aritmetik iÅŸlemlerin yapÄ±labileceÄŸini belirtir. Bu, tip kavramÄ±nÄ±n temel tanÄ±mÄ±dÄ±r."],
    ["DeÄŸiÅŸkenin ne zaman bellekten silineceÄŸini", "Bu, deÄŸiÅŸkenin yaÅŸam sÃ¼resi ile ilgili bir konudur."]
  ],
  answer: 3,
  summary: "Veri tipi, bir deÄŸiÅŸkene 'oyunun kurallarÄ±nÄ±' sÃ¶yler. Hangi deÄŸerleri alabileceÄŸini, hangi operasyonlara katÄ±labileceÄŸini ve diÄŸer verilerle nasÄ±l etkileÅŸime gireceÄŸini tanÄ±mlar."
},
{
  q: "13. Ä°ki farklÄ± alt programÄ±n her birinin iÃ§inde 'toplam' adÄ±nda yerel bir deÄŸiÅŸken tanÄ±mlanmasÄ± durumunda, bu iki deÄŸiÅŸken iÃ§in ne sÃ¶ylenebilir?",
  options: [
    ["Ä°kisi de aynÄ± bellek adresini kullanan aynÄ± deÄŸiÅŸkendir.", "HayÄ±r, yerel deÄŸiÅŸkenler kendi kapsamlarÄ±na Ã¶zeldir."],
    ["Program hata verir Ã§Ã¼nkÃ¼ aynÄ± isimde iki deÄŸiÅŸken tanÄ±mlanamaz.", "FarklÄ± kapsamlarda olduklarÄ± sÃ¼rece aynÄ± isimde deÄŸiÅŸkenler tanÄ±mlanabilir."],
    ["Ä°simleri aynÄ± olsa da, her biri kendi alt programÄ±na Ã¶zel, farklÄ± bellek adresleriyle iliÅŸkili iki farklÄ± deÄŸiÅŸkendir.", "Bir deÄŸiÅŸkenin kimliÄŸi sadece ismiyle deÄŸil, kapsamÄ±yla da belirlenir. FarklÄ± fonksiyonlardaki aynÄ± isimli yerel deÄŸiÅŸkenler, birbirinden tamamen baÄŸÄ±msÄ±zdÄ±r ve farklÄ± bellek adreslerini kullanÄ±rlar."],
    ["Ä°kinci tanÄ±mlanan deÄŸiÅŸken, birincinin deÄŸerini otomatik olarak alÄ±r.", "HayÄ±r, aralarÄ±nda bir iliÅŸki yoktur."],
    ["Bu deÄŸiÅŸkenlerden sadece biri kullanÄ±labilir, diÄŸeri pasif kalÄ±r.", "Her ikisi de kendi fonksiyonlarÄ± iÃ§inde aktif olarak kullanÄ±labilir."]
  ],
  answer: 2,
  summary: "Kapsam (scope) kavramÄ±, deÄŸiÅŸken isimlerinin karÄ±ÅŸmasÄ±nÄ± Ã¶nler. Bu sayede, farklÄ± programcÄ±lar veya farklÄ± modÃ¼ller, birbirlerinin kodunu bozma endiÅŸesi olmadan aynÄ± isimleri kendi yerel deÄŸiÅŸkenleri iÃ§in gÃ¼venle kullanabilirler."
},
{
  q: "14. `a + b * c` ifadesinin `a + (b * c)` olarak deÄŸerlendirilmesinin sebebi nedir?",
  options: [
    ["`+` iÅŸlemcisinin `*` iÅŸlemcisinden daha yÃ¼ksek Ã¶nceliÄŸe sahip olmasÄ±", "Tam tersine, `*` iÅŸlemcisi daha yÃ¼ksek Ã¶nceliÄŸe sahiptir."],
    ["Ä°ÅŸlemcilerin soldan saÄŸa doÄŸru iÅŸlenmesi (sol associative olmasÄ±)", "Bu durum, aynÄ± Ã¶ncelikli iÅŸlemciler iÃ§in geÃ§erlidir. Burada Ã¶ncelikler farklÄ±dÄ±r."],
    ["`*` iÅŸlemcisinin `+` iÅŸlemcisinden daha yÃ¼ksek Ã¶nceliÄŸe sahip olmasÄ±", "Geleneksel iÅŸlemci Ã¶nceliÄŸi kurallarÄ±na gÃ¶re Ã§arpma ve bÃ¶lme, toplama ve Ã§Ä±karmadan Ã¶nce yapÄ±lÄ±r. Bu nedenle Ã¶nce `b*c` iÅŸlemi yapÄ±lÄ±r."],
    ["C dilinin bu ÅŸekilde tasarlanmÄ±ÅŸ olmasÄ±", "Bu kural sadece C'ye Ã¶zgÃ¼ deÄŸil, Ã§oÄŸu programlama dilinde standart bir matematiksel kuraldÄ±r."],
    ["Parantezlerin her zaman saÄŸ tarafa konulmasÄ±", "Bu anlamsÄ±z bir kuraldÄ±r."]
  ],
  answer: 2,
  summary: "Ä°ÅŸlemci Ã¶nceliÄŸi, matematik derslerindeki 'iÅŸlem sÄ±rasÄ±' kuralÄ±nÄ±n programlama dillerindeki karÅŸÄ±lÄ±ÄŸÄ±dÄ±r. Bu kural, karmaÅŸÄ±k ifadelerin herkes tarafÄ±ndan aynÄ± ÅŸekilde ve doÄŸru yorumlanmasÄ±nÄ± saÄŸlar."
},
{
  q: "15. Java gibi bazÄ± dillerde, artÄ±k kullanÄ±lmayan nesnelerin ve deÄŸiÅŸkenlerin kapladÄ±ÄŸÄ± bellek alanÄ±nÄ± otomatik olarak geri alan mekanizmaya ne ad verilir?",
  options: [
    ["Derleyici (Compiler)", "Derleyici kodu makine diline Ã§evirir."],
    ["YorumlayÄ±cÄ± (Interpreter)", "YorumlayÄ±cÄ± kodu satÄ±r satÄ±r Ã§alÄ±ÅŸtÄ±rÄ±r."],
    ["Ã‡Ã¶p ToplayÄ±cÄ± (Garbage Collector)", "Garbage Collector, programÄ±n Ã§alÄ±ÅŸmasÄ± sÄ±rasÄ±nda artÄ±k referans edilmeyen (kullanÄ±lmayan) bellek alanlarÄ±nÄ± tespit edip otomatik olarak serbest bÄ±rakan ve bÃ¶ylece bellek sÄ±zÄ±ntÄ±larÄ±nÄ± Ã¶nleyen bir mekanizmadÄ±r."],
    ["Hata AyÄ±klayÄ±cÄ± (Debugger)", "Debugger, programdaki hatalarÄ± bulmak iÃ§in kullanÄ±lÄ±r."],
    ["SanallaÅŸtÄ±rÄ±cÄ± (Virtualizer)", "Bu, donanÄ±m veya yazÄ±lÄ±m kaynaklarÄ±nÄ± sanal olarak oluÅŸturma iÅŸlemidir."]
  ],
  answer: 2,
  summary: "Manuel bellek yÃ¶netiminin zor ve hataya aÃ§Ä±k olmasÄ± nedeniyle Java, C# gibi modern diller, programcÄ±yÄ± bellek temizleme yÃ¼kÃ¼nden kurtaran 'Garbage Collector' adlÄ± bir otomasyon mekanizmasÄ± iÃ§erir. Bu, deÄŸiÅŸkenin yaÅŸam sÃ¼resi konseptiyle yakÄ±ndan iliÅŸkilidir."
},
{
  q: "16. `a := 10` ÅŸeklindeki bir atama iÅŸleminde, atama sembolÃ¼nÃ¼n saÄŸÄ±ndaki ve solundaki elemanlar iÃ§in ne sÃ¶ylenebilir?",
  options: [
    ["Sol taraf bir deÄŸer, saÄŸ taraf bir deÄŸiÅŸken olmalÄ±dÄ±r.", "Tam tersi doÄŸrudur."],
    ["Her iki taraf da deÄŸiÅŸken olmalÄ±dÄ±r.", "SaÄŸ taraf bir sabit veya ifade de olabilir."],
    ["SaÄŸ taraftaki deÄŸer, sol taraftaki deÄŸiÅŸkene aktarÄ±lÄ±r.", "TÃ¼m programlama dillerindeki atama sembolÃ¼nÃ¼n temel anlamÄ±, saÄŸ taraftaki ifadenin sonucunun hesaplanÄ±p sol taraftaki deÄŸiÅŸkenin temsil ettiÄŸi bellek hÃ¼cresine yazÄ±lmasÄ±dÄ±r."],
    ["Sol taraftaki deÄŸiÅŸken, saÄŸ taraftaki deÄŸere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.", "DeÄŸiÅŸken dÃ¶nÃ¼ÅŸmez, deÄŸeri deÄŸiÅŸir."],
    ["Her iki taraf da sabit bir deÄŸer olmalÄ±dÄ±r.", "Sol tarafÄ±n deÄŸeri deÄŸiÅŸtirilebilen bir deÄŸiÅŸken olmasÄ± gerekir."]
  ],
  answer: 2,
  summary: "Atama iÅŸlemi, imperative programlamanÄ±n en temel eylemidir. Bu eylem, veriyi bir yerden (saÄŸ taraf) alÄ±p baÅŸka bir yere (sol taraf) kopyalamaktÄ±r."
},
{
  q: "17. Ä°ÅŸlenen sayÄ±sÄ±na (arity) gÃ¶re, `++` (artÄ±rma) ve `-` (negatif yapma) iÅŸlemcileri hangi sÄ±nÄ±fa girer?",
  options: [
    ["Ä°kili (Binary) Ä°ÅŸlemciler", "Binary iÅŸlemciler `a+b` gibi iki iÅŸlenen alÄ±r."],
    ["Tekli (Unary) Ä°ÅŸlemciler", "Unary iÅŸlemciler `-5` veya `sayi++` gibi tek bir iÅŸlenen Ã¼zerinde Ã§alÄ±ÅŸÄ±r."],
    ["ÃœÃ§lÃ¼ (Ternary) Ä°ÅŸlemciler", "Ternary iÅŸlemci `(koÅŸul ? doÄŸru : yanlÄ±ÅŸ)` gibi Ã¼Ã§ iÅŸlenen alÄ±r."],
    ["SayÄ±sal Ä°ÅŸlemciler", "Bu, iÅŸlemcinin tÃ¼rÃ¼nÃ¼ belirtir (sayÄ±sal, mantÄ±ksal), iÅŸlenen sayÄ±sÄ±nÄ± deÄŸil."],
    ["Ä°liÅŸkisel Ä°ÅŸlemciler", "Bu da iÅŸlemcinin tÃ¼rÃ¼nÃ¼ belirtir."]
  ],
  answer: 1,
  summary: "Bir iÅŸlemcinin 'arity'si, onun kaÃ§ 'argÃ¼man' aldÄ±ÄŸÄ±nÄ± belirtir. `+` ve `*` gibi iÅŸlemciler genellikle iki argÃ¼man alÄ±rken (binary), `++`, `--` veya `!` (deÄŸil) gibi iÅŸlemciler tek bir argÃ¼man Ã¼zerinde Ã§alÄ±ÅŸÄ±r (unary)."
},
{
  q: "18. AÅŸaÄŸÄ±daki dillerden hangisi, isimlendirilmiÅŸ bir sabit tanÄ±mlamak iÃ§in `const` anahtar kelimesini kullanÄ±r?",
  options: [
    ["C", "C dili, sabit benzeri yapÄ±lar iÃ§in genellikle `#define` Ã¶n iÅŸlemci komutunu kullanÄ±r."],
    ["PHP", "PHP, sabitleri `define()` fonksiyonu ile tanÄ±mlar."],
    ["Java", "Java, sabitler iÃ§in `final` anahtar kelimesini kullanÄ±r."],
    ["Pascal", "Pascal, isimlendirilmiÅŸ sabitlerin tanÄ±mlanmasÄ± iÃ§in `const` tanÄ±mlayÄ±cÄ±sÄ±nÄ± kullanÄ±r."],
    ["FORTRAN", "FORTRAN'da bu amaÃ§la `PARAMETER` ifadesi kullanÄ±lÄ±r."]
  ],
  answer: 3,
  summary: "Ä°simlendirilmiÅŸ sabit kavramÄ± birÃ§ok dilde bulunsa da, bu kavramÄ± gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±lan sÃ¶zdizimi (syntax) dilden dile farklÄ±lÄ±k gÃ¶sterir. Pascal'da bu iÅŸ iÃ§in `const` kullanÄ±lÄ±r."
},
{
  q: "19. `2 ** 3 ** 2` gibi bir Ã¼s alma ifadesinin, saÄŸdan sola doÄŸru yani `2 ** (3 ** 2)` ÅŸeklinde hesaplanarak sonucun `2 ** 9 = 512` bulunmasÄ±, Ã¼s alma iÅŸlemcisinin hangi Ã¶zelliÄŸini gÃ¶sterir?",
  options: [
    ["Sol associative olma", "Sol associative olsaydÄ± `(2 ** 3) ** 2 = 8 ** 2 = 64` olarak hesaplanÄ±rdÄ±."],
    ["SaÄŸ associative olma", "Bir iÅŸlemcinin birden Ã§ok kez yer aldÄ±ÄŸÄ± bir ifadede iÅŸlemler saÄŸdan sola doÄŸru gruplanÄ±yorsa, o iÅŸlemci 'saÄŸ associative'dir. Ãœs alma, bu Ã¶zelliÄŸe sahip olan nadir aritmetik iÅŸlemcilerden biridir."],
    ["DÃ¼ÅŸÃ¼k Ã¶ncelikli olma", "Ãœs alma genellikle diÄŸer aritmetik iÅŸlemcilerden daha yÃ¼ksek Ã¶nceliÄŸe sahiptir."],
    ["Postfix gÃ¶sterimde olma", "Bu gÃ¶sterim infix bir gÃ¶sterimdir."],
    ["MantÄ±ksal bir iÅŸlemci olma", "Ãœs alma sayÄ±sal bir iÅŸlemcidir."]
  ],
  answer: 1,
  summary: "Ã‡oÄŸu aritmetik iÅŸlemci soldan saÄŸa doÄŸru iÅŸlenirken, Ã¼s alma gibi bazÄ± iÅŸlemciler saÄŸdan sola doÄŸru iÅŸlenir. Bu kuralÄ± bilmek, karmaÅŸÄ±k matematiksel ifadelerin doÄŸru sonuÃ§ vermesi iÃ§in kritik Ã¶neme sahiptir."
},
{
  q: "20. `if (x > 5) OR (y < 10)` gibi bir yapÄ±, hangi tÃ¼r ifadeye Ã¶rnektir?",
  options: [
    ["SayÄ±sal Ä°fade", "SayÄ±sal ifadeler `5 * 3` gibi sayÄ±sal bir sonuÃ§ Ã¼retir."],
    ["Atama Deyimi", "Atama deyimi bir deÄŸiÅŸkene deÄŸer aktarÄ±r."],
    ["MantÄ±ksal Ä°fade", "MantÄ±ksal ifadeler; mantÄ±ksal deÄŸiÅŸkenler, mantÄ±ksal sabitler (true/false), iliÅŸkisel ifadeler (`x > 5`) ve mantÄ±ksal iÅŸlemcilerden (`OR`, `AND`) oluÅŸur ve sonuÃ§ olarak doÄŸru veya yanlÄ±ÅŸ bir deÄŸer Ã¼retir."],
    ["Karakter Dizisi Ä°fadesi", "Bu tÃ¼r ifadeler metinlerle ilgilidir."],
    ["Fonksiyon Ã‡aÄŸrÄ±mÄ±", "Bu, bir fonksiyonun adÄ±nÄ± ve parametrelerini iÃ§erir."]
  ],
  answer: 2,
  summary: "MantÄ±ksal ifadeler, programlarÄ±n karar verme mekanizmalarÄ±nÄ±n temelidir. Bir veya daha fazla koÅŸulun birleÅŸtirilerek tek bir 'doÄŸru' veya 'yanlÄ±ÅŸ' sonucu Ã¼retilmesini saÄŸlarlar. `if` gibi kontrol yapÄ±larÄ±nÄ±n temelini oluÅŸtururlar."
},
{
  q: "21. Diziler (Arrays), KayÄ±tlar (Records) ve GÃ¶stergeler (Pointers) hangi veri tipi grubuna aittir?",
  options: [
    ["Ä°lkel Tipler", "Ä°lkel tipler, bÃ¶lÃ¼nemeyen temel tiplerdir."],
    ["KullanÄ±cÄ± TanÄ±mlÄ± Tipler", "Bunlar kullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanabilir ama genel kategorileri yapÄ±sal tiptir."],
    ["SayÄ±sal Tipler", "Bu tipler sadece sayÄ±sal veri tutmazlar."],
    ["YapÄ±sal Tipler", "YapÄ±sal tipler, ilkel veya diÄŸer yapÄ±sal tiplerin bir araya gelmesiyle oluÅŸan daha karmaÅŸÄ±k veri yapÄ±larÄ±dÄ±r. Diziler, kayÄ±tlar ve gÃ¶stergeler bu gruba girer."],
    ["MantÄ±ksal Tipler", "Bu tipler sadece doÄŸru/yanlÄ±ÅŸ deÄŸeri tutarlar."]
  ],
  answer: 3,
  summary: "Veri tipleri temelde ikiye ayrÄ±lÄ±r: tek bir deÄŸer tutan 'ilkel' tipler ve birden Ã§ok deÄŸeri organize bir ÅŸekilde bir arada tutan 'yapÄ±sal' tipler."
},
{
  q: "22. DeÄŸiÅŸken isimlerinin oluÅŸturulmasÄ±nda, gÃ¼nÃ¼mÃ¼zdeki modern programlama dillerinin yaklaÅŸÄ±mÄ± genellikle nasÄ±ldÄ±r?",
  options: [
    ["Ä°simlerin en fazla 6 veya 8 karakterle sÄ±nÄ±rlandÄ±rÄ±lmasÄ±", "Bu, eski dillerde (Ã¶rn: ilk FORTRAN sÃ¼rÃ¼mleri) gÃ¶rÃ¼len bir yaklaÅŸÄ±mdÄ±."],
    ["Ä°simlerde sadece bÃ¼yÃ¼k harflere izin verilmesi", "Bu yaygÄ±n bir kural deÄŸildir."],
    ["Ä°simler iÃ§in kullanÄ±ÅŸlÄ± bir uzunluk sÄ±nÄ±rÄ± koymak ve Ã§oklu kelimeler iÃ§in alt Ã§izgi `_` karakterinin kullanÄ±mÄ±na izin vermek", "Modern diller, `toplam_ogrenci_sayisi` gibi aÃ§Ä±klayÄ±cÄ± ve okunabilir deÄŸiÅŸken isimlerinin kullanÄ±lmasÄ±nÄ± teÅŸvik etmek iÃ§in esnek uzunluk limitleri ve ayÄ±rÄ±cÄ± karakterler sunar."],
    ["DeÄŸiÅŸken isimlerinde alt Ã§izgi `_` karakterinin yasaklanmasÄ±", "Tam tersine, bu karakter genellikle teÅŸvik edilir."],
    ["TÃ¼m deÄŸiÅŸken isimlerinin `var_` Ã¶n eki ile baÅŸlamasÄ±nÄ±n zorunlu olmasÄ±", "Bu, bazÄ± kodlama stillerinde gÃ¶rÃ¼lebilse de bir dil kuralÄ± deÄŸildir."]
  ],
  answer: 2,
  summary: "Ä°yi bir programlamanÄ±n temelinde kodun okunabilir olmasÄ± yatar. Modern diller de bu prensibi destekleyerek, programcÄ±larÄ±n `x`, `y` gibi anlamsÄ±z isimler yerine, deÄŸiÅŸkenin amacÄ±nÄ± aÃ§Ä±klayan uzun ve anlaÅŸÄ±lÄ±r isimler kullanmasÄ±na olanak tanÄ±r."
},
{
  q: "23. Bir iÅŸlemcinin alabileceÄŸi iÅŸlenen sayÄ±sÄ±na gÃ¶re sÄ±nÄ±flandÄ±rÄ±lmasÄ±na ne ad verilir?",
  options: [
    ["Ã–ncelik (Precedence)", "Bu, iÅŸlem sÄ±rasÄ±nÄ± belirler."],
    ["Ä°ÅŸlemcinin Yeri (Placement)", "Bu, iÅŸlemcinin konumunu (prefix, infix) belirtir."],
    ["Ä°ÅŸlenen SayÄ±sÄ± (Arity)", "Bir iÅŸlemcinin 'arity'si, onun tekli (unary), ikili (binary) veya Ã¼Ã§lÃ¼ (ternary) olup olmadÄ±ÄŸÄ±nÄ±, yani kaÃ§ iÅŸlenen aldÄ±ÄŸÄ±nÄ± belirtir."],
    ["Associativity", "Bu, aynÄ± Ã¶ncelikli iÅŸlemcilerin yÃ¶nÃ¼nÃ¼ belirler."],
    ["Kapsam (Scope)", "Bu, deÄŸiÅŸkenlerle ilgili bir kavramdÄ±r."]
  ],
  answer: 2,
  summary: "Ä°ÅŸlemcilerin genel Ã¶zellikleri arasÄ±nda yer alan 'arity', o iÅŸlemcinin doÄŸasÄ±nÄ± anlamak iÃ§in Ã¶nemlidir. `a+b`'deki `+` iki iÅŸlenen alÄ±rken `-a`'daki `-` tek iÅŸlenen alÄ±r."
},
{
  q: "24. C dilinde bir sabiti tanÄ±mlamak iÃ§in genellikle hangi yÃ¶ntem kullanÄ±lÄ±r?",
  options: [
    ["`const` tanÄ±mlayÄ±cÄ±sÄ±", "Bu Pascal'da kullanÄ±lÄ±r."],
    ["`define()` fonksiyonu", "Bu PHP'de kullanÄ±lÄ±r."],
    ["`final` anahtar kelimesi", "Bu Java'da kullanÄ±lÄ±r."],
    ["`let` anahtar kelimesi", "Bu JavaScript'te deÄŸiÅŸken tanÄ±mlamak iÃ§in kullanÄ±lÄ±r."],
    ["`#define` Ã¶n iÅŸlemci komutu", "C'de, derlemeden Ã¶nce metinsel deÄŸiÅŸiklik yapan Ã¶n iÅŸlemci, `#define PI 3.14` gibi komutlarla isimlendirilmiÅŸ sabitler oluÅŸturmak iÃ§in yaygÄ±n olarak kullanÄ±lÄ±r."]
  ],
  answer: 4,
  summary: "FarklÄ± diller, sabitleri tanÄ±mlamak iÃ§in farklÄ± mekanizmalar sunar. C dilinin kendine Ã¶zgÃ¼ yapÄ±sÄ±, bu iÅŸ iÃ§in derleme Ã¶ncesi Ã§alÄ±ÅŸan bir araÃ§ olan Ã¶n iÅŸlemciyi (preprocessor) ve onun `#define` komutunu kullanÄ±r."
},
{
  q: "25. FORTRAN dilinde `REAL` kelimesinin, kullanÄ±ldÄ±ÄŸÄ± yere gÃ¶re hem bir tip tanÄ±mlayÄ±cÄ± (`REAL ELMA`) hem de bir deÄŸiÅŸken ismi (`REAL = 87.6`) olarak kullanÄ±labilmesi, `REAL` kelimesinin ne tÃ¼r bir Ã¶zel kelime olduÄŸunu gÃ¶sterir?",
  options: [
    ["AyrÄ±lmÄ±ÅŸ Kelime (Reserved Word)", "AyrÄ±lmÄ±ÅŸ kelime olsaydÄ± deÄŸiÅŸken ismi olarak kullanÄ±lamazdÄ±."],
    ["Anahtar Kelime (Keyword)", "Anahtar kelime, sadece belirli bir baÄŸlamda Ã¶zel bir anlam taÅŸÄ±yan, ancak diÄŸer baÄŸlamlarda normal bir isim olarak kullanÄ±lmasÄ±na izin verilen kelimedir. Bu durum, dilin okunabilirliÄŸini azaltabilir."],
    ["Ä°lkel Tip", "REAL bir tipi ifade edebilir ancak sorulan, kelimenin bu ikili kullanÄ±mÄ±nÄ±n adÄ±dÄ±r."],
    ["Ã–n iÅŸlemci Komutu", "Bu, C dilindeki `#define` gibi bir Ã¶zelliktir."],
    ["Fonksiyon AdÄ±", "Bu bir fonksiyon adÄ± deÄŸildir."]
  ],
  answer: 1,
  summary: "Bir kelimenin hem Ã¶zel bir komut hem de bir deÄŸiÅŸken adÄ± olarak kullanÄ±labilmesi, eski dillerde gÃ¶rÃ¼len bir esneklikti. Ancak bu durum kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ±na yol aÃ§tÄ±ÄŸÄ± iÃ§in modern dillerin Ã§oÄŸu, `if`, `for`, `while` gibi tÃ¼m Ã¶zel kelimeleri 'ayrÄ±lmÄ±ÅŸ kelime' yaparak bunlarÄ±n deÄŸiÅŸken olarak kullanÄ±lmasÄ±nÄ± engeller."
},
{
  q: "26. Bir ifadenin bileÅŸenlerinin deÄŸerlendirilme sÄ±rasÄ±nÄ± belirleyen 'Ã¶ncelik' ve 'associativity' kurallarÄ±nÄ± geÃ§ersiz kÄ±lÄ±p sÄ±rayÄ± programcÄ±nÄ±n belirlemesini saÄŸlayan yapÄ± nedir?",
  options: [
    ["NoktalÄ± virgÃ¼l (;)", "NoktalÄ± virgÃ¼l genellikle bir deyimi sonlandÄ±rÄ±r."],
    ["Parantez (())", "Bir ifadede parantez iÃ§ine alÄ±nan bÃ¶lÃ¼m, diÄŸer tÃ¼m Ã¶ncelik ve associativity kurallarÄ±ndan baÄŸÄ±msÄ±z olarak her zaman Ã¶nce hesaplanÄ±r. `(3 + 5) * 2` ifadesi bu sayede 16 sonucunu verir."],
    ["Alt Ã§izgi (_)", "Alt Ã§izgi, deÄŸiÅŸken isimlendirmede kullanÄ±lÄ±r."],
    ["Atama operatÃ¶rÃ¼ (=)", "Atama operatÃ¶rÃ¼ bir deÄŸiÅŸkene deÄŸer aktarÄ±r."],
    ["SÃ¼slÃ¼ parantez ({})", "SÃ¼slÃ¼ parantez genellikle bir kod bloÄŸunu tanÄ±mlar."]
  ],
  answer: 1,
  summary: "Ä°ÅŸlemci Ã¶ncelik kurallarÄ±, parantez olmadÄ±ÄŸÄ±nda geÃ§erlidir. ProgramcÄ±, parantez kullanarak varsayÄ±lan iÅŸlem sÄ±rasÄ±nÄ± ezebilir ve kendi istediÄŸi sÄ±rayÄ± zorunlu kÄ±labilir. Bu, ifadeler Ã¼zerinde tam kontrol saÄŸlar."
},
{
  q: "27. PHP gibi 'type strict' (katÄ± tipli) olmayan bir dilde, `$sayi = 5;` satÄ±rÄ±ndan sonra `$sayi = 'Ahmet';` satÄ±rÄ±nÄ±n yazÄ±labilmesi ne anlama gelir?",
  options: [
    ["PHP'de deÄŸiÅŸkenlerin tipi asla deÄŸiÅŸtirilemez.", "Tam tersi, bu Ã¶rnekte tipi deÄŸiÅŸmiÅŸtir."],
    ["DeÄŸiÅŸkenin tipi, iÃ§ine atanan son deÄŸerin tipine otomatik olarak dÃ¶nÃ¼ÅŸÃ¼r.", "KatÄ± tipli olmayan dillerde bir deÄŸiÅŸkenin tipi sabit deÄŸildir. DeÄŸiÅŸken, baÅŸlangÄ±Ã§ta tamsayÄ± tutarken daha sonra iÃ§ine bir metin atandÄ±ÄŸÄ±nda tipi de metin (string) olarak deÄŸiÅŸir. Buna dinamik tipleme denir."],
    ["PHP'de tÃ¼m deÄŸiÅŸkenler metin (string) tipindedir.", "HayÄ±r, tamsayÄ±, ondalÄ±klÄ± sayÄ± gibi farklÄ± tipler de vardÄ±r."],
    ["Ä°kinci satÄ±r bir hata verecektir.", "KatÄ± tipli olmayan bir dilde bu bir hata deÄŸildir."],
    ["PHP sayÄ±sal ve metinsel verileri ayÄ±rt edemez.", "AyÄ±rt edebilir, ancak bir deÄŸiÅŸkenin her iki tÃ¼rÃ¼ de tutmasÄ±na izin verir."]
  ],
  answer: 1,
  summary: "Programlama dilleri, tipleri yÃ¶netme konusunda farklÄ± yaklaÅŸÄ±mlar sergiler. C veya Java gibi katÄ± tipli diller, bir deÄŸiÅŸkenin tipinin program boyunca sabit kalmasÄ±nÄ± zorunlu tutarken, PHP veya Python gibi diller bu konuda daha esnektir ve deÄŸiÅŸkenin tipinin Ã§alÄ±ÅŸma zamanÄ±nda deÄŸiÅŸmesine izin verir."
},
{
  q: "28. Ä°ÅŸlemcilerin genel Ã¶zelliklerini belirleyen dÃ¶rt temel kavram hangi seÃ§enekte doÄŸru olarak verilmiÅŸtir?",
  options: [
    ["SayÄ±sal, Ä°liÅŸkisel, MantÄ±ksal, Atama", "Bu, iÅŸlemcilerin iÅŸlenenlerin niteliÄŸine gÃ¶re sÄ±nÄ±flandÄ±rÄ±lmasÄ±dÄ±r."],
    ["Ä°ÅŸlenen SayÄ±sÄ±, Ä°ÅŸlemcinin Yeri, Ã–ncelik, Associativity", "Bu dÃ¶rt kavram, bir iÅŸlemcinin nasÄ±l yazÄ±lacaÄŸÄ±nÄ± ve bir ifadede nasÄ±l davranacaÄŸÄ±nÄ± belirleyen temel genel Ã¶zellikleridir."],
    ["Prefix, Infix, Postfix, Unary", "Bunlar 'Ä°ÅŸlemcinin Yeri' ve 'Ä°ÅŸlenen SayÄ±sÄ±' Ã¶zelliklerinin alt kategorileridir, dÃ¶rt temel kavramÄ±n tamamÄ± deÄŸildir."],
    ["DeÄŸer, Tip, Kapsam, YaÅŸam SÃ¼resi", "Bunlar deÄŸiÅŸkenlerin Ã¶zellikleridir, iÅŸlemcilerin deÄŸil."],
    ["Toplama, Ã‡Ä±karma, Ã‡arpma, BÃ¶lme", "Bunlar spesifik iÅŸlemci Ã¶rnekleridir."]
  ],
  answer: 1,
  summary: "Bir dildeki iÅŸlemcilerin davranÄ±ÅŸÄ±nÄ± anlamak iÃ§in bu dÃ¶rt Ã¶zelliÄŸe bakÄ±lÄ±r: KaÃ§ iÅŸlenen alÄ±yor? (Arity), Ä°ÅŸlenenlere gÃ¶re nerede duruyor? (Placement), DiÄŸerlerinden daha mÄ± Ã¶nemli? (Precedence), Kendisi gibilerle yan yana gelince ne yapÄ±yor? (Associativity)."
},
{
  q: "29. Bir deÄŸiÅŸkenin programdaki deyimler tarafÄ±ndan gÃ¶rÃ¼lebildiÄŸi veya eriÅŸilebildiÄŸi program bÃ¶lgesi, o deÄŸiÅŸkenin hangi Ã¶zelliÄŸidir?",
  options: [
    ["YaÅŸam SÃ¼resi (Lifetime)", "YaÅŸam sÃ¼resi, deÄŸiÅŸkenin bellekte ne kadar sÃ¼re kaldÄ±ÄŸÄ±dÄ±r."],
    ["Tip (Type)", "Tip, deÄŸiÅŸkenin deÄŸer aralÄ±ÄŸÄ±dÄ±r."],
    ["DeÄŸer (Value)", "DeÄŸer, deÄŸiÅŸkenin iÃ§eriÄŸidir."],
    ["Kapsam (Scope)", "Bir deÄŸiÅŸkenin kapsamÄ±, o deÄŸiÅŸkenin programÄ±n hangi satÄ±rlarÄ± arasÄ±nda tanÄ±ndÄ±ÄŸÄ±nÄ± ve kullanÄ±labileceÄŸini belirler. Ã–rneÄŸin, bir fonksiyon iÃ§inde tanÄ±mlanan deÄŸiÅŸkenin kapsamÄ± o fonksiyonla sÄ±nÄ±rlÄ±dÄ±r."],
    ["Adres (Address)", "Adres, deÄŸiÅŸkenin bellekteki fiziksel konumudur."]
  ],
  answer: 3,
  summary: "Kapsam, bir deÄŸiÅŸkenin 'etki alanÄ±nÄ±' tanÄ±mlar. Global kapsama sahip deÄŸiÅŸkenlere programÄ±n her yerinden eriÅŸilebilirken, yerel (local) kapsama sahip deÄŸiÅŸkenlere sadece tanÄ±mlandÄ±klarÄ± blok veya fonksiyon iÃ§inden eriÅŸilebilir."
},
{
  q: "30. Imperative programlamada bir programÄ±n, iÅŸlem deyimleri aracÄ±lÄ±ÄŸÄ±yla bellekteki deÄŸerleri deÄŸiÅŸtirmesi, hangi temel bilgisayar mimarisine dayanÄ±r?",
  options: [
    ["Bulut Mimarisi", "Bu, daÄŸÄ±tÄ±k sistemlerle ilgili bir mimaridir."],
    ["Paralel Mimarisi", "Bu, Ã§oklu iÅŸlemcilerle ilgili bir mimaridir."],
    ["von Neumann Mimarisi", "Imperative programlama, program komutlarÄ±nÄ±n ve verilerin aynÄ± bellekte bulunduÄŸu ve komutlarÄ±n bu bellekteki verileri deÄŸiÅŸtirdiÄŸi von Neumann mimarisi Ã¼zerine kurulmuÅŸtur."],
    ["Kuantum Mimarisi", "Bu, kuantum hesaplama iÃ§in kullanÄ±lan tamamen farklÄ± bir mimaridir."],
    ["Harvard Mimarisi", "Bu mimari, komut ve veri belleklerini ayÄ±rÄ±r."]
  ],
  answer: 2,
  summary: "Programlama paradigmalarÄ± genellikle temel donanÄ±m mimarilerinden etkilenir. Imperative programlamanÄ±n 'deÄŸiÅŸkenler aracÄ±lÄ±ÄŸÄ±yla bellek durumunu deÄŸiÅŸtirme' mantÄ±ÄŸÄ±, von Neumann mimarisinin Ã§alÄ±ÅŸma prensibinin doÄŸrudan bir yazÄ±lÄ±m yansÄ±masÄ±dÄ±r."
}    
  ];

  const quizDiv = document.getElementById('quiz');
  const optionLabels = ['A)', 'B)', 'C)', 'D)', 'E)'];
  const userAnswers = new Array(questions.length).fill(null);


  questions.forEach((qObj, index) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'question-container';
    questionContainer.id = `question-${index}`;

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = qObj.q;
    questionContainer.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options-group';

    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback';
    feedbackDiv.style.display = 'none'; // Initially hidden

    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'summary';
    summaryDiv.style.display = 'none'; // Initially hidden


    qObj.options.forEach((opt, i) => {
      const optDiv = document.createElement('div');
      optDiv.className = 'option';
      optDiv.textContent = `${optionLabels[i]} ${opt[0]}`;
      optDiv.onclick = () => {
        // Clear previous selection visuals for this question
        const allOptsInGroup = optsDiv.querySelectorAll('.option');
        allOptsInGroup.forEach(el => el.classList.remove('selected'));
        optDiv.classList.add('selected'); // Mark as selected

        userAnswers[index] = i; // Store user's answer

        // Show feedback immediately
        const feedbackText = opt[1] || (i === qObj.answer ? "DoÄŸru cevap!" : "YanlÄ±ÅŸ cevap."); // Fallback feedback
        feedbackDiv.className = 'feedback ' + (i === qObj.answer ? 'correct' : 'incorrect');
        feedbackDiv.style.display = 'block';
        feedbackDiv.textContent = (i === qObj.answer ? 'âœ”ï¸ DoÄŸru: ' : 'âŒ YanlÄ±ÅŸ: ') + feedbackText;


        if (i === qObj.answer && qObj.summary) {
          summaryDiv.style.display = 'block';
          summaryDiv.textContent = 'ðŸ’¡ ' + qObj.summary;
        } else {
          summaryDiv.style.display = 'none';
        }
      };
      optsDiv.appendChild(optDiv);
    });

    questionContainer.appendChild(optsDiv);
    questionContainer.appendChild(feedbackDiv);
    questionContainer.appendChild(summaryDiv);
    quizDiv.appendChild(questionContainer);
  });

  function showResults() {
    let correctCount = 0;
    userAnswers.forEach((answer, index) => {
        if (answer !== null && answer === questions[index].answer) {
            correctCount++;
        }
    });

    const totalQuestions = questions.length;
    const scorePercentage = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(2) : 0;

    document.getElementById('total-questions').textContent = totalQuestions;
    document.getElementById('correct-answers').textContent = correctCount;
    document.getElementById('score-percentage').textContent = scorePercentage;
    document.getElementById('results-summary').style.display = 'block';

    // Scroll to results
    document.getElementById('results-summary').scrollIntoView({ behavior: 'smooth' });
  }

</script>
</body>
</html>