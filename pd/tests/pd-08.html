<!DOCTYPE html>
<html lang="tr">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Programlama Dilleri - 8</title>
  <style>
    body { font-family: 'PT Sans', 'Trebuchet MS', sans-serif; background: #f9f9f9; padding: 20px; color: #333; }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .question-container { background: #fff; padding: 20px; margin-bottom: 25px; border-left: 5px solid #007BFF; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-text { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; }
    .option { padding: 10px; margin: 8px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; transition: background-color 0.2s ease-in-out; }
    .option:hover { background: #e9ecef; }
    .option.selected { background-color: #cce5ff; border-color: #b8daff; }
    .feedback { margin-top: 15px; padding: 12px; border-radius: 4px; display: none; font-weight: bold; }
    .correct { background: #d4edda; border-left: 5px solid #28a745; color: #155724; }
    .incorrect { background: #f8d7da; border-left: 5px solid #dc3545; color: #721c24; }
    .summary { display: none; background: #fff3cd; padding: 12px; margin-top: 10px; border-left: 5px solid #ffc107; border-radius: 4px; color: #856404; }
    button#submit-all {
        display: block;
        margin: 30px auto;
        padding: 12px 25px;
        font-size: 1.1em;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    button#submit-all:hover {
        background-color: #218838;
    }
    .results { margin-top: 30px; padding: 20px; background-color: #e9ecef; border-radius: 5px; text-align: center;}
  </style>
</head>
<body>
<h1>Programlama Dilleri - 8</h1>
<div id="quiz">
  </div>
<button id="submit-all" onclick="showResults()">TÃ¼m Testi Bitir ve SonuÃ§larÄ± GÃ¶r</button>
<div id="results-summary" class="results" style="display:none;">
    <h2>Test Sonucu</h2>
    <p>Toplam Soru: <span id="total-questions"></span></p>
    <p>DoÄŸru Cevap SayÄ±sÄ±: <span id="correct-answers"></span></p>
    <p>BaÅŸarÄ± YÃ¼zdesi: <span id="score-percentage"></span>%</p>
</div>

<script>
  const questions = [
{
  q: "1. `WHILE` ve `REPEAT...UNTIL` tipi koÅŸullu dÃ¶ngÃ¼ler arasÄ±ndaki en temel fark nedir?",
  options: [
    ["WHILE dÃ¶ngÃ¼sÃ¼ sayÄ±sal, UNTIL dÃ¶ngÃ¼sÃ¼ mantÄ±ksal koÅŸul kullanÄ±r.", "Her ikisi de mantÄ±ksal koÅŸul kullanÄ±r."],
    ["WHILE dÃ¶ngÃ¼sÃ¼nde koÅŸul dÃ¶ngÃ¼nÃ¼n baÅŸÄ±nda, UNTIL dÃ¶ngÃ¼sÃ¼nde ise sonunda denetlenir.", "Bu, aralarÄ±ndaki en temel ve kritik farktÄ±r. Bu nedenle UNTIL dÃ¶ngÃ¼sÃ¼ her durumda en az bir kere Ã§alÄ±ÅŸÄ±r, WHILE ise hiÃ§ Ã§alÄ±ÅŸmayabilir."],
    ["WHILE dÃ¶ngÃ¼sÃ¼ sonsuza kadar Ã§alÄ±ÅŸabilir, UNTIL dÃ¶ngÃ¼sÃ¼ ise Ã§alÄ±ÅŸamaz.", "Her iki dÃ¶ngÃ¼ de yanlÄ±ÅŸ kurulursa sonsuz dÃ¶ngÃ¼ye girebilir."],
    ["WHILE dÃ¶ngÃ¼sÃ¼ sayaÃ§lÄ±, UNTIL dÃ¶ngÃ¼sÃ¼ koÅŸullu dÃ¶ngÃ¼dÃ¼r.", "Her ikisi de koÅŸullu dÃ¶ngÃ¼ tÃ¼rÃ¼dÃ¼r."],
    ["HiÃ§bir temel farklarÄ± yoktur, sadece sÃ¶zdizimleri farklÄ±dÄ±r.", "HayÄ±r, Ã§alÄ±ÅŸma mantÄ±klarÄ± arasÄ±nda Ã§ok Ã¶nemli bir fark vardÄ±r."]
  ],
  answer: 1,
  summary: "Bu temel fark, dÃ¶ngÃ¼ye girilmeden Ã¶nce koÅŸulun bilinip bilinmediÄŸi durumlarda Ã¶nemlidir. `WHILE`, koÅŸul en baÅŸta yanlÄ±ÅŸsa dÃ¶ngÃ¼ye hiÃ§ girmez. `REPEAT...UNTIL` ise ne olursa olsun dÃ¶ngÃ¼ye bir kez girer, iÅŸlemlerini yapar ve ancak ondan sonra koÅŸulu kontrol eder."
},
{
  q: "2. `SayÄ± = 11` baÅŸlangÄ±Ã§ deÄŸeri iÃ§in, `WHILE (Mod(SayÄ±,2)=0) SayÄ± = SayÄ± / 2` dÃ¶ngÃ¼sÃ¼nÃ¼n sonunda 'SayÄ±' deÄŸiÅŸkeninin deÄŸeri ne olur?",
  options: [
    ["5.5", "Bu sonuÃ§, dÃ¶ngÃ¼nÃ¼n bir kez Ã§alÄ±ÅŸmasÄ± durumunda elde edilirdi, ancak dÃ¶ngÃ¼ hiÃ§ Ã§alÄ±ÅŸmaz."],
    ["11", "KoÅŸul (`11 % 2 == 0`) baÅŸlangÄ±Ã§ta YANLIÅž olduÄŸu iÃ§in, program akÄ±ÅŸÄ± dÃ¶ngÃ¼ye hiÃ§ girmez ve 'SayÄ±' deÄŸiÅŸkeninin deÄŸeri deÄŸiÅŸmeden 11 olarak kalÄ±r."],
    ["0", "Bu hatalÄ± bir sonuÃ§tur."],
    ["1", "Bu hatalÄ± bir sonuÃ§tur."],
    ["Program hata verir.", "Program hata vermez, sadece dÃ¶ngÃ¼ye girmez."]
  ],
  answer: 1,
  summary: "`WHILE` dÃ¶ngÃ¼sÃ¼ bir 'Ã¶n-denetimli' dÃ¶ngÃ¼dÃ¼r. DÃ¶ngÃ¼nÃ¼n kapÄ±sÄ±nda bir bekÃ§i (koÅŸul) vardÄ±r ve eÄŸer koÅŸul saÄŸlanmÄ±yorsa kimseyi iÃ§eri almaz. Bu Ã¶rnekte 11 Ã§ift sayÄ± olmadÄ±ÄŸÄ± iÃ§in bekÃ§i program akÄ±ÅŸÄ±nÄ± iÃ§eri almaz."
},
{
  q: "3. Bir programda `FOR SayaÃ§=0 TO 199` ÅŸeklinde tanÄ±mlanan parametreli (sayaÃ§lÄ±) bir dÃ¶ngÃ¼ toplamda kaÃ§ kez Ã§alÄ±ÅŸÄ±r?",
  options: [
    ["198", "Bu hatalÄ± bir hesaplamadÄ±r."],
    ["199", "EÄŸer dÃ¶ngÃ¼ 1'den baÅŸlasaydÄ± 199 kez Ã§alÄ±ÅŸÄ±rdÄ±."],
    ["200", "DÃ¶ngÃ¼ 0'dan baÅŸlayÄ±p 199'a kadar (199 dahil) tÃ¼m deÄŸerleri alacaÄŸÄ± iÃ§in, toplamda `199 - 0 + 1 = 200` kez tekrarlanÄ±r."],
    ["201", "Bu hatalÄ± bir hesaplamadÄ±r."],
    ["Sonsuza kadar", "Bu bir koÅŸullu dÃ¶ngÃ¼ deÄŸil, sayaÃ§lÄ± bir dÃ¶ngÃ¼dÃ¼r ve sonlanma noktasÄ± bellidir."]
  ],
  answer: 2,
  summary: "SayaÃ§lÄ± dÃ¶ngÃ¼lerde tekrar sayÄ±sÄ±nÄ± hesaplarken baÅŸlangÄ±Ã§ deÄŸerinin 0 mÄ± yoksa 1 mi olduÄŸuna dikkat etmek Ã§ok Ã¶nemlidir. Programlamada indisler ve sayaÃ§lar genellikle 0'dan baÅŸlar."
},
{
  q: "4. KoÅŸullu ifadelerin en basit hali olan ve sadece koÅŸulun saÄŸlanmasÄ± durumunda bir iÅŸlem yapan, saÄŸlanmamasÄ± durumunda ise program akÄ±ÅŸÄ±na normal devam eden yapÄ± hangisidir?",
  options: [
    ["Tip 1 (IF...THEN)", "Bu tip, sadece doÄŸru (TRUE) yolu iÃ§in bir eylem tanÄ±mlar; yanlÄ±ÅŸ yolu iÃ§in Ã¶zel bir eylem yoktur."],
    ["Tip 2 (IF...THEN...ELSE)", "Bu tip, hem doÄŸru hem de yanlÄ±ÅŸ yollarÄ± iÃ§in ayrÄ± eylemler tanÄ±mlar."],
    ["Tip 3 (IF...ELSEIF...ELSE)", "Bu tip, bir dizi zincirleme koÅŸulu tanÄ±mlar."],
    ["switch-case", "Bu, Tip 3'e benzer bir Ã§oklu seÃ§im yapÄ±sÄ±dÄ±r."],
    ["while", "Bu bir yinelemeli deyimdir."]
  ],
  answer: 0,
  summary: "Tip 1 koÅŸullu ifade, 'eÄŸer hava yaÄŸmurluysa ÅŸemsiyeni al' gibidir. HavanÄ±n yaÄŸmurlu olmamasÄ± durumu iÃ§in Ã¶zel bir talimat vermez, sadece normal hayatÄ±na devam edersin."
},
{
  q: "5. `SayÄ± = 12` baÅŸlangÄ±Ã§ deÄŸeri iÃ§in, `WHILE (Mod(SayÄ±,2)=0) SayÄ± = SayÄ± / 2` dÃ¶ngÃ¼sÃ¼nÃ¼n sonunda 'SayÄ±' deÄŸiÅŸkeninin deÄŸeri ne olur?",
  options: [
    ["12", "DÃ¶ngÃ¼ en az bir kez Ã§alÄ±ÅŸacaÄŸÄ± iÃ§in deÄŸer deÄŸiÅŸir."],
    ["6", "Bu, dÃ¶ngÃ¼nÃ¼n ilk adÄ±mÄ±ndan sonraki deÄŸerdir."],
    ["3", "AdÄ±mlar: 1) 12 Ã§ift, SayÄ±=6 olur. 2) 6 Ã§ift, SayÄ±=3 olur. 3) 3 tek olduÄŸu iÃ§in `Mod(3,2)=0` koÅŸulu YANLIÅž olur ve dÃ¶ngÃ¼ sonlanÄ±r. 'SayÄ±' deÄŸiÅŸkeninin son deÄŸeri 3'tÃ¼r."],
    ["1.5", "DÃ¶ngÃ¼ 3 deÄŸerinde sonlanÄ±r."],
    ["0", "Bu hatalÄ± bir sonuÃ§tur."]
  ],
  answer: 2,
  summary: "Bu soru, bir `WHILE` dÃ¶ngÃ¼sÃ¼nÃ¼n adÄ±mlarÄ±nÄ± takip etme (trace etme) yeteneÄŸini Ã¶lÃ§er. Her adÄ±mda koÅŸul yeniden kontrol edilir ve koÅŸul yanlÄ±ÅŸ olana kadar dÃ¶ngÃ¼ devam eder."
},
{
  q: "6. Ä°lkel koÅŸullarÄ±n `AND` ve `OR` gibi mantÄ±ksal baÄŸlaÃ§larla birbirine baÄŸlanmasÄ±yla elde edilen koÅŸullara ne ad verilir?",
  options: [
    ["Ä°liÅŸkisel KoÅŸullar", "Ä°liÅŸkisel koÅŸullar `>` veya `<` gibi karÅŸÄ±laÅŸtÄ±rmalardÄ±r."],
    ["SayÄ±sal KoÅŸullar", "SayÄ±sal koÅŸul diye bir tanÄ±m yoktur, sayÄ±sal ifadeler vardÄ±r."],
    ["BileÅŸik KoÅŸullar (Compound Conditions)", "Birden fazla ilkel koÅŸulun mantÄ±ksal baÄŸlaÃ§larla birleÅŸtirilmesiyle 'bileÅŸik koÅŸullar' oluÅŸturulur. Ã–rneÄŸin: `(puan > 50) AND (devamsizlik < 10)`."],
    ["Parametreli KoÅŸullar", "Bu, dÃ¶ngÃ¼lerle ilgili bir terimdir."],
    ["Basit KoÅŸullar", "Ä°lkel koÅŸullar basit koÅŸullardÄ±r."]
  ],
  answer: 2,
  summary: "BileÅŸik koÅŸullar, programlarÄ±n daha karmaÅŸÄ±k ve gerÃ§ek hayata uygun kararlar almasÄ±nÄ± saÄŸlar. Sadece tek bir ÅŸarta deÄŸil, birden Ã§ok ÅŸartÄ±n aynÄ± anda saÄŸlanÄ±p saÄŸlanmadÄ±ÄŸÄ±na bakarak karar verilebilir."
},
{
  q: "7. AÅŸaÄŸÄ±dakilerden hangisi, problemleri daha kÃ¼Ã§Ã¼k ve Ã§Ã¶zÃ¼mÃ¼ kolay alt problemlere bÃ¶lerek programÄ±n okunabilirliÄŸini ve verimliliÄŸini artÄ±ran bir yapÄ±dÄ±r?",
  options: [
    ["KoÅŸullu Ä°fadeler", "KoÅŸullu ifadeler karar verme mekanizmalarÄ±dÄ±r."],
    ["DÃ¶ngÃ¼ler", "DÃ¶ngÃ¼ler iÅŸlemleri tekrarlar."],
    ["Alt Programlar (Subprograms)", "Alt programlar (fonksiyonlar), 'bÃ¶l ve yÃ¶net' prensibini uygulayarak karmaÅŸÄ±k problemleri daha basit, yÃ¶netilebilir ve yeniden kullanÄ±labilir parÃ§alara ayÄ±rmanÄ±n temel yoludur."],
    ["DeÄŸiÅŸkenler", "DeÄŸiÅŸkenler veri saklar."],
    ["Sabitler", "Sabitler deÄŸeri deÄŸiÅŸmeyen verileri saklar."]
  ],
  answer: 2,
  summary: "BÃ¼yÃ¼k bir projeyi tek bir dosya halinde yazmak yerine, her bir iÅŸlevi kendi alt programÄ±na (fonksiyonuna) bÃ¶lmek, hem kodun anlaÅŸÄ±lmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r hem de aynÄ± iÅŸlevin programÄ±n farklÄ± yerlerinde tekrar tekrar yazÄ±lmasÄ±nÄ± Ã¶nler."
},
{
  q: "8. KoÅŸullu dÃ¶ngÃ¼ler genel olarak hangi durumlarda kullanÄ±lÄ±r?",
  options: [
    ["DÃ¶ngÃ¼de gerÃ§ekleÅŸecek iÅŸlem sayÄ±sÄ±nÄ±n programcÄ± tarafÄ±ndan Ã¶nceden tam olarak bilindiÄŸi durumlarda", "Bu durumlar iÃ§in genellikle parametreli (sayaÃ§lÄ±) `FOR` dÃ¶ngÃ¼leri daha uygundur."],
    ["DÃ¶ngÃ¼de gerÃ§ekleÅŸecek iÅŸlem sayÄ±sÄ±nÄ±n Ã¶nceden belirlenemediÄŸi durumlarda", "KoÅŸullu dÃ¶ngÃ¼ler, bir sayaÃ§tan Ã§ok 'kullanÄ±cÄ± Ã§Ä±kÄ±ÅŸ tuÅŸuna basana kadar' veya 'dosyanÄ±n sonuna gelene kadar' gibi belirsiz sayÄ±da tekrar gerektiren durumlar iÃ§in idealdir."],
    ["Sadece sayÄ±sal iÅŸlemlerin tekrar edileceÄŸi durumlarda", "Her tÃ¼rlÃ¼ iÅŸlemi tekrar etmek iÃ§in kullanÄ±labilirler."],
    ["ProgramÄ±n her zaman en az bir kere Ã§alÄ±ÅŸmasÄ±nÄ±n istendiÄŸi durumlarda", "Bu sadece `UNTIL` tipi koÅŸullu dÃ¶ngÃ¼ler iÃ§in geÃ§erlidir."],
    ["HiÃ§bir koÅŸula baÄŸlÄ± olmadan sÃ¼rekli tekrar eden iÅŸlemler iÃ§in", "SÃ¼rekli tekrar sonsuz dÃ¶ngÃ¼ anlamÄ±na gelir, koÅŸullu dÃ¶ngÃ¼ler bir sonlanma koÅŸuluna sahiptir."]
  ],
  answer: 1,
  summary: "Bir `FOR` dÃ¶ngÃ¼sÃ¼, 'bu iÅŸlemi tam 100 kere yap' demek iÃ§in kullanÄ±lÄ±r. Bir `WHILE` dÃ¶ngÃ¼sÃ¼ ise 'bu iÅŸlemi sonuÃ§ 'evet' olduÄŸu sÃ¼rece yapmaya devam et' demek iÃ§in kullanÄ±lÄ±r. Tekrar sayÄ±sÄ± belli deÄŸilse, koÅŸullu dÃ¶ngÃ¼ doÄŸru seÃ§imdir."
},
{
  q: "9. Tip 3 koÅŸullu ifadeler (`IF...ELSEIF...ELSE`) oluÅŸturulurken dikkat edilmesi gereken en Ã¶nemli noktalardan biri nedir?",
  options: [
    ["TÃ¼m koÅŸullarÄ±n aynÄ± anda doÄŸru olabilmesi", "Tam tersine, bu durum mantÄ±ksal hatalara yol aÃ§ar."],
    ["KoÅŸullarÄ±n etki alanlarÄ±nÄ±n birbirleriyle kesiÅŸmemesi (sadece bir koÅŸulun saÄŸlanmasÄ±)", "Bir `IF...ELSEIF` zincirinde, program akÄ±ÅŸÄ± ilk doÄŸru koÅŸulu bulduÄŸu anda ilgili bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r ve zincirin geri kalanÄ±nÄ± kontrol etmeden Ã§Ä±kar. EÄŸer koÅŸullar kesiÅŸirse, beklenmedik bir bloÄŸun Ã§alÄ±ÅŸmasÄ± gibi mantÄ±k hatalarÄ± oluÅŸabilir."],
    ["Her zaman en az 5 adet `ELSEIF` kullanÄ±lmasÄ±", "BÃ¶yle bir sayÄ± kÄ±sÄ±tlamasÄ± yoktur."],
    ["Sadece sayÄ±sal karÅŸÄ±laÅŸtÄ±rmalar yapÄ±lmasÄ±", "Her tÃ¼rlÃ¼ mantÄ±ksal ifade kullanÄ±labilir."],
    ["`ELSE` bloÄŸunun mutlaka en baÅŸta yer almasÄ±", "`ELSE` bloÄŸu her zaman en sonda yer alÄ±r."]
  ],
  answer: 1,
  summary: "Bir not hesaplama sisteminde, `IF (Puan > 50)` ve `ELSEIF (Puan > 70)` gibi bir sÄ±ralama hatalÄ±dÄ±r. Ã‡Ã¼nkÃ¼ 75 alan bir Ã¶ÄŸrenci ilk koÅŸulu (`>50`) saÄŸladÄ±ÄŸÄ± iÃ§in, ikinci koÅŸul (`>70`) hiÃ§ kontrol edilmez. KoÅŸullar ya kesiÅŸmeyecek ÅŸekilde ya da en Ã¶zelden en genele doÄŸru (Ã¶rn: `>90`, `>80`, `>70`...) sÄ±ralanmalÄ±dÄ±r."
},
{
  q: "10. Hangi dÃ¶ngÃ¼ yapÄ±sÄ±, iÃ§indeki kod bloÄŸunun her durumda en az bir kere Ã§alÄ±ÅŸacaÄŸÄ±nÄ± garanti eder?",
  options: [
    ["WHILE", "WHILE dÃ¶ngÃ¼sÃ¼, koÅŸul baÅŸlangÄ±Ã§ta yanlÄ±ÅŸsa hiÃ§ Ã§alÄ±ÅŸmayabilir."],
    ["FOR", "FOR dÃ¶ngÃ¼sÃ¼nÃ¼n baÅŸlangÄ±Ã§ ve bitiÅŸ deÄŸerleri aynÄ±ysa hiÃ§ Ã§alÄ±ÅŸmayabilir (Ã¶rn: FOR i=1 TO 0)."],
    ["UNTIL (veya REPEAT...UNTIL)", "`UNTIL` dÃ¶ngÃ¼lerinde koÅŸul sonda denetlendiÄŸi iÃ§in, program akÄ±ÅŸÄ± dÃ¶ngÃ¼ bloÄŸuna en az bir kez girer, iÅŸlemleri yapar ve sonra koÅŸulu kontrol eder."],
    ["FOREACH", "Bu, bir koleksiyonun elemanlarÄ± Ã¼zerinde gezen Ã¶zel bir `FOR` dÃ¶ngÃ¼sÃ¼dÃ¼r ve koleksiyon boÅŸsa hiÃ§ Ã§alÄ±ÅŸmaz."],
    ["HiÃ§biri, tÃ¼m dÃ¶ngÃ¼ler hiÃ§ Ã§alÄ±ÅŸmama ihtimaline sahiptir.", "Bu ifade yanlÄ±ÅŸtÄ±r, `UNTIL` en az bir kez Ã§alÄ±ÅŸÄ±r."]
  ],
  answer: 2,
  summary: "`UNTIL` dÃ¶ngÃ¼sÃ¼, 'Ã¶nce yap, sonra sor' prensibiyle Ã§alÄ±ÅŸÄ±r. `WHILE` dÃ¶ngÃ¼sÃ¼ ise 'Ã¶nce sor, sonra yap' prensibine dayanÄ±r. Bu nedenle, dÃ¶ngÃ¼deki iÅŸlemlerin en az bir kez yapÄ±lmasÄ± zorunluysa `UNTIL` doÄŸru seÃ§imdir."
},
{
  q: "11. DÃ¶ngÃ¼ler genel olarak hangi iki ana tÃ¼rde sÄ±nÄ±flandÄ±rÄ±lÄ±r?",
  options: [
    ["WHILE ve FOR dÃ¶ngÃ¼leri", "Bunlar spesifik dÃ¶ngÃ¼ tÃ¼rleridir, ana sÄ±nÄ±flandÄ±rma deÄŸildir."],
    ["Basit ve BileÅŸik DÃ¶ngÃ¼ler", "Bu terimler genellikle deyimler iÃ§in kullanÄ±lÄ±r."],
    ["KoÅŸullu ve SeÃ§imli DÃ¶ngÃ¼ler", "SeÃ§imli, dÃ¶ngÃ¼ler iÃ§in bir sÄ±nÄ±flandÄ±rma deÄŸildir."],
    ["Parametreli (SayaÃ§lÄ±) DÃ¶ngÃ¼ler ve KoÅŸullu DÃ¶ngÃ¼ler", "DÃ¶ngÃ¼ler, tekrar sayÄ±sÄ±nÄ±n Ã¶nceden belli olup olmadÄ±ÄŸÄ±na gÃ¶re temel olarak bu iki gruba ayrÄ±lÄ±r. `FOR` sayaÃ§lÄ±ya, `WHILE` ve `UNTIL` ise koÅŸulluya Ã¶rnektir."],
    ["Ä°lkel ve YapÄ±sal DÃ¶ngÃ¼ler", "Bu terimler veri tipleri iÃ§in kullanÄ±lÄ±r."]
  ],
  answer: 3,
  summary: "Bir dÃ¶ngÃ¼ kurarken sorulmasÄ± gereken ilk soru ÅŸudur: 'Bu iÅŸlemi tam olarak kaÃ§ kere yapacaÄŸÄ±mÄ± biliyor muyum?'. Cevap 'evet' ise Parametreli/SayaÃ§lÄ± (`FOR`) dÃ¶ngÃ¼, 'hayÄ±r' ise KoÅŸullu (`WHILE`, `UNTIL`) dÃ¶ngÃ¼ kullanÄ±lÄ±r."
},
{
  q: "12. Bir `notlar` dizisindeki tÃ¼m Ã¶ÄŸrencilerin notlarÄ±nÄ± iÅŸlemek iÃ§in dÃ¶ngÃ¼ kurulduÄŸunda, `Harf`, `KatsayÄ±` gibi sonuÃ§ deÄŸiÅŸkenlerinin de birer dizi (`Harfler[SayaÃ§]`, `KatsayÄ±lar[SayaÃ§]`) olarak tanÄ±mlanmasÄ±nÄ±n sebebi nedir?",
  options: [
    ["ProgramÄ±n daha yavaÅŸ Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak iÃ§in", "Bu bir sebep deÄŸildir."],
    ["DÃ¶ngÃ¼nÃ¼n her adÄ±mÄ±nda bir Ã¶nceki Ã¶ÄŸrencinin hesaplanan sonucunun kaybolmasÄ±nÄ± Ã¶nlemek iÃ§in", "EÄŸer sonuÃ§lar normal deÄŸiÅŸkenlere atansaydÄ±, dÃ¶ngÃ¼nÃ¼n her yeni adÄ±mÄ±nda bu deÄŸiÅŸkenlerin Ã¼zerine yeni deÄŸer yazÄ±lÄ±r ve eski deÄŸer kaybolurdu. DÃ¶ngÃ¼ bittiÄŸinde sadece son Ã¶ÄŸrencinin bilgileri kalÄ±rdÄ±. SonuÃ§larÄ± da bir diziye atayarak her Ã¶ÄŸrencinin bilgisi kendi indisinde saklanmÄ±ÅŸ olur."],
    ["Bellekte daha fazla yer kaplamak iÃ§in", "Bu bir amaÃ§ deÄŸil, bir sonuÃ§tur."],
    ["Kodun daha karmaÅŸÄ±k gÃ¶rÃ¼nmesini saÄŸlamak iÃ§in", "Bu bir amaÃ§ deÄŸildir."],
    ["DÃ¶ngÃ¼nÃ¼n sonsuza girmesini engellemek iÃ§in", "Bunun sonsuz dÃ¶ngÃ¼yle bir ilgisi yoktur."]
  ],
  answer: 1,
  summary: "Bir dÃ¶ngÃ¼ iÃ§inde yapÄ±lan hesaplamalarÄ±n sonuÃ§larÄ±nÄ± korumak iÃ§in, bu sonuÃ§larÄ±n da dÃ¶ngÃ¼ sayacÄ±yla indislenmiÅŸ bir diziye kaydedilmesi gerekir. Aksi takdirde, dÃ¶ngÃ¼ her dÃ¶ndÃ¼ÄŸÃ¼nde, bir Ã¶nceki adÄ±mda elde edilen deÄŸerli bilgiler ezilerek kaybolur."
},
{
  q: "13. KoÅŸullu ifadeler, program akÄ±ÅŸÄ±nÄ± bir mantÄ±ksal ifadenin hangi deÄŸerine baÄŸlÄ± olarak denetimli bir biÃ§imde deÄŸiÅŸtirir?",
  options: [
    ["SayÄ±sal (Integer veya Float) deÄŸere", "SayÄ±sal deÄŸerler koÅŸulun iÃ§inde kullanÄ±labilir ama koÅŸulun sonucu sayÄ±sal deÄŸildir."],
    ["Karakter Dizisi (String) deÄŸere", "Metinler koÅŸulda karÅŸÄ±laÅŸtÄ±rÄ±labilir ama koÅŸulun sonucu metin deÄŸildir."],
    ["DoÄŸru (TRUE) ya da YanlÄ±ÅŸ (FALSE) deÄŸere", "Bir koÅŸullu ifadenin temelindeki mantÄ±ksal ifade her zaman deÄŸerlendirilir ve sonuÃ§ olarak 'doÄŸru' veya 'yanlÄ±ÅŸ' Ã¼retir. ProgramÄ±n akÄ±ÅŸÄ± bu sonuca gÃ¶re yÃ¶nlendirilir."],
    ["NULL (boÅŸ) deÄŸere", "Null kontrolÃ¼ bir koÅŸul olabilir, ancak koÅŸulun sonucu her zaman true/false'tur."],
    ["Dizi (Array) deÄŸere", "Diziler koÅŸul iÃ§inde kullanÄ±labilir ama sonuÃ§ bir dizi deÄŸildir."]
  ],
  answer: 2,
  summary: "KoÅŸullu ifadeler, programÄ±n yol ayrÄ±mlarÄ±dÄ±r. Yol ayrÄ±mÄ±ndaki trafik Ä±ÅŸÄ±ÄŸÄ± ise her zaman 'yeÅŸil' (doÄŸru) veya 'kÄ±rmÄ±zÄ±' (yanlÄ±ÅŸ) yanar. Program bu Ä±ÅŸÄ±ÄŸÄ±n rengine gÃ¶re hangi yola sapacaÄŸÄ±na karar verir."
},
{
  q: "14. `SayÄ± = 11` baÅŸlangÄ±Ã§ deÄŸeri iÃ§in, `DO SayÄ± = SayÄ± / 2 UNTIL (Mod(SayÄ±,2)=1)` dÃ¶ngÃ¼sÃ¼nÃ¼n sonunda 'SayÄ±' deÄŸiÅŸkeninin deÄŸeri ne olur?",
  options: [
    ["11", "DÃ¶ngÃ¼ en az bir kez Ã§alÄ±ÅŸacaÄŸÄ± iÃ§in deÄŸer deÄŸiÅŸir."],
    ["3", "Bu, `WHILE` dÃ¶ngÃ¼sÃ¼ iÃ§in farklÄ± bir senaryonun sonucu olurdu."],
    ["5.5", "KoÅŸul sonda denetlendiÄŸi iÃ§in dÃ¶ngÃ¼ en az bir kez Ã§alÄ±ÅŸÄ±r. `SayÄ± = 11 / 2 = 5.5` olur. Daha sonra `Mod(5.5, 2) = 1` koÅŸulu kontrol edilir (birÃ§ok dilde bu iÅŸlem tamsayÄ± olmayanlar iÃ§in farklÄ± sonuÃ§lar verse de, mantÄ±ksal olarak 1'e eÅŸit olmayacaÄŸÄ± varsayÄ±lÄ±r), ancak sorulan dÃ¶ngÃ¼ sonundaki deÄŸerdir ve o da 5.5'tir."],
    ["12", "Bu hatalÄ± bir sonuÃ§tur."],
    ["Program dÃ¶ngÃ¼ye hiÃ§ girmez.", "`UNTIL` dÃ¶ngÃ¼sÃ¼ her zaman en az bir kez Ã§alÄ±ÅŸÄ±r."]
  ],
  answer: 2,
  summary: "`REPEAT...UNTIL` dÃ¶ngÃ¼sÃ¼nÃ¼n 'en az bir kez Ã§alÄ±ÅŸma' garantisi, `WHILE` dÃ¶ngÃ¼sÃ¼nden en Ã¶nemli farkÄ±dÄ±r. Bu Ã¶rnekte `SayÄ±` deÄŸiÅŸkeni 11 gibi tek bir sayÄ± olsa bile, dÃ¶ngÃ¼ bir kez Ã§alÄ±ÅŸÄ±r, bÃ¶lme iÅŸlemi yapÄ±lÄ±r ve `SayÄ±`'nÄ±n deÄŸeri 5.5 olur."
},
{
  q: "15. Bir koÅŸulun mantÄ±ksal tersini denetlemek iÃ§in genellikle hangi Ã¶n ek kullanÄ±lÄ±r?",
  options: [
    ["AND", "Bu bir baÄŸlaÃ§tÄ±r."],
    ["OR", "Bu bir baÄŸlaÃ§tÄ±r."],
    ["IF", "Bu, koÅŸul yapÄ±sÄ±nÄ± baÅŸlatan bir anahtar kelimedir."],
    ["NOT (veya `!`)", "`NOT` mantÄ±ksal iÅŸlemcisi, bir koÅŸulun sonucunu tersine Ã§evirir. Yani, doÄŸru ise yanlÄ±ÅŸ, yanlÄ±ÅŸ ise doÄŸru yapar. `NOT is_integer(sayi)` ifadesi, 'sayÄ± bir tamsayÄ± DEÄžÄ°LSE' anlamÄ±na gelir."],
    ["THEN", "Bu, `IF`'ten sonra gelen eylemi belirtir."]
  ],
  answer: 3,
  summary: "`NOT` operatÃ¶rÃ¼, mantÄ±ksal bir ifadenin 'deÄŸilini' almak iÃ§in kullanÄ±lÄ±r. Bu, 'eÅŸit deÄŸilse', 'iÃ§ermiyorsa', 'doÄŸru deÄŸilse' gibi durumlarÄ± kontrol etmeyi Ã§ok kolaylaÅŸtÄ±rÄ±r."
},
{
  q: "16. `FOR SayaÃ§=1 TO 10` dÃ¶ngÃ¼sÃ¼ kaÃ§ kez Ã§alÄ±ÅŸÄ±r?",
  options: [
    ["9", "BaÅŸlangÄ±Ã§ deÄŸeri de dahil olduÄŸu iÃ§in yanlÄ±ÅŸ bir sayÄ±m."],
    ["10", "DÃ¶ngÃ¼ 1'den baÅŸlayÄ±p 10'a kadar (10 dahil) tÃ¼m deÄŸerleri alacaÄŸÄ± iÃ§in toplam 10 kez tekrarlanÄ±r."],
    ["11", "BaÅŸlangÄ±Ã§ deÄŸeri 0 olsaydÄ± ve 10'a kadar gitseydi 11 kez Ã§alÄ±ÅŸÄ±rdÄ±."],
    ["1", "Bu sadece ilk adÄ±mdÄ±r."],
    ["0", "DÃ¶ngÃ¼ en az bir kez Ã§alÄ±ÅŸÄ±r."]
  ],
  answer: 1,
  summary: "Bir `FOR` dÃ¶ngÃ¼sÃ¼nÃ¼n tekrar sayÄ±sÄ±nÄ± bulmak iÃ§in `(BitiÅŸ - BaÅŸlangÄ±Ã§) + 1` formÃ¼lÃ¼ kullanÄ±lÄ±r. Bu durumda `(10 - 1) + 1 = 10`'dur."
},
{
  q: "17. Collatz Problemi Ã¶rneÄŸinde, bir sayÄ±nÄ±n 1'e ulaÅŸÄ±p ulaÅŸmayacaÄŸÄ±nÄ±n kaÃ§ adÄ±mda gerÃ§ekleÅŸeceÄŸi Ã¶nceden bilinemediÄŸi iÃ§in ne tÃ¼r bir dÃ¶ngÃ¼ kullanÄ±lmasÄ± zorunludur?",
  options: [
    ["Parametreli (SayaÃ§lÄ±) DÃ¶ngÃ¼", "Tekrar sayÄ±sÄ± belli olmadÄ±ÄŸÄ± iÃ§in `FOR` gibi bir sayaÃ§lÄ± dÃ¶ngÃ¼ kullanÄ±lamaz."],
    ["KoÅŸullu DÃ¶ngÃ¼", "DÃ¶ngÃ¼nÃ¼n sonlanma kuralÄ± bir sayaca deÄŸil, 'hesaplanan sayÄ± 1'e eÅŸit mi?' gibi bir mantÄ±ksal koÅŸula baÄŸlÄ± olduÄŸu iÃ§in `WHILE` veya `UNTIL` gibi bir koÅŸullu dÃ¶ngÃ¼ kullanÄ±lmalÄ±dÄ±r."],
    ["Sonsuz DÃ¶ngÃ¼", "ProgramÄ±n bir noktada sonlanmasÄ± hedeflenir."],
    ["Ä°Ã§ Ä°Ã§e DÃ¶ngÃ¼", "Ä°Ã§ iÃ§e dÃ¶ngÃ¼ bir gereklilik deÄŸildir."],
    ["SeÃ§imli Deyim", "SeÃ§imli deyimler dÃ¶ngÃ¼ deÄŸildir."]
  ],
  answer: 1,
  summary: "Collatz Problemi, tekrar sayÄ±sÄ±nÄ±n baÅŸlangÄ±Ã§ deÄŸerine gÃ¶re tamamen deÄŸiÅŸtiÄŸi, bu nedenle sonucun ne zaman elde edileceÄŸinin bilinemediÄŸi durumlara mÃ¼kemmel bir Ã¶rnektir. Bu gibi senaryolarda, programcÄ± bir sonlanma 'koÅŸulu' belirler ve bu koÅŸul saÄŸlanana kadar devam eden bir koÅŸullu dÃ¶ngÃ¼ kurar."
},
{
  q: "18. AkÄ±ÅŸ diyagramlarÄ±nda koÅŸullu ifadeler hangi geometrik ÅŸekil ile gÃ¶sterilir?",
  options: [
    ["DikdÃ¶rtgen", "DikdÃ¶rtgen, genellikle yapÄ±lacak bir iÅŸlemi veya bir eylemi temsil eder."],
    ["Paralelkenar", "Paralelkenar, genellikle veri giriÅŸi veya Ã§Ä±kÄ±ÅŸÄ±nÄ± temsil eder."],
    ["Elips veya Oval", "Elips, genellikle sÃ¼recin baÅŸlangÄ±cÄ±nÄ± veya sonunu temsil eder."],
    ["EÅŸkenar DÃ¶rtgen", "EÅŸkenar dÃ¶rtgen, bir karar noktasÄ±nÄ± veya bir koÅŸulu temsil eder. Ä°Ã§inden genellikle 'DoÄŸru (T)' ve 'YanlÄ±ÅŸ (F)' olmak Ã¼zere iki farklÄ± akÄ±ÅŸ yolu Ã§Ä±kar."],
    ["Daire", "Daire, genellikle akÄ±ÅŸlarÄ± birleÅŸtiren bir baÄŸlantÄ± noktasÄ± olarak kullanÄ±lÄ±r."]
  ],
  answer: 3,
  summary: "AkÄ±ÅŸ diyagramlarÄ±, bir programÄ±n mantÄ±ksal akÄ±ÅŸÄ±nÄ± gÃ¶rselleÅŸtirmek iÃ§in standart ÅŸekiller kullanÄ±r. EÅŸkenar dÃ¶rtgen, programÄ±n bir 'yol ayrÄ±mÄ±na' geldiÄŸini ve bir koÅŸula gÃ¶re hangi yÃ¶ne gideceÄŸine karar vermesi gerektiÄŸini simgeler."
},
{
  q: "19. KoÅŸullu ifadeler iÃ§in 'AkÄ±ÅŸ Kontrol Deyimleri' denmesinin sebebi nedir?",
  options: [
    ["Programdaki tÃ¼m verileri kontrol ettikleri iÃ§in", "TÃ¼m verileri deÄŸil, belirli bir koÅŸulu kontrol ederler."],
    ["ProgramÄ±n normalde doÄŸrusal olan akÄ±ÅŸÄ±nÄ±, bir koÅŸula baÄŸlÄ± olarak denetimli bir biÃ§imde deÄŸiÅŸtirdikleri iÃ§in", "Normalde bir program yukarÄ±dan aÅŸaÄŸÄ±ya doÄŸru akar. KoÅŸullu ifadeler bu akÄ±ÅŸÄ± kesintiye uÄŸratarak, koÅŸulun sonucuna gÃ¶re akÄ±ÅŸÄ±n farklÄ± bir kod bloÄŸuna 'atlamasÄ±nÄ±' veya bazÄ± bloklarÄ± 'es geÃ§mesini' saÄŸlar."],
    ["Sadece dÃ¶ngÃ¼lerin akÄ±ÅŸÄ±nÄ± kontrol edebildikleri iÃ§in", "DÃ¶ngÃ¼ler de birer akÄ±ÅŸ kontrol deyimidir ama koÅŸullu ifadeler genel program akÄ±ÅŸÄ±nÄ± kontrol eder."],
    ["ProgramÄ±n baÅŸlangÄ±Ã§ ve bitiÅŸini kontrol ettikleri iÃ§in", "Bunu yapmazlar."],
    ["ProgramÄ±n ne kadar hÄ±zlÄ± aktÄ±ÄŸÄ±nÄ± kontrol ettikleri iÃ§in", "HÄ±zla deÄŸil, yÃ¶nle ilgilenirler."]
  ],
  answer: 1,
  summary: "AkÄ±ÅŸ kontrol deyimleri, bir programÄ±n 'yol haritasÄ±nÄ±' Ã§izen yapÄ±lardÄ±r. ProgramÄ±n hangi koÅŸulda hangi yola sapacaÄŸÄ±nÄ±, hangi yolu tekrarlayacaÄŸÄ±nÄ± bu deyimler belirler."
},
{
  q: "20. `IF...THEN...ELSE` yapÄ±sÄ± hangi tip koÅŸullu ifadedir?",
  options: [
    ["Tip 1", "Tip 1, sadece `IF...THEN` iÃ§erir."],
    ["Tip 2", "Tip 2, bir koÅŸulun hem doÄŸru (THEN) hem de yanlÄ±ÅŸ (ELSE) olmasÄ± durumlarÄ± iÃ§in ayrÄ± yollar tanÄ±mlayan yapÄ±dÄ±r."],
    ["Tip 3", "Tip 3, `IF...ELSEIF...ELSE` ÅŸeklinde zincirleme koÅŸullar iÃ§erir."],
    ["Tip 4", "Tip 4 diye bir sÄ±nÄ±flandÄ±rma belirtilmemiÅŸtir."],
    ["KoÅŸulsuz Ä°fade", "Bu yapÄ± tamamen koÅŸula baÄŸlÄ±dÄ±r."]
  ],
  answer: 1,
  summary: "KoÅŸullu ifadelerin tipleri, sunduklarÄ± dallanma sayÄ±sÄ±na gÃ¶re artar. Tip 1 tek bir dal sunarken (sadece doÄŸruysa), Tip 2 iki dal (doÄŸruysa veya yanlÄ±ÅŸsa) sunar."
},
{
  q: "21. Prolog ve Lisp gibi mantÄ±ksal programlama dillerinde neden `IF...THEN` gibi Ã¶zel bir koÅŸul sÃ¶zcÃ¼ÄŸÃ¼ bulunmaz?",
  options: [
    ["Bu diller Ã§ok eski olduÄŸu iÃ§in", "Bu dillerin yapÄ±sÄ±yla ilgilidir, yaÅŸlarÄ±yla deÄŸil."],
    ["Bu dillerin tÃ¼mÃ¼yle mantÄ±ksal karÅŸÄ±laÅŸtÄ±rmalar Ã¼zerine kurulu olmasÄ± nedeniyle", "Imperative dillerde program akÄ±ÅŸÄ± doÄŸrusaldÄ±r ve `IF` bu akÄ±ÅŸÄ± kÄ±rmak iÃ§in gerekir. Prolog gibi dillerde ise programÄ±n kendisi bir dizi mantÄ±ksal kural ve sorgudan oluÅŸur, bu nedenle akÄ±ÅŸÄ± kÄ±rmak iÃ§in ek bir `IF` yapÄ±sÄ±na ihtiyaÃ§ duyulmaz."],
    ["Bu dillerde koÅŸul kontrolÃ¼ yapÄ±lamadÄ±ÄŸÄ± iÃ§in", "Tam tersine, bu dillerin temeli koÅŸul kontrolÃ¼dÃ¼r."],
    ["Bu dillerin sadece sayÄ±sal hesaplama yapmasÄ± nedeniyle", "Bu diller Ã¶zellikle sembolik ve mantÄ±ksal hesaplamalarda gÃ¼Ã§lÃ¼dÃ¼r."],
    ["SÃ¶zdizimlerinin Ã§ok karmaÅŸÄ±k olmasÄ± nedeniyle", "Bu bir neden deÄŸildir."]
  ],
  answer: 1,
  summary: "BazÄ± programlama paradigmalarÄ±, 'karar verme' eylemini dilin temel bir parÃ§asÄ± olarak gÃ¶rÃ¼r. Prolog'da her ÅŸey zaten bir kuralÄ±n doÄŸruluÄŸunu sorgulamak Ã¼zerine kurulu olduÄŸu iÃ§in, `IF` gibi bir komuta gerek kalmaz."
},
{
  q: "22. MaaÅŸ hesaplama Ã¶rneÄŸinde, Ã§ocuk yardÄ±mÄ±, dil tazminatÄ± gibi farklÄ± hesaplamalarÄ±n her birini ayrÄ± bir alt program (fonksiyon) olarak tasarlamanÄ±n temel faydasÄ± nedir?",
  options: [
    ["ProgramÄ±n daha uzun sÃ¼rmesini saÄŸlamak", "Bu bir fayda deÄŸildir."],
    ["Ana problemi (maaÅŸ hesabÄ±), Ã§Ã¶zÃ¼mÃ¼ daha kolay alt problemlere bÃ¶lmek", "Bu, 'bÃ¶l ve yÃ¶net' yaklaÅŸÄ±mÄ±dÄ±r. Her bir eklentiyi kendi iÃ§inde bir problem olarak ele alÄ±p Ã§Ã¶zen kÃ¼Ã§Ã¼k fonksiyonlar yazmak, devasa bir maaÅŸ hesaplama kodu yazmaktan daha kolay ve yÃ¶netilebilirdir."],
    ["TÃ¼m hesaplamalarÄ± tek bir deÄŸiÅŸkende toplamak", "Bu bir fayda deÄŸildir."],
    ["ProgramÄ±n sadece tek bir kiÅŸi iÃ§in Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak", "Tam tersine, bu yapÄ± programÄ± daha genel ve esnek hale getirir."],
    ["TÃ¼m kodun tek bir dosyada olmasÄ±nÄ± zorunlu kÄ±lmak", "Alt programlar kodun daha modÃ¼ler ve farklÄ± dosyalara bÃ¶lÃ¼nebilir olmasÄ±nÄ± saÄŸlar."]
  ],
  answer: 1,
  summary: "Alt program kullanmak, bir evi inÅŸa ederken duvarlarÄ±, Ã§atÄ±yÄ± ve pencereleri ayrÄ± ayrÄ± ustalarÄ±n yapmasÄ±na benzer. Herkes kendi uzmanlÄ±k alanÄ±na odaklanÄ±r ve sonunda parÃ§alar birleÅŸtirilerek ana yapÄ± (program) tamamlanÄ±r. Bu yaklaÅŸÄ±m hem daha hÄ±zlÄ± hem de daha az hatalÄ±dÄ±r."
},
{
  q: "23. Bir `notHesapla(puan)` fonksiyonunun, gelen puana gÃ¶re birden fazla sonucu (harf, katsayÄ±, ects) `RETURN` ifadesiyle tek seferde geri dÃ¶ndÃ¼rebilmesi iÃ§in, kullanÄ±lan programlama dilinin hangi Ã¶zelliÄŸi desteklemesi gerekir?",
  options: [
    ["KoÅŸullu dÃ¶ngÃ¼leri desteklemesi", "Bu durumla ilgisi yoktur."],
    ["Parametreli dÃ¶ngÃ¼leri desteklemesi", "Bu durumla ilgisi yoktur."],
    ["YÃ¼ksek iÅŸlemci Ã¶nceliÄŸini desteklemesi", "Bu durumla ilgisi yoktur."],
    ["Liste (List) gibi dÃ¼ÅŸÃ¼k dÃ¼zeyli veri tÃ¼rlerini desteklemesi", "Bir fonksiyon normalde sadece tek bir deÄŸer dÃ¶ndÃ¼rÃ¼r. Ancak dil, birden Ã§ok deÄŸeri tek bir paket (liste, dizi, nesne vb.) iÃ§inde toplayÄ±p bu paketi tek bir sonuÃ§ gibi dÃ¶ndÃ¼rmeye izin veriyorsa, birden fazla sonuÃ§ dÃ¶ndÃ¼rÃ¼lebilir."],
    ["HiÃ§bir Ã¶zellik gerekmez, tÃ¼m diller bunu yapabilir.", "HayÄ±r, bu Ã¶zellik her dilde bu kadar kolay olmayabilir."]
  ],
  answer: 3,
  summary: "FonksiyonlarÄ±n genellikle tek bir 'cevap' vermesi beklenir. Birden Ã§ok cevabÄ± aynÄ± anda vermek iÃ§in, bu cevaplarÄ± bir 'zarfa' veya 'kutuyu' (liste, dizi gibi bir veri yapÄ±sÄ±) koyup tek bir paket olarak gÃ¶ndermek gerekir. Bu, dilin bu tÃ¼r veri yapÄ±larÄ±nÄ± esnek bir ÅŸekilde desteklemesini gerektirir."
},
{
  q: "24. `WHILE (Mod(SayÄ±,2)=0)` dÃ¶ngÃ¼sÃ¼ ile `UNTIL (Mod(SayÄ±,2)=1)` dÃ¶ngÃ¼sÃ¼nÃ¼n aynÄ± iÅŸi yapmasÄ± neyi gÃ¶sterir?",
  options: [
    ["Ä°ki dÃ¶ngÃ¼nÃ¼n de her zaman aynÄ± sayÄ±da Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±", "HayÄ±r, baÅŸlangÄ±Ã§ deÄŸerine gÃ¶re Ã§alÄ±ÅŸma sayÄ±larÄ± farklÄ± olabilir."],
    ["`=` ve `!=` operatÃ¶rlerinin aynÄ± anlama geldiÄŸini", "Burada `Mod(SayÄ±,2)=0` ile `Mod(SayÄ±,2)=1` farklÄ± mantÄ±ksal ifadelerdir."],
    ["`WHILE`'dan `UNTIL`'e geÃ§erken dÃ¶ngÃ¼nÃ¼n sonlanma koÅŸulunun mantÄ±ksal olarak deÄŸillenmesi (tersine Ã§evrilmesi) gerektiÄŸini", "`WHILE` 'koÅŸul doÄŸru iken devam et' der. `UNTIL` ise 'koÅŸul doÄŸru olana kadar devam et' der. AynÄ± iÅŸlevi elde etmek iÃ§in, birinin devam etme koÅŸulunun, diÄŸerinin durma koÅŸulu olmasÄ± gerekir. Yani `(koÅŸul)` ile `NOT (koÅŸul)` mantÄ±ÄŸÄ± geÃ§erlidir."],
    ["`UNTIL` dÃ¶ngÃ¼sÃ¼nÃ¼n daha verimli olduÄŸunu", "Verimlilikleri duruma gÃ¶re deÄŸiÅŸir, bu Ã¶rnek bunu gÃ¶stermez."],
    ["`WHILE` dÃ¶ngÃ¼sÃ¼nÃ¼n daha gÃ¼venilir olduÄŸunu", "GÃ¼venilirlikleri duruma gÃ¶re deÄŸiÅŸir, bu Ã¶rnek bunu gÃ¶stermez."]
  ],
  answer: 2,
  summary: "`WHILE` dÃ¶ngÃ¼sÃ¼nÃ¼n koÅŸulu 'devam etme' koÅŸuludur. `UNTIL` dÃ¶ngÃ¼sÃ¼nÃ¼n koÅŸulu ise 'durma' koÅŸuludur. Bu nedenle, aynÄ± mantÄ±ÄŸÄ± bu iki farklÄ± dÃ¶ngÃ¼yle kurmak istediÄŸinizde, koÅŸul ifadesini birinden diÄŸerine geÃ§erken mantÄ±ksal olarak tersine Ã§evirmeniz gerekir."
},
{
  q: "25. `IF (Puan>=90) THEN ... ELSEIF (Puan>=80) THEN ...` ÅŸeklindeki not hesaplama yapÄ±sÄ±nÄ±n mantÄ±ksal olarak doÄŸru Ã§alÄ±ÅŸmasÄ±nÄ±n sebebi nedir?",
  options: [
    ["KoÅŸullarÄ±n en dÃ¼ÅŸÃ¼kten en yÃ¼kseÄŸe doÄŸru sÄ±ralanmasÄ±", "EÄŸer bÃ¶yle sÄ±ralansaydÄ±, 95 alan bir Ã¶ÄŸrenci `Puan>=80` koÅŸulunu da saÄŸlayacaÄŸÄ± iÃ§in mantÄ±k hatasÄ± olurdu."],
    ["KoÅŸullarÄ±n en yÃ¼ksekten en dÃ¼ÅŸÃ¼ÄŸe doÄŸru sÄ±ralanmasÄ±", "`ELSEIF` yapÄ±sÄ±, bir Ã¶nceki koÅŸul yanlÄ±ÅŸsa devreye girer. Puan 95 ise ilk `IF` Ã§alÄ±ÅŸÄ±r ve diÄŸerleri kontrol edilmez. Puan 85 ise ilk `IF` yanlÄ±ÅŸ olur, ikinci `ELSEIF (Puan>=80)` doÄŸru olur ve Ã§alÄ±ÅŸÄ±r. Bu sÄ±ralama, her puanÄ±n sadece kendi doÄŸru aralÄ±ÄŸÄ±na girmesini saÄŸlar."],
    ["TÃ¼m `ELSEIF`'lerin aynÄ± anda Ã§alÄ±ÅŸmasÄ±", "`ELSEIF` zincirinde sadece bir blok Ã§alÄ±ÅŸÄ±r."],
    ["Her koÅŸulun bir Ã¶ncekinden baÄŸÄ±msÄ±z olmasÄ±", "Tam tersine, her `ELSEIF` bir Ã¶ncekinin yanlÄ±ÅŸ olmasÄ±na baÄŸÄ±mlÄ±dÄ±r."],
    ["`=` operatÃ¶rÃ¼nÃ¼n her koÅŸulda kullanÄ±lmasÄ±", "KoÅŸullar `>=` operatÃ¶rÃ¼nÃ¼ kullanÄ±yor."]
  ],
  answer: 1,
  summary: "Bu tÃ¼r zincirleme `IF` yapÄ±larÄ±nda sÄ±ralama hayati Ã¶nem taÅŸÄ±r. En Ã¶zel veya dar koÅŸuldan (en yÃ¼ksek puan) baÅŸlayÄ±p en genel koÅŸula (en dÃ¼ÅŸÃ¼k puan) doÄŸru gitmek, her durumun yalnÄ±zca bir kez ve doÄŸru koÅŸul tarafÄ±ndan yakalanmasÄ±nÄ± garanti eden en gÃ¼venli yÃ¶ntemdir."
}    
  ];

  const quizDiv = document.getElementById('quiz');
  const optionLabels = ['A)', 'B)', 'C)', 'D)', 'E)'];
  const userAnswers = new Array(questions.length).fill(null);


  questions.forEach((qObj, index) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'question-container';
    questionContainer.id = `question-${index}`;

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = qObj.q;
    questionContainer.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options-group';

    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback';
    feedbackDiv.style.display = 'none'; // Initially hidden

    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'summary';
    summaryDiv.style.display = 'none'; // Initially hidden


    qObj.options.forEach((opt, i) => {
      const optDiv = document.createElement('div');
      optDiv.className = 'option';
      optDiv.textContent = `${optionLabels[i]} ${opt[0]}`;
      optDiv.onclick = () => {
        // Clear previous selection visuals for this question
        const allOptsInGroup = optsDiv.querySelectorAll('.option');
        allOptsInGroup.forEach(el => el.classList.remove('selected'));
        optDiv.classList.add('selected'); // Mark as selected

        userAnswers[index] = i; // Store user's answer

        // Show feedback immediately
        const feedbackText = opt[1] || (i === qObj.answer ? "DoÄŸru cevap!" : "YanlÄ±ÅŸ cevap."); // Fallback feedback
        feedbackDiv.className = 'feedback ' + (i === qObj.answer ? 'correct' : 'incorrect');
        feedbackDiv.style.display = 'block';
        feedbackDiv.textContent = (i === qObj.answer ? 'âœ”ï¸ DoÄŸru: ' : 'âŒ YanlÄ±ÅŸ: ') + feedbackText;


        if (i === qObj.answer && qObj.summary) {
          summaryDiv.style.display = 'block';
          summaryDiv.textContent = 'ðŸ’¡ ' + qObj.summary;
        } else {
          summaryDiv.style.display = 'none';
        }
      };
      optsDiv.appendChild(optDiv);
    });

    questionContainer.appendChild(optsDiv);
    questionContainer.appendChild(feedbackDiv);
    questionContainer.appendChild(summaryDiv);
    quizDiv.appendChild(questionContainer);
  });

  function showResults() {
    let correctCount = 0;
    userAnswers.forEach((answer, index) => {
        if (answer !== null && answer === questions[index].answer) {
            correctCount++;
        }
    });

    const totalQuestions = questions.length;
    const scorePercentage = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(2) : 0;

    document.getElementById('total-questions').textContent = totalQuestions;
    document.getElementById('correct-answers').textContent = correctCount;
    document.getElementById('score-percentage').textContent = scorePercentage;
    document.getElementById('results-summary').style.display = 'block';

    // Scroll to results
    document.getElementById('results-summary').scrollIntoView({ behavior: 'smooth' });
  }

</script>
</body>
</html>