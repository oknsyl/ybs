<!DOCTYPE html>
<html lang="tr">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Programlama Dilleri - 4</title>
  <style>
    body { font-family: 'PT Sans', 'Trebuchet MS', sans-serif; background: #f9f9f9; padding: 20px; color: #333; }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .question-container { background: #fff; padding: 20px; margin-bottom: 25px; border-left: 5px solid #007BFF; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-text { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; }
    .option { padding: 10px; margin: 8px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; transition: background-color 0.2s ease-in-out; }
    .option:hover { background: #e9ecef; }
    .option.selected { background-color: #cce5ff; border-color: #b8daff; }
    .feedback { margin-top: 15px; padding: 12px; border-radius: 4px; display: none; font-weight: bold; }
    .correct { background: #d4edda; border-left: 5px solid #28a745; color: #155724; }
    .incorrect { background: #f8d7da; border-left: 5px solid #dc3545; color: #721c24; }
    .summary { display: none; background: #fff3cd; padding: 12px; margin-top: 10px; border-left: 5px solid #ffc107; border-radius: 4px; color: #856404; }
    button#submit-all {
        display: block;
        margin: 30px auto;
        padding: 12px 25px;
        font-size: 1.1em;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    button#submit-all:hover {
        background-color: #218838;
    }
    .results { margin-top: 30px; padding: 20px; background-color: #e9ecef; border-radius: 5px; text-align: center;}
  </style>
</head>
<body>
<h1>Programlama Dilleri - 4</h1>
<div id="quiz">
  </div>
<button id="submit-all" onclick="showResults()">TÃ¼m Testi Bitir ve SonuÃ§larÄ± GÃ¶r</button>
<div id="results-summary" class="results" style="display:none;">
    <h2>Test Sonucu</h2>
    <p>Toplam Soru: <span id="total-questions"></span></p>
    <p>DoÄŸru Cevap SayÄ±sÄ±: <span id="correct-answers"></span></p>
    <p>BaÅŸarÄ± YÃ¼zdesi: <span id="score-percentage"></span>%</p>
</div>

<script>
  const questions = [
{
  q: "1. Bir programlama dilinde yazÄ±lmÄ±ÅŸ kaynak kodun, hedef makinede Ã§alÄ±ÅŸabilen taÅŸÄ±nabilir bir ara koda Ã§evrilmesi ve bu ara kodun daha sonra bir sanal makine Ã¼zerinde yorumlanmasÄ± iÅŸlemine en iyi Ã¶rnek hangi dildir?",
  options: [
    ["C", "C, genellikle doÄŸrudan makine koduna derlenen bir dildir, ara koda Ã§evrilip yorumlanma modelini standart olarak kullanmaz."],
    ["Assembly", "Assembly, bir Ã§evirici (assembler) ile doÄŸrudan makine diline Ã§evrilen dÃ¼ÅŸÃ¼k seviyeli bir dildir."],
    ["Java", "Java, kaynak kodlarÄ± Ã¶nce platformdan baÄŸÄ±msÄ±z olan 'bytecode' adlÄ± bir ara koda derler, daha sonra bu bytecode her platformdaki Java Sanal Makinesi (JVM) tarafÄ±ndan yorumlanarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r."],
    ["COBOL", "COBOL da C gibi derlenerek kullanÄ±lan bir dildir."],
    ["Pascal", "Pascal da derlenerek kullanÄ±lan klasik bir dildir."]
  ],
  answer: 2,
  summary: "Java'nÄ±n 'bir kere yaz, her yerde Ã§alÄ±ÅŸtÄ±r' felsefesi, derleme ve yorumlamayÄ± birleÅŸtiren bu hibrit modele dayanÄ±r. Kaynak kod, platformdan baÄŸÄ±msÄ±z olan bytecode'a derlenir ve bu bytecode, JVM sayesinde farklÄ± iÅŸletim sistemlerinde Ã§alÄ±ÅŸabilir."
},
{
  q: "2. Derleme ve yorumlama yÃ¶ntemleri 'Zaman EtkinliÄŸi' aÃ§Ä±sÄ±ndan karÅŸÄ±laÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda, hangi yÃ¶ntem neden daha avantajlÄ±dÄ±r?",
  options: [
    ["Yorumlama, Ã§Ã¼nkÃ¼ kaynak kodu analiz etmekle zaman harcamaz.", "YorumlayÄ±cÄ± ilk baÅŸlangÄ±Ã§ta hÄ±zlÄ± olsa da, bir deyimi her Ã§alÄ±ÅŸtÄ±rÄ±ÅŸÄ±nda tekrar tekrar Ã§evirdiÄŸi iÃ§in genel yÃ¼rÃ¼tme sÃ¼resi daha yavaÅŸtÄ±r."],
    ["Derleme, Ã§Ã¼nkÃ¼ programdaki her deyim iÃ§in makine kodu sadece bir defa oluÅŸturulur.", "Derleme iÅŸleminde, tÃ¼m program bir kez makine koduna Ã§evrilir ve bu Ã§evrilmiÅŸ kod defalarca hÄ±zlÄ± bir ÅŸekilde Ã§alÄ±ÅŸtÄ±rÄ±labilir. Bu da genel olarak zamandan bÃ¼yÃ¼k kazanÃ§ saÄŸlar."],
    ["Yorumlama, Ã§Ã¼nkÃ¼ hata ayÄ±klamasÄ± daha kolaydÄ±r.", "Hata ayÄ±klama kolaylÄ±ÄŸÄ± yorumlayÄ±cÄ±nÄ±n bir avantajÄ±dÄ±r, ancak bu zaman etkinliÄŸi (Ã§alÄ±ÅŸma hÄ±zÄ±) ile ilgili deÄŸildir."],
    ["Derleme, Ã§Ã¼nkÃ¼ daha az bellek kullanÄ±r.", "Derleme genellikle daha fazla bellek kullanÄ±r Ã§Ã¼nkÃ¼ kaynak koda ek olarak bir de amaÃ§ program oluÅŸturur."],
    ["Ä°ki yÃ¶ntemin de zaman etkinliÄŸi aÃ§Ä±sÄ±ndan bir farkÄ± yoktur.", "HayÄ±r, Ã§alÄ±ÅŸma hÄ±zÄ± aÃ§Ä±sÄ±ndan aralarÄ±nda belirgin bir fark vardÄ±r ve derleme daha hÄ±zlÄ±dÄ±r."]
  ],
  answer: 1,
  summary: "Derleme, baÅŸlangÄ±Ã§ta (derleme zamanÄ±nda) daha uzun sÃ¼rse de, programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± (Ã§alÄ±ÅŸma zamanÄ±) Ã§ok daha hÄ±zlÄ±dÄ±r Ã§Ã¼nkÃ¼ Ã§eviri iÅŸlemi sadece bir kez yapÄ±lÄ±r. Yorumlama ise her Ã§alÄ±ÅŸtÄ±rmada Ã§eviri yaptÄ±ÄŸÄ± iÃ§in yavaÅŸtÄ±r."
},
{
  q: "3. Bir derleyicinin 'Ã¶n ucu (front-end)' ve 'arka ucu (back-end)' arasÄ±ndaki temel baÄŸÄ±mlÄ±lÄ±k farkÄ± nedir?",
  options: [
    ["Ã–n uÃ§ bilgisayara, arka uÃ§ programlama diline baÄŸÄ±mlÄ±dÄ±r.", "Tam tersi doÄŸrudur."],
    ["Ã–n uÃ§ programlama diline, arka uÃ§ bilgisayara (hedef makineye) baÄŸÄ±mlÄ±dÄ±r.", "Derleyicinin Ã¶n ucu, kaynak dilin kurallarÄ±nÄ± (sÃ¶zdizim, anlam) analiz eder ve dile Ã¶zgÃ¼dÃ¼r. Arka ucu ise bu analizi alÄ±p belirli bir bilgisayar mimarisi iÃ§in makine kodu Ã¼retir ve makineye Ã¶zgÃ¼dÃ¼r."],
    ["Her ikisi de sadece programlama diline baÄŸÄ±mlÄ±dÄ±r.", "HayÄ±r, arka uÃ§ hedef makinenin mimarisine de baÄŸÄ±mlÄ±dÄ±r."],
    ["Her ikisi de sadece bilgisayara baÄŸÄ±mlÄ±dÄ±r.", "HayÄ±r, Ã¶n uÃ§ kaynak programlama diline baÄŸÄ±mlÄ±dÄ±r."],
    ["Ä°kisi arasÄ±nda bir baÄŸÄ±mlÄ±lÄ±k farkÄ± yoktur, ikisi de platformdan baÄŸÄ±msÄ±zdÄ±r.", "HayÄ±r, aralarÄ±nda net bir gÃ¶rev ve baÄŸÄ±mlÄ±lÄ±k ayrÄ±mÄ± vardÄ±r."]
  ],
  answer: 1,
  summary: "Bu ayrÄ±m, derleyici Ã¼retiminde bÃ¼yÃ¼k bir esneklik saÄŸlar. AynÄ± Ã¶n uÃ§, farklÄ± bilgisayarlar iÃ§in yazÄ±lmÄ±ÅŸ farklÄ± arka uÃ§larla birleÅŸtirilerek birden Ã§ok platform iÃ§in derleyici Ã¼retilebilir."
},
{
  q: "4. Java'nÄ±n 'bytecode' ve 'Java Sanal Makinesi (JVM)' yaklaÅŸÄ±mÄ±nÄ±n saÄŸladÄ±ÄŸÄ± en Ã¶nemli iki avantaj aÅŸaÄŸÄ±dakilerden hangisidir?",
  options: [
    ["Daha hÄ±zlÄ± Ã§alÄ±ÅŸma ve daha az bellek kullanÄ±mÄ±", "Bu yaklaÅŸÄ±m genellikle saf derlemeden daha yavaÅŸ Ã§alÄ±ÅŸÄ±r."],
    ["Platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ± ve gÃ¼venlik", "Bytecode, JVM olan her makinede Ã§alÄ±ÅŸabildiÄŸi iÃ§in platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ± saÄŸlar. AyrÄ±ca kodun doÄŸrudan makine Ã¼zerinde deÄŸil, bir sanal makine katmanÄ±nda Ã§alÄ±ÅŸmasÄ± kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±mlara karÅŸÄ± bir koruma (gÃ¼venlik) katmanÄ± oluÅŸturur."],
    ["Kolay hata ayÄ±klama ve hÄ±zlÄ± derleme", "Bu yaklaÅŸÄ±mda hata ayÄ±klama geleneksel yorumlayÄ±cÄ±lar kadar kolay olmayabilir ve bir derleme adÄ±mÄ± iÃ§erir."],
    ["DonanÄ±ma doÄŸrudan eriÅŸim ve eniyileme kolaylÄ±ÄŸÄ±", "Sanal makine, donanÄ±ma doÄŸrudan eriÅŸimi kÄ±sÄ±tlar."],
    ["Daha basit sÃ¶zdizimi ve daha kÃ¼Ã§Ã¼k kod boyutu", "Bu yaklaÅŸÄ±m sÃ¶zdizimini etkilemez ve bytecode genellikle kaynak koddan daha bÃ¼yÃ¼ktÃ¼r."]
  ],
  answer: 1,
  summary: "Java'nÄ±n baÅŸarÄ±sÄ±nÄ±n temelinde yatan iki ilke, yazÄ±lan kodun farklÄ± iÅŸletim sistemlerinde deÄŸiÅŸtirilmeden Ã§alÄ±ÅŸabilmesi (platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ±) ve kodun sanal bir makine iÃ§inde gÃ¼venli bir 'korumalÄ± alan' (sandbox) iÃ§inde Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±dÄ±r."
},
{
  q: "5. Derleme sÃ¼recinde, kaynak programdaki 'puan', 'deger' gibi tanÄ±mlayÄ±cÄ±lar iÃ§in bilgilerin (tÃ¼rÃ¼, adresi vb.) tutulduÄŸu ve sÃ¼reÃ§ boyunca kullanÄ±lan yapÄ±ya ne ad verilir?",
  options: [
    ["AyrÄ±ÅŸtÄ±rma AÄŸacÄ± (Parse Tree)", "AyrÄ±ÅŸtÄ±rma aÄŸacÄ±, programÄ±n hiyerarÅŸik sÃ¶zdizimsel yapÄ±sÄ±nÄ± gÃ¶sterir."],
    ["Token Dizisi", "Token dizisi, metinsel Ã§Ã¶zÃ¼mleme sonucu oluÅŸan ve programÄ±n birimlerini belirten listedir."],
    ["Sembol Tablosu (Symbol Table)", "Derleyici, programdaki her bir deÄŸiÅŸken, fonksiyon gibi tanÄ±mlayÄ±cÄ± iÃ§in bir girdi oluÅŸturarak bu bilgileri sembol tablosunda saklar ve diÄŸer aÅŸamalarda bu tabloya baÅŸvurur."],
    ["YÄ±ÄŸÄ±t (Stack)", "YÄ±ÄŸÄ±t, programÄ±n Ã§alÄ±ÅŸmasÄ± sÄ±rasÄ±nda veri depolamak iÃ§in kullanÄ±lan bir bellek alanÄ±dÄ±r."],
    ["AmaÃ§ Program (Object Program)", "AmaÃ§ program, derleme sÃ¼recinin sonunda Ã¼retilen makine kodudur."]
  ],
  answer: 2,
  summary: "Sembol tablosu, derleyicinin 'hafÄ±zasÄ±' gibidir. Bir deÄŸiÅŸkenle ilk kez karÅŸÄ±laÅŸtÄ±ÄŸÄ±nda onu tabloya yazar ve daha sonra o deÄŸiÅŸkene her rastladÄ±ÄŸÄ±nda Ã¶zelliklerini bu tablodan kontrol eder."
},
{
  q: "6. Bir derleyicinin 'eniyileme (optimization)' aÅŸamasÄ±nÄ±n temel amacÄ± nedir?",
  options: [
    ["Programdaki sÃ¶zdizimsel hatalarÄ± bulmak", "Bu, sÃ¶zdizim Ã§Ã¶zÃ¼mleme aÅŸamasÄ±nÄ±n gÃ¶revidir."],
    ["ProgramÄ± daha okunabilir hale getirmek", "Okunabilirlik insan iÃ§indir, eniyileme makinenin performansÄ± iÃ§indir."],
    ["ProgramÄ±n daha etkin (hÄ±zlÄ± veya daha az kaynak kullanan) Ã§alÄ±ÅŸacak bir eÅŸdeÄŸer programa dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi", "Eniyileme, programÄ±n yaptÄ±ÄŸÄ± iÅŸi deÄŸiÅŸtirmeden, o iÅŸi daha hÄ±zlÄ± veya daha verimli yapmasÄ±nÄ± saÄŸlayan tekniklerin uygulanmasÄ±dÄ±r."],
    ["ProgramÄ± platformdan baÄŸÄ±msÄ±z bir ara koda Ã§evirmek", "Bu, ara kod oluÅŸturma aÅŸamasÄ±nÄ±n bir amacÄ± olabilir, eniyilemenin deÄŸil."],
    ["ProgramÄ±n kullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼ iyileÅŸtirmek", "Bu, yazÄ±lÄ±m tasarÄ±mÄ± ile ilgili bir konudur, derleyici aÅŸamasÄ±yla deÄŸil."]
  ],
  answer: 2,
  summary: "Eniyileme, bir programÄ±n mantÄ±ÄŸÄ±nÄ± koruyarak performansÄ±nÄ± artÄ±rma sanatÄ±dÄ±r. Ã–rneÄŸin, gereksiz hesaplamalarÄ± ortadan kaldÄ±rmak veya daha hÄ±zlÄ± komutlarÄ± tercih etmek gibi iÅŸlemlerle kod daha verimli hale getirilir."
},
{
  q: "7. AÅŸaÄŸÄ±dakilerden hangisi 'makine baÄŸÄ±mlÄ± eniyileme'ye bir Ã¶rnektir?",
  options: [
    ["DeÄŸerleri bilinen ifadelerin derleme zamanÄ±nda hesaplanmasÄ±", "Bu, hedef makinenin Ã¶zelliklerine baÄŸlÄ± olmayan bir makine baÄŸÄ±msÄ±z eniyilemedir."],
    ["AynÄ± hesaplamalarÄ±n program iÃ§inde yinelenmesinin Ã¶nlenmesi", "Bu da makine baÄŸÄ±msÄ±z bir eniyilemedir."],
    ["Bir sayÄ±yÄ± 2 ile Ã§arpma iÅŸlemini, bir kaydÄ±rma (shift) iÅŸlemi ile deÄŸiÅŸtirmek", "KaydÄ±rma (shift) gibi iÅŸlemler, doÄŸrudan merkezi iÅŸlem biriminin (CPU) komut setine Ã¶zgÃ¼dÃ¼r ve bu tÃ¼r bir deÄŸiÅŸiklik hedef makinenin Ã¶zelliklerini kullanÄ±r. Bu nedenle makine baÄŸÄ±mlÄ± bir eniyilemedir."],
    ["KullanÄ±lmayan kod parÃ§alarÄ±nÄ±n programdan Ã§Ä±karÄ±lmasÄ±", "Bu da makine baÄŸÄ±msÄ±z bir eniyilemedir."],
    ["Bir dÃ¶ngÃ¼nÃ¼n yapÄ±sÄ±nÄ± daha verimli hale getirmek", "Bu genellikle makine baÄŸÄ±msÄ±z bir mantÄ±ksal eniyilemedir."]
  ],
  answer: 2,
  summary: "Makine baÄŸÄ±mlÄ± eniyileme, hedef iÅŸlemcinin 'hilelerini' bilmek gibidir. Ã–rneÄŸin, birÃ§ok iÅŸlemcide bir sayÄ±yÄ± sola kaydÄ±rmak (shift), onu 2 ile Ã§arpmaktan Ã§ok daha hÄ±zlÄ±dÄ±r. Derleyicinin bu bilgiyi kullanarak kodu deÄŸiÅŸtirmesi makine baÄŸÄ±mlÄ± eniyilemedir."
},
{
  q: "8. 'SÄ±radaki deyimi al, yapÄ±lacak iÅŸlemleri belirle, iÅŸlemleri gerÃ§ekleÅŸtir' adÄ±mlarÄ±nÄ±n sÃ¼rekli yinelenmesi, hangi dil Ã§eviricisinin Ã§alÄ±ÅŸma ÅŸeklini tanÄ±mlar?",
  options: [
    ["Derleyici (Compiler)", "Derleyici programÄ± bir bÃ¼tÃ¼n olarak ele alÄ±r, adÄ±m adÄ±m deÄŸil."],
    ["YorumlayÄ±cÄ± (Interpreter)", "Bir yorumlayÄ±cÄ±, programÄ± satÄ±r satÄ±r veya deyim deyim okur, her bir deyimi anÄ±nda Ã§evirir ve Ã§alÄ±ÅŸtÄ±rÄ±r. Bu dÃ¶ngÃ¼, yorumlayÄ±cÄ±nÄ±n temel Ã§alÄ±ÅŸma prensibidir."],
    ["BirleÅŸtirici (Assembler)", "Assembler, Assembly kodunu makine koduna Ã§evirir, bu dÃ¶ngÃ¼sel Ã§alÄ±ÅŸma ÅŸekli ona ait deÄŸildir."],
    ["BaÄŸlayÄ±cÄ± (Linker)", "BaÄŸlayÄ±cÄ±, derlenmiÅŸ farklÄ± kod parÃ§alarÄ±nÄ± birleÅŸtirir."],
    ["Ã–n-iÅŸlemci (Preprocessor)", "Ã–n-iÅŸlemci, derlemeden Ã¶nce kaynak kod Ã¼zerinde metinsel deÄŸiÅŸiklikler yapar."]
  ],
  answer: 1,
  summary: "YorumlayÄ±cÄ±, bir ÅŸefin yemek tarifini adÄ±m adÄ±m okuyup her adÄ±mÄ± anÄ±nda yapmasÄ±na benzer. Derleyici ise ÅŸefin Ã¶nce tÃ¼m tarifi okuyup kendi dilinde notlar alÄ±p daha sonra o notlara bakarak yemeÄŸi yapmasÄ±na benzer."
},
{
  q: "9. Derleme sÃ¼recinde, metinsel Ã§Ã¶zÃ¼mleyici (lexical analyzer) tarafÄ±ndan kaynak programÄ±n iÅŸlenmesi sonucunda ne oluÅŸturulur?",
  options: [
    ["AmaÃ§ Program (Object Program)", "Bu, derleme sÃ¼recinin en sonunda oluÅŸur."],
    ["AyrÄ±ÅŸtÄ±rma AÄŸacÄ± (Parse Tree)", "Bu, sÃ¶zdizim Ã§Ã¶zÃ¼mleyici tarafÄ±ndan oluÅŸturulur."],
    ["Bir dizi token", "Metinsel Ã§Ã¶zÃ¼mleyicinin temel gÃ¶revi, karakter dizisinden oluÅŸan kaynak programÄ± okuyup, onu 'tanÄ±mlayÄ±cÄ±', 'sayÄ±', 'operatÃ¶r' gibi anlamlÄ± birimlere, yani token'lara ayÄ±rmaktÄ±r."],
    ["Ara Kod (Intermediate Code)", "Bu, anlam Ã§Ã¶zÃ¼mleme aÅŸamasÄ±nÄ±n sonunda oluÅŸur."],
    ["Sembol Tablosu", "Sembol tablosu bu aÅŸamada oluÅŸturulur ve kullanÄ±lÄ±r, ancak temel Ã§Ä±ktÄ± token dizisidir."]
  ],
  answer: 2,
  summary: "Derlemenin ilk adÄ±mÄ± olan metinsel Ã§Ã¶zÃ¼mleme, bir cÃ¼mlenin kelimelere ayrÄ±lmasÄ±na benzer. Kaynak kod, 'puan', '=', '10', ';' gibi en kÃ¼Ã§Ã¼k anlamlÄ± birimler olan token'lara bÃ¶lÃ¼nÃ¼r."
},
{
  q: "10. Hata bildirme yÃ¶ntemleri aÃ§Ä±sÄ±ndan yorumlayÄ±cÄ±larÄ±n derleyicilere gÃ¶re temel Ã¼stÃ¼nlÃ¼ÄŸÃ¼ nedir?",
  options: [
    ["TÃ¼m hatalarÄ± programÄ±n sonunda toplu olarak bildirmesi", "Bu, derleyicilerin Ã§alÄ±ÅŸma ÅŸeklidir ve bir dezavantaj olarak kabul edilir."],
    ["HiÃ§ hata bildirmemesi, programÄ±n Ã§Ã¶kmesine izin vermesi", "Bu istenen bir durum deÄŸildir."],
    ["HatalarÄ± programcÄ± yerine otomatik olarak dÃ¼zeltmesi", "Bu, gÃ¼nÃ¼mÃ¼zdeki Ã§eviricilerin genel bir yeteneÄŸi deÄŸildir."],
    ["Ä°lk hatayÄ± gÃ¶rdÃ¼ÄŸÃ¼ yerde durmasÄ± ve hatayÄ± doÄŸrudan bildirmesi", "YorumlayÄ±cÄ±lar her komutu birer birer ele aldÄ±ÄŸÄ± iÃ§in, bir hatayla karÅŸÄ±laÅŸtÄ±klarÄ± anda Ã§alÄ±ÅŸmayÄ± durdurur ve hatanÄ±n tam olarak nerede olduÄŸunu bildirirler. Bu da hata ayÄ±klamayÄ± (debugging) kolaylaÅŸtÄ±rÄ±r."],
    ["Sadece sÃ¶zdizimsel hatalarÄ± bildirmesi, anlamsal hatalarÄ± gÃ¶z ardÄ± etmesi", "Hem derleyiciler hem de yorumlayÄ±cÄ±lar her iki tÃ¼r hatayÄ± da bildirmeye Ã§alÄ±ÅŸÄ±r."]
  ],
  answer: 3,
  summary: "Bir yorumlayÄ±cÄ± kullandÄ±ÄŸÄ±nÄ±zda, programÄ±nÄ±z Ã§alÄ±ÅŸmaya baÅŸlar ve ilk hatanÄ±n olduÄŸu satÄ±ra gelince durur. Bu, sorunun kaynaÄŸÄ±nÄ± bulmayÄ± Ã§ok kolaylaÅŸtÄ±rÄ±r. Derleyici ise Ã¶nce tÃ¼m programÄ± kontrol eder ve size bir hata listesi sunar, bu da kaynaÄŸÄ± bulmayÄ± zorlaÅŸtÄ±rabilir."
},
{
  q: "11. Derleme sÃ¼recinin sonunda oluÅŸan makine dilindeki programa ne ad verilir?",
  options: [
    ["Kaynak (Source) Program", "Kaynak program, derleyiciye verilen yÃ¼ksek dÃ¼zeyli dilde yazÄ±lmÄ±ÅŸ programdÄ±r."],
    ["Ara (Intermediate) Program", "Ara program, derleyicinin Ã¶n ucu tarafÄ±ndan oluÅŸturulan ve arka uca verilen programdÄ±r."],
    ["TaÅŸÄ±nabilir (Portable) Kod", "TaÅŸÄ±nabilir kod, genellikle sanal bir makine iÃ§in Ã¼retilen ara koddur."],
    ["AmaÃ§ (Object) Program", "Derleme sÃ¼recinin sonucunda oluÅŸan makine dilindeki programa amaÃ§ (object) program adÄ± verilir."],
    ["YorumlanmÄ±ÅŸ (Interpreted) Program", "Bu terim, yorumlanan diller iÃ§in kullanÄ±lÄ±r; derleme sonucu oluÅŸan bir Ã§Ä±ktÄ± deÄŸildir."]
  ],
  answer: 3,
  summary: "Derleme sÃ¼reci, bir dilden baÅŸka bir dile Ã§eviri sÃ¼recidir. BaÅŸlangÄ±Ã§taki programa 'kaynak', Ã§eviri sonucu ortaya Ã§Ä±kan ve bilgisayarÄ±n anlayacaÄŸÄ± dildeki programa ise 'amaÃ§' denir."
},
{
  q: "12. Java bytecode'unun sadece Java diline Ã¶zgÃ¼ olmadÄ±ÄŸÄ±, Jython, ML, Lisp gibi baÅŸka dillerin de Java bytecode'una derlenebildiÄŸi bilgisi neyi gÃ¶sterir?",
  options: [
    ["Bu dillerin yakÄ±nda kullanÄ±mdan kalkacaÄŸÄ±nÄ±", "Bu bilgiyle ilgisi olmayan bir yorumdur."],
    ["Java Sanal Makinesi'nin (JVM) Ã§ok dilli bir platform olarak kullanÄ±labileceÄŸini", "Bu durum, JVM'nin sadece Java iÃ§in deÄŸil, Ã¼zerine bytecode Ã¼retebilen herhangi bir dil iÃ§in bir Ã§alÄ±ÅŸma platformu olabileceÄŸini gÃ¶sterir. Bu, JVM'nin gÃ¼cÃ¼nÃ¼ ve esnekliÄŸini ortaya koyar."],
    ["Jython, ML ve Lisp'in Java'dan daha eski diller olduÄŸunu", "Bu bilgi dillerin yaÅŸlarÄ± hakkÄ±nda bir ÅŸey sÃ¶ylemez."],
    ["TÃ¼m programlama dillerinin aslÄ±nda aynÄ± olduÄŸunu", "Bu, dillerin farklÄ±lÄ±klarÄ±nÄ± gÃ¶z ardÄ± eden yanlÄ±ÅŸ bir Ã§Ä±karÄ±mdÄ±r."],
    ["Java'nÄ±n diÄŸer tÃ¼m dillerden daha gÃ¼venli olduÄŸunu", "GÃ¼venlik bir avantaj olsa da, bu spesifik durum JVM'nin Ã§ok dilli bir hedef platform olma yeteneÄŸi ile ilgilidir."]
  ],
  answer: 1,
  summary: "Java Sanal Makinesi (JVM), baÅŸarÄ±lÄ± bir 'hedef platform' tasarÄ±mÄ±dÄ±r. FarklÄ± diller iÃ§in yazÄ±lan derleyiciler, eÄŸer Ã§Ä±ktÄ± olarak standart Java bytecode'u Ã¼retiyorlarsa, bu dillerde yazÄ±lan programlar da JVM'nin platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ± gibi avantajlarÄ±ndan faydalanabilir."
},
{
  q: "13. AyrÄ±ÅŸtÄ±rma aÄŸacÄ± oluÅŸturulurken, amaÃ§ sembolden baÅŸlayÄ±p terminal sembollere doÄŸru ilerleyen tekniÄŸe ne ad verilir?",
  options: [
    ["AÅŸaÄŸÄ±dan YukarÄ±ya (Bottom-up) AyrÄ±ÅŸtÄ±rma", "Bu teknikte, bir dizi token'dan baÅŸlanÄ±r ve amaÃ§ sembole ulaÅŸÄ±lmaya Ã§alÄ±ÅŸÄ±lÄ±r."],
    ["Geri Ä°zleme (Backtracking)", "Geri izleme, tÃ¼retme sÄ±rasÄ±nda bir Ã¶lÃ¼ noktaya gelindiÄŸinde bir Ã¶nceki adÄ±ma dÃ¶nÃ¼p farklÄ± bir kural deneme iÅŸlemidir."],
    ["YukarÄ±dan AÅŸaÄŸÄ±ya (Top-down) AyrÄ±ÅŸtÄ±rma", "Bu teknikte, iÅŸleme en tepedeki amaÃ§ sembolÃ¼yle baÅŸlanÄ±r ve gramer kurallarÄ± kullanÄ±larak, verilen token dizisine ulaÅŸÄ±lana kadar aÄŸaÃ§ aÅŸaÄŸÄ±ya doÄŸru geniÅŸletilir."],
    ["Metinsel Ã‡Ã¶zÃ¼mleme", "Bu, programÄ±n token'lara ayrÄ±ldÄ±ÄŸÄ±, ayrÄ±ÅŸtÄ±rmadan Ã¶nceki aÅŸamadÄ±r."],
    ["Anlam Ã‡Ã¶zÃ¼mleme", "Bu, ayrÄ±ÅŸtÄ±rma aÄŸacÄ± oluÅŸturulduktan sonraki aÅŸamadÄ±r."]
  ],
  answer: 2,
  summary: "YukarÄ±dan aÅŸaÄŸÄ±ya ayrÄ±ÅŸtÄ±rma, 'Bu cÃ¼mlenin bir program olmasÄ±nÄ± bekliyorum, Ã¶yleyse bir programÄ±n iÃ§ermesi gereken parÃ§alarÄ± iÃ§eriyor mu?' diye sorarak bÃ¼tÃ¼nden parÃ§aya doÄŸru ilerleyen bir analiz tekniÄŸidir."
},
{
  q: "14. Derleme sÃ¼recinde eniyilemenin (optimization) bir dezavantajÄ± olarak ne belirtilmiÅŸtir?",
  options: [
    ["ProgramÄ±n daha yavaÅŸ Ã§alÄ±ÅŸmasÄ±na neden olmasÄ±", "Tam tersine, eniyilemenin amacÄ± programÄ± daha hÄ±zlÄ± hale getirmektir."],
    ["AmaÃ§ programÄ±n boyutunu her zaman artÄ±rmasÄ±", "Eniyileme bazen kod boyutunu kÃ¼Ã§Ã¼ltebilir."],
    ["Hata ayÄ±klama (debug) iÅŸlemini gÃ¼Ã§leÅŸtirebilmesi", "Eniyileme, Ã§alÄ±ÅŸtÄ±rÄ±lan deyimlerin sÄ±rasÄ±nÄ± kaynak koddaki sÄ±radan farklÄ±laÅŸtÄ±rabilir. Bu durum, bir hata oluÅŸtuÄŸunda programcÄ±nÄ±n kaynak kodda hangi satÄ±rÄ±n soruna yol aÃ§tÄ±ÄŸÄ±nÄ± takip etmesini zorlaÅŸtÄ±rÄ±r."],
    ["Sadece makine baÄŸÄ±msÄ±z eniyilemenin mÃ¼mkÃ¼n olmasÄ±", "HayÄ±r, hem makine baÄŸÄ±msÄ±z hem de makine baÄŸÄ±mlÄ± eniyileme tÃ¼rleri vardÄ±r."],
    ["Derleme sÃ¼resini her zaman kÄ±saltmasÄ±", "Eniyileme, derleme sÃ¼recine ek bir adÄ±m olduÄŸu iÃ§in derleme sÃ¼resini genellikle uzatÄ±r."]
  ],
  answer: 2,
  summary: "ProgramÄ± eniyileÅŸtirmek, bir ÅŸefin tarifi daha hÄ±zlÄ± yapmak iÃ§in adÄ±mlarÄ±n sÄ±rasÄ±nÄ± deÄŸiÅŸtirmesine benzer. SonuÃ§ta aynÄ± yemek Ã§Ä±ksa da, bir sorun olduÄŸunda orijinal tarifin hangi adÄ±mÄ±nda hata yapÄ±ldÄ±ÄŸÄ±nÄ± bulmak zorlaÅŸÄ±r. Bu nedenle hata ayÄ±klama yapÄ±lÄ±rken eniyileyici genellikle kapatÄ±lÄ±r."
},
{
  q: "15. Derleyicinin hangi bÃ¶lÃ¼mÃ¼, metinsel Ã§Ã¶zÃ¼mleme, sÃ¶zdizim Ã§Ã¶zÃ¼mleme ve anlam Ã§Ã¶zÃ¼mleme aÅŸamalarÄ±nÄ± iÃ§erir?",
  options: [
    ["Arka UÃ§ (Back-end)", "Arka uÃ§, eniyileme ve kod oluÅŸturma aÅŸamalarÄ±nÄ± iÃ§erir."],
    ["Ã–n UÃ§ (Front-end)", "Bir derleyicinin Ã¶n ucu, kaynak programÄ± analiz eden ve bir ara koda dÃ¶nÃ¼ÅŸtÃ¼ren bÃ¶lÃ¼mdÃ¼r. Bu analiz, metinsel, sÃ¶zdizimsel ve anlamsal Ã§Ã¶zÃ¼mleme adÄ±mlarÄ±nÄ± kapsar."],
    ["Sembol Tablosu", "Sembol tablosu, bu aÅŸamalarda kullanÄ±lan bir veri yapÄ±sÄ±dÄ±r, bir bÃ¶lÃ¼m deÄŸildir."],
    ["Eniyileyici (Optimizer)", "Eniyileyici, genellikle arka ucun bir parÃ§asÄ±dÄ±r."],
    ["Kod OluÅŸturucu (Code Generator)", "Kod oluÅŸturucu, arka ucun son parÃ§asÄ±dÄ±r."]
  ],
  answer: 1,
  summary: "Derleme sÃ¼reci iki ana parÃ§aya ayrÄ±labilir. Ã–n uÃ§, kaynak kodu 'anlamakla' gÃ¶revlidir. Arka uÃ§ ise bu 'anlaÅŸÄ±lan' yapÄ±yÄ± alÄ±p hedef makine iÃ§in 'uygulamakla' gÃ¶revlidir."
},
{
  q: "16. Bellek kullanma etkinliÄŸi aÃ§Ä±sÄ±ndan, yorumlayÄ±cÄ±larÄ±n derleyicilere gÃ¶re avantajlÄ± olmasÄ±nÄ±n sebebi nedir?",
  options: [
    ["YorumlayÄ±cÄ±larÄ±n her zaman daha az bellek kullanmasÄ±", "Bu her zaman doÄŸru deÄŸildir; yorumlayÄ±cÄ±nÄ±n kendisi de bellekte yer kaplar."],
    ["YÃ¼ksek dÃ¼zeyli dil deyimlerinin orijinal ÅŸekillerinde kalmasÄ± ve ek bir amaÃ§ program oluÅŸturulmamasÄ±", "Derlemede kaynak programa ek olarak bir de bÃ¼yÃ¼k olabilen bir amaÃ§ program dosyasÄ± oluÅŸturulur. Yorumlamada ise sadece kaynak kod ve yorumlayÄ±cÄ±nÄ±n kendisi bellekte bulunur, bu da genellikle daha az bellek kullanÄ±mÄ± anlamÄ±na gelir."],
    ["Derleyicilerin sembol tablosu kullanmamasÄ±", "Derleyiciler sembol tablosu kullanÄ±r."],
    ["YorumlayÄ±cÄ±larÄ±n eniyileme yapmamasÄ±", "Eniyileme yapmamak bellek kullanÄ±mÄ±nÄ± doÄŸrudan etkileyen ana faktÃ¶r deÄŸildir."],
    ["Derleyicilerin programÄ± satÄ±r satÄ±r iÅŸlemesi", "Bu yorumlayÄ±cÄ±larÄ±n Ã§alÄ±ÅŸma ÅŸeklidir."]
  ],
  answer: 1,
  summary: "Derleme iÅŸlemi, elinizdeki bir kitaptan (kaynak program) yola Ã§Ä±karak tamamen yeni ve genellikle daha kalÄ±n bir kitap (amaÃ§ program) yazmaya benzer. Yorumlama ise sadece orijinal kitabÄ± okuyup anlatmaya benzer. Ä°kinci durumda bellekte sadece bir kitap olur."
},
{
  q: "17. `sonuc = fonksiyon1(a+b) + fonksiyon2(a+b)` ifadesinde `a+b` iÅŸleminin sadece bir kez hesaplanÄ±p sonucunun bir deÄŸiÅŸkende saklanarak her iki fonksiyonda da kullanÄ±lmasÄ±, ne tÃ¼r bir eniyileme Ã¶rneÄŸidir?",
  options: [
    ["Makine baÄŸÄ±mlÄ± eniyileme", "Bu, iÅŸlemcinin komut setine baÄŸlÄ± bir deÄŸiÅŸiklik deÄŸildir."],
    ["SÃ¶zdizimsel eniyileme", "SÃ¶zdizimi deÄŸil, programÄ±n Ã§alÄ±ÅŸma ÅŸekli deÄŸiÅŸmektedir."],
    ["Makine baÄŸÄ±msÄ±z eniyileme", "AynÄ± hesaplamanÄ±n tekrarlanmasÄ±nÄ± Ã¶nlemek, hedef bilgisayarÄ±n Ã¶zelliklerinden baÄŸÄ±msÄ±z olarak uygulanabilecek mantÄ±ksal bir iyileÅŸtirmedir. Bu nedenle makine baÄŸÄ±msÄ±z bir eniyilemedir."],
    ["Hata ayÄ±klama", "Bu bir eniyileme tÃ¼rÃ¼dÃ¼r, hata ayÄ±klama deÄŸil."],
    ["Geri izleme (Backtracking)", "Bu, ayrÄ±ÅŸtÄ±rma sÄ±rasÄ±nda kullanÄ±lan bir tekniktir."]
  ],
  answer: 2,
  summary: "Bu eniyileme tÃ¼rÃ¼ 'ortak alt ifade eliminasyonu' olarak bilinir. Derleyici, aynÄ± ifadenin birden Ã§ok kez hesaplandÄ±ÄŸÄ±nÄ± fark eder ve bunu sadece bir kez yapÄ±p sonucu yeniden kullanarak programÄ± hÄ±zlandÄ±rÄ±r. Bu, genel bir mantÄ±k kuralÄ± olduÄŸu iÃ§in makine baÄŸÄ±msÄ±zdÄ±r."
},
{
  q: "18. SÃ¶zdizim Ã§Ã¶zÃ¼mleyicinin (parser) temel girdileri ve Ã§Ä±ktÄ±sÄ± nedir?",
  options: [
    ["Girdi: Kaynak Program, Ã‡Ä±ktÄ±: AmaÃ§ Program", "Bu, tÃ¼m derleme sÃ¼recinin girdi ve Ã§Ä±ktÄ±sÄ±dÄ±r."],
    ["Girdi: Token Dizisi ve Dilin Grameri, Ã‡Ä±ktÄ±: AyrÄ±ÅŸtÄ±rma AÄŸacÄ±", "SÃ¶zdizim Ã§Ã¶zÃ¼mleyici, metinsel Ã§Ã¶zÃ¼mleyiciden gelen token dizisini alÄ±r, dilin gramer kurallarÄ±nÄ± kullanarak bu dizinin geÃ§erli bir cÃ¼mle olup olmadÄ±ÄŸÄ±nÄ± kontrol eder ve sonuÃ§ olarak cÃ¼mlenin yapÄ±sÄ±nÄ± gÃ¶steren bir ayrÄ±ÅŸtÄ±rma aÄŸacÄ± oluÅŸturur."],
    ["Girdi: AyrÄ±ÅŸtÄ±rma AÄŸacÄ±, Ã‡Ä±ktÄ±: Ara Kod", "Bu, anlam Ã§Ã¶zÃ¼mleyicinin girdi ve Ã§Ä±ktÄ±sÄ±dÄ±r."],
    ["Girdi: Kaynak Program, Ã‡Ä±ktÄ±: Token Dizisi", "Bu, metinsel Ã§Ã¶zÃ¼mleyicinin girdi ve Ã§Ä±ktÄ±sÄ±dÄ±r."],
    ["Girdi: Ara Kod, Ã‡Ä±ktÄ±: Makine Kodu", "Bu, derleyicinin arka ucunun (kod oluÅŸturucu) girdi ve Ã§Ä±ktÄ±sÄ±dÄ±r."]
  ],
  answer: 1,
  summary: "Derleme sÃ¼reci bir fabrika bandÄ± gibidir. Metinsel Ã§Ã¶zÃ¼mleyici, kodu 'token' adÄ± verilen parÃ§alara ayÄ±rÄ±r. SÃ¶zdizim Ã§Ã¶zÃ¼mleyici bu parÃ§alarÄ± alÄ±r, dilin 'montaj talimatlarÄ±nÄ±' (gramer) kullanarak bir 'iskelet' (ayrÄ±ÅŸtÄ±rma aÄŸacÄ±) oluÅŸturur."
},
{
  q: "19. YukarÄ±dan aÅŸaÄŸÄ±ya ayrÄ±ÅŸtÄ±rma tekniÄŸinde, tÃ¼retme sÃ¼recinde yanlÄ±ÅŸ bir kural seÃ§ilmesi nedeniyle 'Ã¶lÃ¼ nokta'ya gelinmesi durumunda Ã§Ã¶zÃ¼mleyicinin yaptÄ±ÄŸÄ± iÅŸleme ne ad verilir?",
  options: [
    ["Eniyileme (Optimization)", "Bu, kodu daha verimli hale getirme iÅŸlemidir."],
    ["Kod oluÅŸturma (Code Generation)", "Bu, makine kodu Ã¼retme iÅŸlemidir."],
    ["Geri izleme (Backtracking)", "Ã‡Ã¶zÃ¼mleyici bir yola girdiÄŸinde bunun token dizisiyle eÅŸleÅŸmediÄŸini anlarsa, en son karar noktasÄ±na geri dÃ¶ner ve daha Ã¶nce kullanmadÄ±ÄŸÄ± alternatif bir kuralÄ± dener. Bu geri dÃ¶nÃ¼p baÅŸka bir yol deneme iÅŸlemine geri izleme denir."],
    ["Yorumlama (Interpretation)", "Bu, farklÄ± bir dil Ã§evrim yÃ¶ntemidir."],
    ["StandartlaÅŸtÄ±rma (Standardization)", "Bu, bir dil iÃ§in resmi kurallar belirleme iÅŸlemidir."]
  ],
  answer: 2,
  summary: "YukarÄ±dan aÅŸaÄŸÄ±ya ayrÄ±ÅŸtÄ±rma bir labirentte yol bulmaya benzer. YanlÄ±ÅŸ bir yola saptÄ±ÄŸÄ±nÄ±zÄ± fark ettiÄŸinizde (Ã¶lÃ¼ nokta), bir Ã¶nceki yol ayrÄ±mÄ±na geri dÃ¶nÃ¼p diÄŸer patikayÄ± denersiniz. Bu iÅŸleme 'geri izleme' denir."
},
{
  q: "20. Derleme sÃ¼recinde 'derleme zamanÄ±' ve 'Ã§alÄ±ÅŸma zamanÄ±' arasÄ±ndaki fark nedir?",
  options: [
    ["Ä°kisi de aynÄ± anlama gelir.", "HayÄ±r, bunlar iki ayrÄ± ve farklÄ± zaman dilimidir."],
    ["Derleme zamanÄ± programÄ±n yazÄ±ldÄ±ÄŸÄ±, Ã§alÄ±ÅŸma zamanÄ± test edildiÄŸi zamandÄ±r.", "Yazma ve test etme bu sÃ¼reÃ§lerin parÃ§asÄ± olabilir ancak temel tanÄ±m bu deÄŸildir."],
    ["Derleme zamanÄ± kaynak kodun makine koduna Ã§evrildiÄŸi, Ã§alÄ±ÅŸma zamanÄ± ise bu makine kodunun Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± zamandÄ±r.", "Derleyicinin kendisinin Ã§alÄ±ÅŸtÄ±ÄŸÄ± ve amaÃ§ programÄ± Ã¼rettiÄŸi sÃ¼re 'derleme zamanÄ±'dÄ±r. Ãœretilen bu amaÃ§ programÄ±n kullanÄ±cÄ± tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± sÃ¼re ise 'Ã§alÄ±ÅŸma zamanÄ±'dÄ±r."],
    ["Derleme zamanÄ± yorumlayÄ±cÄ±lar, Ã§alÄ±ÅŸma zamanÄ± derleyiciler iÃ§in geÃ§erlidir.", "Bu ayrÄ±m temel olarak derleme sÃ¼reci iÃ§in geÃ§erlidir. YorumlayÄ±cÄ±larda bu iki zaman iÃ§ iÃ§e geÃ§miÅŸtir."],
    ["Derleme zamanÄ± programÄ±n hatalarÄ±nÄ±, Ã§alÄ±ÅŸma zamanÄ± ise programÄ±n doÄŸruluÄŸunu ifade eder.", "Bu anlamsÄ±z bir ifadedir."]
  ],
  answer: 2,
  summary: "Bir yazÄ±lÄ±mÄ± indirdiÄŸinizde, o yazÄ±lÄ±mÄ±n geliÅŸtiricisi 'derleme zamanÄ±'nÄ± Ã§oktan yaÅŸamÄ±ÅŸtÄ±r. Sizin programÄ± Ã§ift tÄ±klayÄ±p baÅŸlattÄ±ÄŸÄ±nÄ±z an ise 'Ã§alÄ±ÅŸma zamanÄ±'nÄ±n baÅŸladÄ±ÄŸÄ± andÄ±r."
},
{
  q: "21. Bir programlama dili komutlarÄ±nÄ± makine diline Ã§eviren yazÄ±lÄ±mlara genel olarak ne ad verilir?",
  options: [
    ["Ä°ÅŸletim Sistemleri", "Ä°ÅŸletim sistemleri donanÄ±mÄ± yÃ¶netir ve programlarÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in bir ortam saÄŸlar."],
    ["Uygulama YazÄ±lÄ±mlarÄ±", "Uygulama yazÄ±lÄ±mlarÄ±, kelime iÅŸlemci gibi son kullanÄ±cÄ±ya yÃ¶nelik programlardÄ±r."],
    ["Dil Ã‡evirici YazÄ±lÄ±mlar", "Bir programlama diliyle yazÄ±lmÄ±ÅŸ komutlarÄ±n makine diline Ã§evrimini gerÃ§ekleÅŸtiren yazÄ±lÄ±mlara genel olarak dil Ã§evirici yazÄ±lÄ±mlar denir. Derleyiciler ve yorumlayÄ±cÄ±lar bu kategoriye girer."],
    ["SÃ¼rÃ¼cÃ¼ler (Drivers)", "SÃ¼rÃ¼cÃ¼ler, iÅŸletim sisteminin belirli bir donanÄ±m parÃ§asÄ±nÄ± kontrol etmesini saÄŸlayan yazÄ±lÄ±mlardÄ±r."],
    ["Metin EditÃ¶rleri", "Metin editÃ¶rleri, kaynak kodu yazmak iÃ§in kullanÄ±lan araÃ§lardÄ±r, kodu Ã§evirmezler."]
  ],
  answer: 2,
  summary: "Ä°nsanlarÄ±n anladÄ±ÄŸÄ± yÃ¼ksek seviyeli diller ile makinelerin anladÄ±ÄŸÄ± makine dili arasÄ±nda bir 'tercÃ¼mana' ihtiyaÃ§ vardÄ±r. Bu tercÃ¼manlÄ±k gÃ¶revini yapan yazÄ±lÄ±mlarÄ±n genel adÄ± dil Ã§eviricilerdir."
},
{
  q: "22. Anlam Ã§Ã¶zÃ¼mleme aÅŸamasÄ±nÄ±n temel girdi ve Ã§Ä±ktÄ±sÄ± nedir?",
  options: [
    ["Girdi: Kaynak Program, Ã‡Ä±ktÄ±: Token Dizisi", "Bu metinsel Ã§Ã¶zÃ¼mlemenin girdi ve Ã§Ä±ktÄ±sÄ±dÄ±r."],
    ["Girdi: AyrÄ±ÅŸtÄ±rma AÄŸacÄ±, Ã‡Ä±ktÄ±: Soyut Dil ile GÃ¶sterilen Ara Program", "Anlam Ã§Ã¶zÃ¼mleyici, sÃ¶zdizimsel olarak doÄŸru olan programÄ±n yapÄ±sÄ±nÄ± gÃ¶steren ayrÄ±ÅŸtÄ±rma aÄŸacÄ±nÄ± alÄ±r ve ondan daha makineye yakÄ±n olan bir ara program (soyut program) Ã¼retir."],
    ["Girdi: Token Dizisi, Ã‡Ä±ktÄ±: AyrÄ±ÅŸtÄ±rma AÄŸacÄ±", "Bu sÃ¶zdizim Ã§Ã¶zÃ¼mlemenin girdi ve Ã§Ä±ktÄ±sÄ±dÄ±r."],
    ["Girdi: Ara Program, Ã‡Ä±ktÄ±: Makine Kodu", "Bu kod oluÅŸturma aÅŸamasÄ±nÄ±n girdi ve Ã§Ä±ktÄ±sÄ±dÄ±r."],
    ["Girdi: Dilin Grameri, Ã‡Ä±ktÄ±: Hata MesajlarÄ±", "Gramer bir girdidir ancak Ã§Ä±ktÄ± bu deÄŸildir."]
  ],
  answer: 1,
  summary: "Derleme bandÄ±nda sÃ¶zdizim Ã§Ã¶zÃ¼mleyici, kodun 'iskeletini' (ayrÄ±ÅŸtÄ±rma aÄŸacÄ±) Ã§Ä±karÄ±r. Anlam Ã§Ã¶zÃ¼mleyici ise bu iskeleti alÄ±p, ona 'anlam' katarak daha iÅŸlevsel bir ara modele dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r."
},
{
  q: "23. AÅŸaÄŸÄ±dakilerden hangisi bir yorumlayÄ±cÄ±nÄ±n Ã§alÄ±ÅŸma adÄ±mlarÄ±ndan biri deÄŸildir?",
  options: [
    ["SÄ±radaki deyimi al", "Bu, yorumlayÄ±cÄ±nÄ±n dÃ¶ngÃ¼sÃ¼nÃ¼n ilk adÄ±mÄ±dÄ±r."],
    ["YapÄ±lacak iÅŸlemleri belirle", "Bu, alÄ±nan deyimi analiz etme adÄ±mÄ±dÄ±r."],
    ["Ä°ÅŸlemleri gerÃ§ekleÅŸtir", "Bu, analiz edilen deyimi Ã§alÄ±ÅŸtÄ±rma adÄ±mÄ±dÄ±r."],
    ["TÃ¼m programÄ± tarayÄ±p amaÃ§ program oluÅŸtur", "Bu, bir derleyicinin Ã§alÄ±ÅŸma ÅŸeklidir. YorumlayÄ±cÄ±lar programÄ± bir bÃ¼tÃ¼n olarak deÄŸil, deyim deyim iÅŸler ve ayrÄ± bir amaÃ§ program oluÅŸturmazlar."],
    ["Programdaki deyimler sona erene kadar bu adÄ±mlarÄ± yinele", "Bu, yorumlayÄ±cÄ±nÄ±n genel Ã§alÄ±ÅŸma prensibini Ã¶zetler."]
  ],
  answer: 3,
  summary: "YorumlayÄ±cÄ±nÄ±n Ã§alÄ±ÅŸma prensibi bir 'oku-anla-yap' dÃ¶ngÃ¼sÃ¼dÃ¼r. Derleyicinin ise 'hepsini oku-hepsini anla-hepsini Ã§evir' ÅŸeklinde farklÄ± bir prensibi vardÄ±r. AmaÃ§ program oluÅŸturmak derleyiciye Ã¶zgÃ¼dÃ¼r."
},
{
  q: "24. Bir yÃ¼ksek dÃ¼zeyli programÄ±n makine diline Ã§evrilmesi ve o deyimin bilgisayarda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± birleÅŸtiren yaklaÅŸÄ±m hangisidir?",
  options: [
    ["Derleme", "Derleme, Ã§evirme ve Ã§alÄ±ÅŸtÄ±rma iÅŸlemlerini birbirinden net olarak ayÄ±rÄ±r (derleme zamanÄ± ve Ã§alÄ±ÅŸma zamanÄ±)."],
    ["Yorumlama", "Yorumlama yaklaÅŸÄ±mÄ±, bir deyimin makine diline Ã§evrimini ve o deyimin bilgisayarda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± birleÅŸtirir; her deyim anÄ±nda Ã§evrilip Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r."],
    ["Eniyileme", "Eniyileme, Ã§evrilen kodu daha verimli hale getirme iÅŸlemidir."],
    ["AyrÄ±ÅŸtÄ±rma", "AyrÄ±ÅŸtÄ±rma, derleme sÃ¼recinin bir aÅŸamasÄ±dÄ±r."],
    ["BaÄŸlama (Linking)", "BaÄŸlama, derlenmiÅŸ farklÄ± modÃ¼lleri birleÅŸtirme iÅŸlemidir."]
  ],
  answer: 1,
  summary: "Derlemede Ã§eviri ve Ã§alÄ±ÅŸtÄ±rma iki ayrÄ± dÃ¼nyadÄ±r. Yorumlamada ise bu iki dÃ¼nya iÃ§ iÃ§e geÃ§miÅŸtir; Ã§eviri ve Ã§alÄ±ÅŸtÄ±rma her deyim iÃ§in anÄ±nda birlikte gerÃ§ekleÅŸir."
},
{
  q: "25. Derleyici ve yorumlayÄ±cÄ±larÄ±n karÅŸÄ±laÅŸtÄ±rÄ±ldÄ±ÄŸÄ± tabloda, hangi dilin bir yorumlayÄ±cÄ± kullandÄ±ÄŸÄ± belirtilmiÅŸtir?",
  options: [
    ["C", "C, derleyici kullanan dillere Ã¶rnek olarak verilmiÅŸtir."],
    ["C++", "C++, derleyici kullanan dillere Ã¶rnek olarak verilmiÅŸtir."],
    ["Python", "Python, Ruby ve Java gibi dillerin yorumlayÄ±cÄ± kullandÄ±ÄŸÄ± belirtilmiÅŸtir."],
    ["Assembly", "Assembly dili bir derleyici (assembler) kullanÄ±r, yorumlayÄ±cÄ± deÄŸil."],
    ["Pascal", "Pascal, genellikle derlenerek kullanÄ±lan bir dildir."]
  ],
  answer: 2,
  summary: "Genel olarak C ve C++ gibi diller performans odaklÄ± olduklarÄ± iÃ§in derleyici kullanÄ±rken; Python ve Ruby gibi diller esneklik ve kullanÄ±m kolaylÄ±ÄŸÄ± iÃ§in yorumlayÄ±cÄ± kullanÄ±r. Java ise hibrit bir model kullanÄ±r."
},
{
  q: "26. Bir dil Ã§evirici yazÄ±lÄ±mÄ± oluÅŸturma sÃ¼recine ne ad verilir?",
  options: [
    ["Dil standardizasyonu", "Bu, dil iÃ§in resmi kurallar belirleme sÃ¼recidir."],
    ["Dil Ã§evrimi", "Bu, bir dilde yazÄ±lmÄ±ÅŸ programÄ± baÅŸka bir dile Ã§evirme iÅŸlemidir."],
    ["Dilin gerÃ§ekleÅŸtirimi", "Bir dil iÃ§in derleyici veya yorumlayÄ±cÄ± gibi dil Ã§evirici yazÄ±lÄ±mlarÄ±n oluÅŸturulmasÄ±, o dilin gerÃ§ekleÅŸtirimi (implementation) olarak adlandÄ±rÄ±lÄ±r."],
    ["Dil soyutlamasÄ±", "Bu, dildeki karmaÅŸÄ±k yapÄ±larÄ± daha basit temsil etme yeteneÄŸidir."],
    ["Dil ayrÄ±ÅŸtÄ±rmasÄ±", "Bu, derleme sÃ¼recindeki bir aÅŸamadÄ±r."]
  ],
  answer: 2,
  summary: "Bir programlama dilinin sadece kurallarÄ±nÄ± tanÄ±mlamak yetmez. O dilde yazÄ±lan kodlarÄ± Ã§alÄ±ÅŸtÄ±racak bir araca da ihtiyaÃ§ vardÄ±r. Ä°ÅŸte bu aracÄ± (derleyici/yorumlayÄ±cÄ±) yapma sÃ¼recine 'dilin gerÃ§ekleÅŸtirimi' denir."
},
{
  q: "27. Derleyicinin arka ucunda yer alan ve amacÄ±, programÄ±n ara kod gÃ¶sterimini alarak hedef bilgisayar iÃ§in makine kodunu oluÅŸturmak olan aÅŸama hangisidir?",
  options: [
    ["Metinsel Ã‡Ã¶zÃ¼mleme", "Bu, Ã¶n ucun ilk aÅŸamasÄ±dÄ±r."],
    ["SÃ¶zdizim Ã‡Ã¶zÃ¼mleme", "Bu, Ã¶n ucun ikinci aÅŸamasÄ±dÄ±r."],
    ["Anlam Ã‡Ã¶zÃ¼mleme", "Bu, Ã¶n ucun Ã¼Ã§Ã¼ncÃ¼ aÅŸamasÄ±dÄ±r."],
    ["Eniyileme", "Bu, arka ucun bir parÃ§asÄ±dÄ±r ancak temel gÃ¶revi kodu iyileÅŸtirmektir."],
    ["Kod OluÅŸturma", "Kod oluÅŸturma, derleyicinin arka ucunun temel gÃ¶revidir ve soyut programÄ± alÄ±p belirli bir bilgisayar iÃ§in nihai makine kodunu Ã¼retir."]
  ],
  answer: 4,
  summary: "Derleyicinin arka ucu, bir 'mÃ¼teahhit' gibidir. Ã–n uÃ§tan gelen 'mimari planÄ±' (ara kod) alÄ±r ve belirli bir 'arsa' (hedef bilgisayar) iÃ§in 'binayÄ± inÅŸa eder' (makine kodu oluÅŸturur)."
},
{
  q: "28. TaÅŸÄ±nabilir kod Ã¼retmek amacÄ±yla kullanÄ±lan hibrit yaklaÅŸÄ±mda, kaynak program Ã¶nce neye Ã§evrilir?",
  options: [
    ["DoÄŸrudan makine koduna", "Bu saf derleme yÃ¶ntemidir."],
    ["Bir sanal makinenin yorumlayacaÄŸÄ± bir ara koda (bytecode gibi)", "Hibrit yaklaÅŸÄ±mda, kaynak program Ã¶nce platformdan baÄŸÄ±msÄ±z bir ara koda derlenir. Bu ara kod daha sonra her platformdaki sanal makine tarafÄ±ndan yorumlanÄ±r."],
    ["Token dizisine", "Bu, derlemenin Ã§ok erken bir aÅŸamasÄ±dÄ±r."],
    ["AyrÄ±ÅŸtÄ±rma aÄŸacÄ±na", "Bu da derlemenin erken bir aÅŸamasÄ±dÄ±r."],
    ["DoÄŸrudan Ã§alÄ±ÅŸtÄ±rÄ±labilir bir dosyaya", "Bu saf derleme sonucudur."]
  ],
  answer: 1,
  summary: "TaÅŸÄ±nabilir kodun sÄ±rrÄ±, doÄŸrudan belirli bir makinenin diline deÄŸil, tÃ¼m makinelerin Ã¼zerinde Ã§alÄ±ÅŸabilen hayali bir makinenin (sanal makine) anladÄ±ÄŸÄ± evrensel bir 'ara dile' (bytecode) Ã§eviri yapmaktÄ±r."
},
{
  q: "29. Bir derleyicinin, bir programdaki aynÄ± tanÄ±mlayÄ±cÄ±nÄ±n sonraki kullanÄ±mlarÄ±nÄ±, o tanÄ±mlayÄ±cÄ± iÃ§in sembol tablosunda oluÅŸturulmuÅŸ olan aynÄ± elemana baÄŸlamasÄ±nÄ±n amacÄ± nedir?",
  options: [
    ["ProgramÄ±n daha yavaÅŸ Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak", "Bu anlamsÄ±z bir amaÃ§tÄ±r."],
    ["Bellek israfÄ±na neden olmak", "Bu bir amaÃ§ deÄŸil, istenmeyen bir sonuÃ§ olurdu."],
    ["ProgramÄ±n tutarlÄ±lÄ±ÄŸÄ±nÄ± saÄŸlamak ve tanÄ±mlayÄ±cÄ±yla ilgili bilgilere tek bir yerden eriÅŸmek", "Derleyici, 'puan' adÄ±nda bir deÄŸiÅŸken gÃ¶rdÃ¼ÄŸÃ¼nde, onunla ilgili tÃ¼m bilgileri (tipi, adresi vb.) tek bir yere kaydeder. Daha sonra her 'puan' gÃ¶rdÃ¼ÄŸÃ¼nde aynÄ± kayda bakarak tutarlÄ±lÄ±ÄŸÄ± korur."],
    ["Programdaki tÃ¼m deÄŸiÅŸkenlerin aynÄ± isimde olmasÄ±nÄ± zorunlu kÄ±lmak", "Bu anlamsÄ±z ve kÄ±sÄ±tlayÄ±cÄ± bir durum olurdu."],
    ["ProgramÄ±n hata ayÄ±klamasÄ±nÄ± zorlaÅŸtÄ±rmak", "Bu bir amaÃ§ deÄŸil, istenmeyen bir sonuÃ§ olurdu."]
  ],
  answer: 2,
  summary: "Sembol tablosu bir 'adres defteri' gibidir. Derleyici, bir deÄŸiÅŸkenle ilk tanÄ±ÅŸtÄ±ÄŸÄ±nda onun bilgilerini bu deftere kaydeder. Daha sonra aynÄ± isimle karÅŸÄ±laÅŸtÄ±ÄŸÄ±nda, kim olduÄŸunu anlamak iÃ§in tekrar tekrar analiz yapmak yerine doÄŸrudan bu adres defterine bakar."
},
{
  q: "30. AÅŸaÄŸÄ±daki ifadelerden hangisi derleme ve yorumlama arasÄ±ndaki farkÄ± yanlÄ±ÅŸ bir ÅŸekilde aÃ§Ä±klar?",
  options: [
    ["Derleyici tÃ¼m programÄ± tarar, yorumlayÄ±cÄ± satÄ±r satÄ±r iÅŸler.", "Bu doÄŸru bir ifadedir."],
    ["Derleyicinin genel yÃ¼rÃ¼tme sÃ¼resi daha hÄ±zlÄ±dÄ±r.", "Bu doÄŸru bir ifadedir."],
    ["YorumlayÄ±cÄ±da hata ayÄ±klama genellikle daha kolaydÄ±r.", "Bu doÄŸru bir ifadedir."],
    ["Derleyici tÃ¼m hatalarÄ± taradÄ±ktan sonra bildirir, yorumlayÄ±cÄ± ilk hatada durur.", "Bu doÄŸru bir ifadedir."],
    ["Derleyici Java gibi dilleri, yorumlayÄ±cÄ± C gibi dilleri kullanÄ±r.", "Bu ifade yanlÄ±ÅŸtÄ±r. Tam tersi, C ve C++ gibi diller derleyici kullanÄ±rken, Java hibrit bir model (derleyici+yorumlayÄ±cÄ±) kullanÄ±r."]
  ],
  answer: 4,
  summary: "Genel bir kural olarak, performansÄ±n kritik olduÄŸu sistem programlama dilleri (C, C++) derleyici kullanÄ±r. EsnekliÄŸin ve platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ±nÄ±n Ã¶nemli olduÄŸu diller (Java, Python) ise yorumlayÄ±cÄ± veya hibrit modeller kullanÄ±r."
}    
  ];

  const quizDiv = document.getElementById('quiz');
  const optionLabels = ['A)', 'B)', 'C)', 'D)', 'E)'];
  const userAnswers = new Array(questions.length).fill(null);


  questions.forEach((qObj, index) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'question-container';
    questionContainer.id = `question-${index}`;

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = qObj.q;
    questionContainer.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options-group';

    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback';
    feedbackDiv.style.display = 'none'; // Initially hidden

    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'summary';
    summaryDiv.style.display = 'none'; // Initially hidden


    qObj.options.forEach((opt, i) => {
      const optDiv = document.createElement('div');
      optDiv.className = 'option';
      optDiv.textContent = `${optionLabels[i]} ${opt[0]}`;
      optDiv.onclick = () => {
        // Clear previous selection visuals for this question
        const allOptsInGroup = optsDiv.querySelectorAll('.option');
        allOptsInGroup.forEach(el => el.classList.remove('selected'));
        optDiv.classList.add('selected'); // Mark as selected

        userAnswers[index] = i; // Store user's answer

        // Show feedback immediately
        const feedbackText = opt[1] || (i === qObj.answer ? "DoÄŸru cevap!" : "YanlÄ±ÅŸ cevap."); // Fallback feedback
        feedbackDiv.className = 'feedback ' + (i === qObj.answer ? 'correct' : 'incorrect');
        feedbackDiv.style.display = 'block';
        feedbackDiv.textContent = (i === qObj.answer ? 'âœ”ï¸ DoÄŸru: ' : 'âŒ YanlÄ±ÅŸ: ') + feedbackText;


        if (i === qObj.answer && qObj.summary) {
          summaryDiv.style.display = 'block';
          summaryDiv.textContent = 'ðŸ’¡ ' + qObj.summary;
        } else {
          summaryDiv.style.display = 'none';
        }
      };
      optsDiv.appendChild(optDiv);
    });

    questionContainer.appendChild(optsDiv);
    questionContainer.appendChild(feedbackDiv);
    questionContainer.appendChild(summaryDiv);
    quizDiv.appendChild(questionContainer);
  });

  function showResults() {
    let correctCount = 0;
    userAnswers.forEach((answer, index) => {
        if (answer !== null && answer === questions[index].answer) {
            correctCount++;
        }
    });

    const totalQuestions = questions.length;
    const scorePercentage = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(2) : 0;

    document.getElementById('total-questions').textContent = totalQuestions;
    document.getElementById('correct-answers').textContent = correctCount;
    document.getElementById('score-percentage').textContent = scorePercentage;
    document.getElementById('results-summary').style.display = 'block';

    // Scroll to results
    document.getElementById('results-summary').scrollIntoView({ behavior: 'smooth' });
  }

</script>
</body>
</html>