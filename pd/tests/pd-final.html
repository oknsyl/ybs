<!DOCTYPE html>
<html lang="tr">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Programlama Dilleri - Final</title>
  <style>
    body { font-family: 'PT Sans', 'Trebuchet MS', sans-serif; background: #f9f9f9; padding: 20px; color: #333; }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .question-container { background: #fff; padding: 20px; margin-bottom: 25px; border-left: 5px solid #007BFF; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-text { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; }
    .option { padding: 10px; margin: 8px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; transition: background-color 0.2s ease-in-out; }
    .option:hover { background: #e9ecef; }
    .option.selected { background-color: #cce5ff; border-color: #b8daff; }
    .feedback { margin-top: 15px; padding: 12px; border-radius: 4px; display: none; font-weight: bold; }
    .correct { background: #d4edda; border-left: 5px solid #28a745; color: #155724; }
    .incorrect { background: #f8d7da; border-left: 5px solid #dc3545; color: #721c24; }
    .summary { display: none; background: #fff3cd; padding: 12px; margin-top: 10px; border-left: 5px solid #ffc107; border-radius: 4px; color: #856404; }
    button#submit-all {
        display: block;
        margin: 30px auto;
        padding: 12px 25px;
        font-size: 1.1em;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    button#submit-all:hover {
        background-color: #218838;
    }
    .results { margin-top: 30px; padding: 20px; background-color: #e9ecef; border-radius: 5px; text-align: center;}
  </style>
</head>
<body>
<h1>Programlama Dilleri - Final</h1>
<div id="quiz">
  </div>
<button id="submit-all" onclick="showResults()">TÃ¼m Testi Bitir ve SonuÃ§larÄ± GÃ¶r</button>
<div id="results-summary" class="results" style="display:none;">
    <h2>Test Sonucu</h2>
    <p>Toplam Soru: <span id="total-questions"></span></p>
    <p>DoÄŸru Cevap SayÄ±sÄ±: <span id="correct-answers"></span></p>
    <p>BaÅŸarÄ± YÃ¼zdesi: <span id="score-percentage"></span>%</p>
</div>

<script>
  const questions = [
{
  q: "1. 'Tek Sorumluluk Prensibi' (Single Responsibility Principle) ve 'ArayÃ¼z AyÄ±rÄ±mÄ± Prensibi' (Interface Segregation Principle) arasÄ±ndaki temel iliÅŸki ve fark nedir?",
  options: [
    ["Her ikisi de sÄ±nÄ±flarla ilgilidir ve aralarÄ±nda fark yoktur.", "Tek Sorumluluk sÄ±nÄ±flarla, ArayÃ¼z AyÄ±rÄ±mÄ± ise arayÃ¼zlerle ilgilenir."],
    ["Tek Sorumluluk kalÄ±tÄ±mÄ±, ArayÃ¼z AyÄ±rÄ±mÄ± ise Ã§okyapÄ±lÄ±lÄ±ÄŸÄ± hedefler.", "Her ikisi de daha Ã§ok kodun modÃ¼lerliÄŸi ve sorumluluklarÄ±n daÄŸÄ±tÄ±lmasÄ±yla ilgilidir."],
    ["Her ikisi de aynÄ± amaca (sorumluluklarÄ± ayÄ±rmaya) hizmet eder; ancak Tek Sorumluluk bunu sÄ±nÄ±flar dÃ¼zeyinde, ArayÃ¼z AyÄ±rÄ±mÄ± ise arayÃ¼zler dÃ¼zeyinde yapar.", "Bu, ikisi arasÄ±ndaki en doÄŸru tanÄ±mdÄ±r. SRP, bir sÄ±nÄ±fÄ±n deÄŸiÅŸmesi iÃ§in tek bir neden olmasÄ± gerektiÄŸini sÃ¶yler. ISP ise bir sÄ±nÄ±fÄ±n, ihtiyacÄ± olmayan metotlarÄ± iÃ§eren bir arayÃ¼zÃ¼ uygulamaya zorlanmamasÄ± gerektiÄŸini sÃ¶yler. Ä°kisinin de kÃ¶kÃ¼nde 'bir ÅŸeye birden fazla sorumluluk yÃ¼kleme' fikri yatar."],
    ["Tek Sorumluluk derleme zamanÄ±, ArayÃ¼z AyÄ±rÄ±mÄ± ise Ã§alÄ±ÅŸma zamanÄ± ile ilgilidir.", "Her ikisi de tasarÄ±m zamanÄ± prensipleridir."],
    ["ArayÃ¼z AyÄ±rÄ±mÄ±, Tek Sorumluluk Prensibi'nin eski bir versiyonudur.", "HayÄ±r, ikisi de SOLID'in farklÄ± ve geÃ§erli prensipleridir."]
  ],
  answer: 2,
  summary: "SOLID prensiplerinden olan bu iki ilke, birbiriyle karÄ±ÅŸtÄ±rÄ±lmamalÄ±dÄ±r. UnutmayÄ±n: SRP, sÄ±nÄ±flarÄ±n 'iÃ§ini' dÃ¼zenler ve bir sÄ±nÄ±fÄ±n sadece bir iÅŸ yapmasÄ±nÄ± saÄŸlar. ISP ise sÄ±nÄ±flarÄ±n 'dÄ±ÅŸ dÃ¼nyayla olan sÃ¶zleÅŸmelerini' (arayÃ¼zlerini) dÃ¼zenler ve bir sÄ±nÄ±fÄ±n bilmediÄŸi iÅŸler iÃ§in sÃ¶z vermesini engeller."
},
{
  q: "2. `FOR SayaÃ§ = 5 TO 15` ÅŸeklinde tanÄ±mlanan parametreli bir dÃ¶ngÃ¼ toplamda kaÃ§ kez Ã§alÄ±ÅŸÄ±r?",
  options: [
    ["9", "Bu hatalÄ± bir hesaplamadÄ±r."],
    ["10", "`15 - 5` iÅŸlemi 10 sonucunu verir ancak dÃ¶ngÃ¼lerde bitiÅŸ deÄŸeri de dahil olduÄŸu iÃ§in bu cevap yanlÄ±ÅŸtÄ±r."],
    ["11", "DÃ¶ngÃ¼, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ve 15 deÄŸerlerini alarak toplamda 11 kez tekrarlanÄ±r. Genel formÃ¼l `(BitiÅŸ - BaÅŸlangÄ±Ã§) + 1` ÅŸeklindedir."],
    ["15", "Bu bitiÅŸ deÄŸeridir, tekrar sayÄ±sÄ± deÄŸildir."],
    ["DÃ¶ngÃ¼ sonsuza girer.", "Bu bir sayaÃ§lÄ± dÃ¶ngÃ¼dÃ¼r ve baÅŸlangÄ±cÄ± ile sonu bellidir."]
  ],
  answer: 2,
  summary: "SayaÃ§lÄ± dÃ¶ngÃ¼lerin tekrar sayÄ±sÄ±nÄ± hesaplamak, algoritma analizinin temel bir parÃ§asÄ±dÄ±r. SÄ±nÄ±r deÄŸerlerinin (baÅŸlangÄ±Ã§ ve bitiÅŸ) dÃ¶ngÃ¼ye dahil olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek, doÄŸru sonuca ulaÅŸmak iÃ§in kritik Ã¶neme sahiptir."
},
{
  q: "3. 'Metod YÃ¼klemesi (Overloading)' ve 'Metod Ãœzerine Yazma (Overriding)' arasÄ±ndaki en temel fark nedir?",
  options: [
    ["Overloading kalÄ±tÄ±mla, Overriding ise arayÃ¼zlerle ilgilidir.", "Her ikisi de kalÄ±tÄ±mla yakÄ±ndan ilgilidir. Overriding doÄŸrudan kalÄ±tÄ±mÄ± gerektirir."],
    ["Overloading Ã§alÄ±ÅŸma zamanÄ±nda, Overriding ise derleme zamanÄ±nda Ã§Ã¶zÃ¼lÃ¼r.", "Tam tersi doÄŸrudur. Hangi 'yÃ¼klenmiÅŸ' metodun Ã§aÄŸrÄ±lacaÄŸÄ± parametrelere gÃ¶re derleme zamanÄ±nda, hangi 'Ã¼zerine yazÄ±lmÄ±ÅŸ' metodun Ã§aÄŸrÄ±lacaÄŸÄ± ise nesnenin tipine gÃ¶re Ã§alÄ±ÅŸma zamanÄ±nda belirlenir."],
    ["Overloading'de metotlarÄ±n parametre listeleri farklÄ±, Overriding'de ise aynÄ± olmak zorundadÄ±r.", "Bu, aralarÄ±ndaki en kritik ve temel farktÄ±r. YÃ¼kleme (Overloading), aynÄ± ismin farklÄ± gÃ¶revler iÃ§in 'yeniden yÃ¼klenmesidir' ve bu gÃ¶revler parametrelerine gÃ¶re ayÄ±rt edilir. Ãœzerine yazma (Overriding) ise, bir alt sÄ±nÄ±fÄ±n, Ã¼st sÄ±nÄ±ftan gelen bir gÃ¶revi 'devralÄ±p kendi yÃ¶ntemiyle yapmasÄ±dÄ±r' ve gÃ¶revin tanÄ±mÄ± (isim ve parametreleri) aynÄ± kalmalÄ±dÄ±r."],
    ["Overloading C++'da, Overriding ise Java'da bulunur.", "Her iki kavram da nesneye yÃ¶nelik programlamanÄ±n temelini oluÅŸturur ve her iki dilde de bulunur."],
    ["Overloading'de metot isimleri farklÄ±, Overriding'de aynÄ±dÄ±r.", "Her ikisinde de metot isimleri aynÄ±dÄ±r."]
  ],
  answer: 2,
  summary: "Ã–zetle, Overloading 'aynÄ± adlÄ± farklÄ± metotlar' demektir ve derleyici hangisini seÃ§eceÄŸini parametrelere bakarak bilir (statik baÄŸlama). Overriding ise 'Ã¼st sÄ±nÄ±fÄ±n metodunu alt sÄ±nÄ±fta ezmek' demektir ve program Ã§alÄ±ÅŸÄ±rken nesnenin gerÃ§ek tipine gÃ¶re hangi versiyonun Ã§alÄ±ÅŸacaÄŸÄ±na karar verilir (dinamik baÄŸlama)."
},
{
  q: "4. Java'nÄ±n 'bir kere yaz, her yerde Ã§alÄ±ÅŸtÄ±r' felsefesini mÃ¼mkÃ¼n kÄ±lan ve platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ± saÄŸlayan temel teknoloji ikilisi nedir?",
  options: [
    ["Derleyici ve BaÄŸlayÄ±cÄ± (Linker)", "Bu, C/C++ gibi dillerde platforma baÄŸÄ±mlÄ± Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyalar Ã¼reten standart bir sÃ¼reÃ§tir."],
    ["YorumlayÄ±cÄ± ve Betik Dili", "Bu yaklaÅŸÄ±m platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ± sunabilir ancak Java'nÄ±n hibrit modelinden farklÄ±dÄ±r."],
    ["Ã‡Ã¶p ToplayÄ±cÄ± (Garbage Collector) ve KalÄ±tÄ±m", "Bunlar Java'nÄ±n Ã¶nemli Ã¶zellikleri olsa da platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ±nÄ±n temel mekanizmasÄ± deÄŸildir."],
    ["Bytecode ve Java Sanal Makinesi (JVM)", "Java'da kaynak kod, belirli bir iÅŸletim sisteminin makine koduna deÄŸil, 'bytecode' adÄ± verilen evrensel bir ara koda derlenir. Bu bytecode, her platform iÃ§in ayrÄ± ayrÄ± yazÄ±lmÄ±ÅŸ olan Java Sanal Makinesi (JVM) tarafÄ±ndan yorumlanarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Bu yapÄ± platform baÄŸÄ±msÄ±zlÄ±ÄŸÄ± saÄŸlar."],
    ["Applet ve Uygulama (Application)", "Bunlar, Java programlarÄ±nÄ±n iki farklÄ± tÃ¼rÃ¼dÃ¼r, altta yatan teknoloji deÄŸildir."]
  ],
  answer: 3,
  summary: "Java'nÄ±n Ã§Ã¶zÃ¼mÃ¼ dÃ¢hicedir: 'Kodu her platform iÃ§in ayrÄ± ayrÄ± yazmak yerine, her platform iÃ§in bir kez 'tercÃ¼man' (JVM) yazalÄ±m. BÃ¶ylece Java dilinde yazÄ±lan her kod, bu tercÃ¼manlarÄ±n olduÄŸu her yerde sorunsuzca Ã§alÄ±ÅŸabilsin.' Bu ara dil de 'bytecode'dur."
},
{
  q: "5. 'AÃ§Ä±k/KapalÄ± Prensibi' (Open/Closed Principle) ne anlama gelir?",
  options: [
    ["Bir sÄ±nÄ±fÄ±n kaynak kodunun herkese aÃ§Ä±k, ancak deÄŸiÅŸtirilmesinin yasak olmasÄ± gerektiÄŸini.", "Bu, aÃ§Ä±k kaynak lisanslarÄ±yla ilgili bir konudur."],
    ["Bir nesnenin geliÅŸtirilmeye (yeni Ã¶zellikler eklemeye) aÃ§Ä±k, ancak deÄŸiÅŸtirilmeye (mevcut kodunu bozmaya) kapalÄ± olmasÄ± gerektiÄŸini.", "Bu prensip, var olan ve hatasÄ±z Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan emin olduÄŸumuz bir kodu deÄŸiÅŸtirmeden, sisteme yeni iÅŸlevler ekleyebilmemiz gerektiÄŸini sÃ¶yler. Bu, genellikle mevcut sÄ±nÄ±ftan kalÄ±tÄ±m alarak veya arayÃ¼zler kullanarak saÄŸlanÄ±r."],
    ["Bir projenin hem aÃ§Ä±k hem de kapalÄ± kaynak kodlu olabileceÄŸini.", "Bu, lisanslama ile ilgili bir konudur."],
    ["SÄ±nÄ±flarÄ±n kapÄ±larÄ±nÄ±n yeni Ã¶zelliklere kapalÄ± olmasÄ± gerektiÄŸini.", "Tam tersine, yeni Ã¶zelliklere 'aÃ§Ä±k' olmalÄ±dÄ±r."],
    ["TÃ¼m metotlarÄ±n public (aÃ§Ä±k) olmasÄ± gerektiÄŸini.", "Bu, kapsÃ¼lleme ilkesini ihlal eder."]
  ],
  answer: 1,
  summary: "AÃ§Ä±k/KapalÄ± Prensibi, 'Mevcut sisteme dokunma, ona eklentiler yaparak geniÅŸlet' der. Bu, Ã§alÄ±ÅŸan bir sistemin yeni bir Ã¶zellik eklenirken bozulma riskini ortadan kaldÄ±rÄ±r ve yazÄ±lÄ±mÄ± daha sÃ¼rdÃ¼rÃ¼lebilir hale getirir."
},
{
  q: "6. Bir programlama dilinin gÃ¼venilirliÄŸini Ã¶nemli Ã¶lÃ§Ã¼de artÄ±ran 'kuvvetli tipleme (strong typing)' kavramÄ±nÄ± literatÃ¼re ilk kez tanÄ±tan dil hangisidir?",
  options: [
    ["C", "C ve C++, esnek yapÄ±larÄ± ve gÃ¶sterge kullanÄ±mlarÄ± nedeniyle kuvvetli tiplemeyi tam olarak gerÃ§ekleÅŸtirmeyen dillere Ã¶rnektir."],
    ["FORTRAN", "Ä°lk programlama dillerinden olan FORTRAN'da tip denetimi oldukÃ§a zayÄ±ftÄ±."],
    ["Java", "Java kuvvetli tipli bir dildir ancak bu kavramÄ± literatÃ¼re tanÄ±tan ilk dil deÄŸildir."],
    ["ALGOL 60", "ALGOL 60, birÃ§ok yapÄ±sal programlama ve tip teorisi kavramÄ±nÄ±n temelini atmÄ±ÅŸtÄ±r ancak kuvvetli tiplemeyi getiren dil olarak Pascal kabul edilir."],
    ["Pascal", "Pascal, program doÄŸruluÄŸunu ve gÃ¼venilirliÄŸini artÄ±rmak amacÄ±yla tasarlanmÄ±ÅŸtÄ±r. Bu hedef doÄŸrultusunda, derleyicinin katÄ± tip denetimleri yaptÄ±ÄŸÄ± 'kuvvetli tipleme' anlayÄ±ÅŸÄ±nÄ± programlama dilleri dÃ¼nyasÄ±na tanÄ±tan Ã¶ncÃ¼ dildir."]
  ],
  answer: 4,
  summary: "Pascal, bir 'eÄŸitim' dili olarak tasarlanmasÄ±nÄ±n bir sonucu olarak, programcÄ±larÄ± daha disiplinli ve daha az hataya aÃ§Ä±k kod yazmaya teÅŸvik eden birÃ§ok gÃ¼venlik mekanizmasÄ± getirmiÅŸtir. Kuvvetli tipleme, bu mekanizmalarÄ±n en Ã¶nemlisidir."
},
{
  q: "7. `WHILE` ve `REPEAT...UNTIL` tipi koÅŸullu dÃ¶ngÃ¼ler arasÄ±ndaki en temel fark nedir?",
  options: [
    ["WHILE dÃ¶ngÃ¼sÃ¼ sayÄ±sal, UNTIL dÃ¶ngÃ¼sÃ¼ mantÄ±ksal koÅŸul kullanÄ±r.", "Her ikisi de mantÄ±ksal bir koÅŸula gÃ¶re Ã§alÄ±ÅŸÄ±r."],
    ["WHILE dÃ¶ngÃ¼sÃ¼nde koÅŸul dÃ¶ngÃ¼nÃ¼n baÅŸÄ±nda, UNTIL dÃ¶ngÃ¼sÃ¼nde ise sonunda denetlenir.", "Bu, aralarÄ±ndaki en temel ve kritik farktÄ±r. Bu nedenle `UNTIL` dÃ¶ngÃ¼sÃ¼ her durumda en az bir kere Ã§alÄ±ÅŸÄ±rken, `WHILE` dÃ¶ngÃ¼sÃ¼ koÅŸul baÅŸlangÄ±Ã§ta yanlÄ±ÅŸsa hiÃ§ Ã§alÄ±ÅŸmayabilir."],
    ["WHILE dÃ¶ngÃ¼sÃ¼ sonsuza kadar Ã§alÄ±ÅŸabilir, UNTIL dÃ¶ngÃ¼sÃ¼ ise Ã§alÄ±ÅŸamaz.", "Her iki dÃ¶ngÃ¼ de yanlÄ±ÅŸ kurulursa sonsuz dÃ¶ngÃ¼ye girebilir."],
    ["WHILE dÃ¶ngÃ¼sÃ¼ sayaÃ§lÄ±, UNTIL dÃ¶ngÃ¼sÃ¼ koÅŸullu dÃ¶ngÃ¼dÃ¼r.", "Her ikisi de koÅŸullu dÃ¶ngÃ¼ tÃ¼rÃ¼dÃ¼r."],
    ["HiÃ§bir temel farklarÄ± yoktur, sadece sÃ¶zdizimleri farklÄ±dÄ±r.", "HayÄ±r, Ã§alÄ±ÅŸma mantÄ±klarÄ± arasÄ±nda Ã§ok Ã¶nemli bir fark vardÄ±r."]
  ],
  answer: 1,
  summary: "`WHILE` dÃ¶ngÃ¼sÃ¼ bir 'Ã¶n-denetimli' dÃ¶ngÃ¼dÃ¼r; kapÄ±daki koÅŸul saÄŸlanmazsa iÃ§eri kimseyi almaz. `REPEAT...UNTIL` dÃ¶ngÃ¼sÃ¼ ise bir 'son-denetimli' dÃ¶ngÃ¼dÃ¼r; herkesi iÃ§eri alÄ±r, en az bir kez eylemi gerÃ§ekleÅŸtirir ve Ã§Ä±kÄ±ÅŸta koÅŸulu kontrol eder."
},
{
  q: "8. Bir derleyicinin arka ucunda (back-end) yer alan ve amacÄ±, programÄ±n yaptÄ±ÄŸÄ± iÅŸi deÄŸiÅŸtirmeden daha hÄ±zlÄ± veya daha az kaynak kullanacak ÅŸekilde kodu iyileÅŸtirmek olan aÅŸama hangisidir?",
  options: [
    ["Anlam Ã‡Ã¶zÃ¼mleme", "Bu, Ã¶n ucun bir parÃ§asÄ±dÄ±r ve kodun anlamÄ±nÄ± kontrol eder."],
    ["SÃ¶zdizim Ã‡Ã¶zÃ¼mleme", "Bu, Ã¶n ucun bir parÃ§asÄ±dÄ±r ve kodun gramerini kontrol eder."],
    ["Kod OluÅŸturma", "Bu, arka ucun bir parÃ§asÄ±dÄ±r ancak amacÄ± son makine kodunu Ã¼retmektir."],
    ["Eniyileme (Optimization)", "Eniyileme, programÄ±n mantÄ±ÄŸÄ±nÄ± koruyarak performansÄ±nÄ± artÄ±rma sanatÄ±dÄ±r. Ã–rneÄŸin, gereksiz hesaplamalarÄ± ortadan kaldÄ±rmak veya daha hÄ±zlÄ± komutlarÄ± tercih etmek gibi iÅŸlemlerle kod daha verimli hale getirilir."],
    ["Metinsel Ã‡Ã¶zÃ¼mleme", "Bu, Ã¶n ucun ilk aÅŸamasÄ±dÄ±r."]
  ],
  answer: 3,
  summary: "Eniyileme aÅŸamasÄ±, derleyicinin 'akÄ±llÄ±' davrandÄ±ÄŸÄ± yerdir. YazdÄ±ÄŸÄ±nÄ±z kodu analiz eder ve 'bunu yapmanÄ±n daha verimli bir yolu var' diyerek, programÄ±n iÅŸlevini bozmadan daha performanslÄ± Ã§alÄ±ÅŸacak ÅŸekilde yeniden dÃ¼zenler."
},
{
  q: "9. `a - b * c` gibi bir ifadenin sonucunun belirsizliÄŸini ortadan kaldÄ±rmak iÃ§in, iÅŸlemcilerin hangi iki Ã¶zelliÄŸi kullanÄ±lÄ±r?",
  options: [
    ["Ä°ÅŸlenen SayÄ±sÄ± ve Ä°ÅŸlemcinin Yeri", "Bunlar ifadenin yapÄ±sÄ±nÄ± tanÄ±mlar ama iÅŸlem sÄ±rasÄ±nÄ± belirlemez."],
    ["Kapsam ve YaÅŸam SÃ¼resi", "Bunlar deÄŸiÅŸkenlerle ilgili kavramlardÄ±r."],
    ["Ã–ncelik (Precedence) ve Ä°liÅŸkisellik (Associativity)", "Ã–ncelik, `*` ve `+` gibi farklÄ± seviyedeki iÅŸlemcilerden hangisinin Ã¶nce yapÄ±lacaÄŸÄ±nÄ± belirler. Ä°liÅŸkisellik ise `a-b-c` gibi aynÄ± seviyedeki iÅŸlemcilerin soldan mÄ± yoksa saÄŸdan mÄ± iÅŸleneceÄŸini belirler. Bu iki kural, tÃ¼m ifadelerin net bir ÅŸekilde yorumlanmasÄ±nÄ± saÄŸlar."],
    ["Tip Denetimi ve Tip DÃ¶nÃ¼ÅŸÃ¼mÃ¼", "Bunlar, iÅŸlem yapÄ±lacak verilerin uyumluluÄŸu ile ilgilidir."],
    ["KalÄ±tÄ±m ve Ã‡okyapÄ±lÄ±lÄ±k", "Bunlar nesneye yÃ¶nelik programlama kavramlarÄ±dÄ±r."]
  ],
  answer: 2,
  summary: "Ä°ÅŸlemci Ã–nceliÄŸi ve Ä°liÅŸkisellik, programlama dillerinin 'matematiksel dilbilgisi' kurallarÄ±dÄ±r. Bu kurallar sayesinde, parantez kullanÄ±lmasa bile karmaÅŸÄ±k bir ifadenin tÃ¼m dÃ¼nyadaki derleyiciler tarafÄ±ndan aynÄ± ÅŸekilde anlaÅŸÄ±lÄ±p aynÄ± sonucu Ã¼retmesi garanti altÄ±na alÄ±nÄ±r."
},
{
  q: "10. Bir `Hayvan` Ã¼st sÄ±nÄ±fÄ±ndan tÃ¼retilen `Kedi` ve `Kopek` alt sÄ±nÄ±flarÄ±nÄ±n her ikisinin de `sesCikar()` metodunu kendine Ã¶zgÃ¼ bir ÅŸekilde (biri 'Miyav', diÄŸeri 'Hav' olarak) tanÄ±mlamasÄ±, hangi OOP kavramÄ±na Ã¶rnektir?",
  options: [
    ["Metod YÃ¼klemesi (Method Overloading)", "YÃ¼klemede aynÄ± sÄ±nÄ±f iÃ§inde, farklÄ± parametrelerle aynÄ± isimli metotlar olur."],
    ["Metod Ãœzerine Yazma (Method Overriding)", "Bu, tam olarak Ã¼zerine yazma kavramÄ±dÄ±r. Alt sÄ±nÄ±f, Ã¼st sÄ±nÄ±ftan gelen bir davranÄ±ÅŸÄ± devralÄ±r ama onu kendi kimliÄŸine uygun ÅŸekilde 'ezer' ve yeniden uygular."],
    ["Soyutlama (Abstraction)", "Soyutlama, detaylarÄ± gizlemektir."],
    ["KapsÃ¼lleme (Encapsulation)", "KapsÃ¼lleme, veri ve metotlarÄ± birleÅŸtirmektir."],
    ["Tek Sorumluluk Prensibi", "Bu bir SOLID prensibidir, doÄŸrudan bir OOP mekanizmasÄ± deÄŸildir."]
  ],
  answer: 1,
  summary: "Metod Ãœzerine Yazma, kalÄ±tÄ±mÄ±n en gÃ¼Ã§lÃ¼ yÃ¶nlerinden biridir. TÃ¼m 'hayvanlarÄ±n' ses Ã§Ä±kardÄ±ÄŸÄ±nÄ± (Ã¼st sÄ±nÄ±f metodu) bilirsiniz, ancak her hayvanÄ±n bu eylemi kendine Ã¶zgÃ¼ bir ÅŸekilde yaptÄ±ÄŸÄ±nÄ± (alt sÄ±nÄ±fÄ±n Ã¼zerine yazdÄ±ÄŸÄ± metot) bilirsiniz. Bu, ortak bir arayÃ¼z altÄ±nda farklÄ± davranÄ±ÅŸlar sergilemeyi saÄŸlar."
},
{
  q: "11. 'BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±n Ters Ã‡evrilmesi Prensibi'ne (Dependency Inversion Principle) gÃ¶re, Ã¼st seviye bir modÃ¼l ile alt seviye bir modÃ¼l arasÄ±ndaki iliÅŸki nasÄ±l olmalÄ±dÄ±r?",
  options: [
    ["Ãœst seviye modÃ¼l, alt seviye modÃ¼lÃ¼ doÄŸrudan bilmeli ve kullanmalÄ±dÄ±r.", "Bu, prensibin ihlal edildiÄŸi durumdur."],
    ["Her iki modÃ¼l de doÄŸrudan birbirine deÄŸil, ikisinin de ortak olarak kullandÄ±ÄŸÄ± bir soyutlamaya (arayÃ¼ze) baÄŸÄ±mlÄ± olmalÄ±dÄ±r.", "Bu prensip, modÃ¼ller arasÄ±ndaki doÄŸrudan 'somut' baÄŸÄ±mlÄ±lÄ±klarÄ± koparÄ±p, yerine her ikisinin de 'soyut' bir sÃ¶zleÅŸmeye (arayÃ¼ze) uymasÄ±nÄ± saÄŸlayarak sistemi daha esnek ve deÄŸiÅŸtirilebilir hale getirir."],
    ["Alt seviye modÃ¼l, Ã¼st seviye modÃ¼l hakkÄ±nda her ÅŸeyi bilmelidir.", "Bu, baÄŸÄ±mlÄ±lÄ±ÄŸÄ± daha da artÄ±rÄ±r."],
    ["ModÃ¼ller arasÄ±nda hiÃ§bir iliÅŸki olmamalÄ±dÄ±r.", "Bu, sistemin Ã§alÄ±ÅŸmasÄ±nÄ± imkansÄ±z kÄ±lar."],
    ["TÃ¼m modÃ¼ller tek bir Ã¼st sÄ±nÄ±f altÄ±nda toplanmalÄ±dÄ±r.", "Bu farklÄ± bir tasarÄ±m desenidir."]
  ],
  answer: 1,
  summary: "Bu prensip, 'prize deÄŸil, fiÅŸe takÄ±l' mantÄ±ÄŸÄ±na dayanÄ±r. Elektrikli aletler (Ã¼st seviye modÃ¼l), duvardaki prizin (alt seviye modÃ¼l) markasÄ±na veya yapÄ±sÄ±na deÄŸil, standart bir fiÅŸ arayÃ¼zÃ¼ne (soyutlama) baÄŸÄ±mlÄ±dÄ±r. Bu sayede aynÄ± aleti farklÄ± Ã¼lkelerdeki prizlere bir adaptÃ¶rle takabilirsiniz."
},
{
  q: "12. C++ dilinin aksine, Java dilinin doÄŸrudan desteklemediÄŸi ancak etkisini 'arayÃ¼zler (interfaces)' kullanarak saÄŸladÄ±ÄŸÄ± kalÄ±tÄ±m tÃ¼rÃ¼ hangisidir?",
  options: [
    ["Tekli KalÄ±tÄ±m", "Java tekli kalÄ±tÄ±mÄ± doÄŸrudan destekler."],
    ["Ã‡oklu KalÄ±tÄ±m", "Java, C++'da bulunan ve bir sÄ±nÄ±fÄ±n birden fazla Ã¼st sÄ±nÄ±ftan miras almasÄ±na olanak tanÄ±yan Ã§oklu kalÄ±tÄ±mÄ±, getirdiÄŸi karmaÅŸÄ±klÄ±klar (Ã¶rn: diamond problem) nedeniyle doÄŸrudan desteklemez."],
    ["Spesifikasyon iÃ§in KalÄ±tÄ±m", "Bu bir kalÄ±tÄ±m amacÄ±dÄ±r, tÃ¼rÃ¼ deÄŸil."],
    ["GeniÅŸletme iÃ§in KalÄ±tÄ±m", "Bu da bir kalÄ±tÄ±m amacÄ±dÄ±r."],
    ["KÄ±sÄ±tlama iÃ§in KalÄ±tÄ±m", "Bu da bir kalÄ±tÄ±m amacÄ±dÄ±r."]
  ],
  answer: 1,
  summary: "Java, bir sÄ±nÄ±fÄ±n sadece tek bir 'gerÃ§ek' ebeveyni (Ã¼st sÄ±nÄ±fÄ±) olabileceÄŸini sÃ¶yler. Ancak bir sÄ±nÄ±fÄ±n, birden Ã§ok 'rolÃ¼' (arayÃ¼zÃ¼) Ã¼stlenebileceÄŸini belirtir. Bu, Ã§oklu kalÄ±tÄ±mÄ±n gÃ¼cÃ¼nÃ¼, onun karmaÅŸÄ±klÄ±ÄŸÄ± olmadan elde etmenin bir yoludur."
},
{
  q: "13. Bir dilin sÃ¶zdizimini (syntax) tanÄ±mlamak iÃ§in kullanÄ±lan BNF gibi metadiller varken, anlamÄ±nÄ± (semantics) tanÄ±mlamak iÃ§in neden evrensel kabul gÃ¶rmÃ¼ÅŸ tek bir standart yoktur?",
  options: [
    ["Ã‡Ã¼nkÃ¼ anlam kurallarÄ± her programda deÄŸiÅŸir.", "Anlam kurallarÄ± dile aittir, programa deÄŸil."],
    ["Ã‡Ã¼nkÃ¼ anlam tanÄ±mlama yÃ¶ntemleri oldukÃ§a karmaÅŸÄ±ktÄ±r ve hiÃ§biri evrensel kabul gÃ¶rmemiÅŸtir.", "Bir dilin gramerini tanÄ±mlamak, onun ne anlama geldiÄŸini tanÄ±mlamaktan daha basit bir problemdir. Anlam, programÄ±n durumu, mantÄ±ÄŸÄ± gibi Ã§ok daha soyut kavramlar iÃ§erdiÄŸinden, bunu tanÄ±mlayacak tek ve basit bir standart Ã¼zerinde anlaÅŸmaya varÄ±lamamÄ±ÅŸtÄ±r."],
    ["Ã‡Ã¼nkÃ¼ anlamÄ± sadece derleyici tanÄ±mlayabilir.", "Derleyici anlam kurallarÄ±nÄ± uygular, tanÄ±mlamaz."],
    ["Ã‡Ã¼nkÃ¼ tÃ¼m dillerin anlamÄ± temelde aynÄ±dÄ±r.", "Bu kesinlikle yanlÄ±ÅŸtÄ±r."],
    ["Ã‡Ã¼nkÃ¼ sÃ¶zdizim, anlamdan daha Ã¶nemlidir.", "Her ikisi de bir dilin Ã§alÄ±ÅŸmasÄ± iÃ§in eÅŸit derecede Ã¶nemlidir."]
  ],
  answer: 1,
  summary: "SÃ¶zdizimi, bir cÃ¼mlenin 'dilbilgisi kurallarÄ±na uygun' olup olmadÄ±ÄŸÄ±nÄ± sÃ¶yler. Anlam ise o cÃ¼mlenin 'mantÄ±klÄ± olup olmadÄ±ÄŸÄ±nÄ±' sÃ¶yler. 'YeÅŸil fikirler renksizce uyur' cÃ¼mlesi sÃ¶zdizimsel olarak doÄŸru ama anlamsal olarak saÃ§madÄ±r. Ä°ÅŸte bu anlamsal karmaÅŸÄ±klÄ±k, tek bir standart oluÅŸturmayÄ± zorlaÅŸtÄ±rÄ±r."
},
{
  q: "14. `Liskov Yerine GeÃ§me Prensibi`ne gÃ¶re, bir `Kare` sÄ±nÄ±fÄ±, `Dikdortgen` sÄ±nÄ±fÄ±ndan miras aldÄ±ÄŸÄ±nda neden bir ihlal oluÅŸabilir?",
  options: [
    ["Ã‡Ã¼nkÃ¼ kare bir dikdÃ¶rtgen deÄŸildir.", "Matematiksel olarak her kare aynÄ± zamanda bir dikdÃ¶rtgendir."],
    ["Ã‡Ã¼nkÃ¼ `Dikdortgen` sÄ±nÄ±fÄ±nÄ±n `setGenislik` ve `setYukseklik` metotlarÄ±, `Kare` sÄ±nÄ±fÄ±nda beklendiÄŸi gibi Ã§alÄ±ÅŸmaz.", "Bir dikdÃ¶rtgenin geniÅŸliÄŸini deÄŸiÅŸtirmek yÃ¼ksekliÄŸini etkilemez. Ancak bir karenin geniÅŸliÄŸini deÄŸiÅŸtirdiÄŸinizde, kare kalmasÄ± iÃ§in yÃ¼ksekliÄŸinin de deÄŸiÅŸmesi gerekir. Bu durum, `Dikdortgen` sÄ±nÄ±fÄ±nÄ±n 'davranÄ±ÅŸ sÃ¶zleÅŸmesini' bozar ve alt sÄ±nÄ±fÄ±n, Ã¼st sÄ±nÄ±fÄ±n yerine sorunsuzca geÃ§mesini engeller."],
    ["Ã‡Ã¼nkÃ¼ `Kare` sÄ±nÄ±fÄ± daha az metoda sahiptir.", "Metot sayÄ±sÄ± deÄŸil, davranÄ±ÅŸlarÄ±n tutarlÄ±lÄ±ÄŸÄ± Ã¶nemlidir."],
    ["Ã‡Ã¼nkÃ¼ kalÄ±tÄ±m sadece soyut sÄ±nÄ±flardan yapÄ±labilir.", "Bu doÄŸru deÄŸildir."],
    ["Ã‡Ã¼nkÃ¼ C++'da bu tÃ¼r bir kalÄ±tÄ±m yasaktÄ±r.", "Yasak deÄŸildir ancak bu prensibin ihlaline iyi bir Ã¶rnektir."]
  ],
  answer: 1,
  summary: "Bu prensip, 'kalÄ±tÄ±m, sadece bir 'is-a' (bir tÃ¼rÃ¼dÃ¼r) iliÅŸkisinden daha fazlasÄ±dÄ±r, aynÄ± zamanda bir 'behaves-like-a' (gibi davranÄ±r) iliÅŸkisidir' der. EÄŸer alt sÄ±nÄ±f, Ã¼st sÄ±nÄ±f gibi davranmÄ±yorsa, bu kalÄ±tÄ±m yanlÄ±ÅŸtÄ±r ve Liskov prensibi ihlal edilmiÅŸtir."
},
{
  q: "15. YazÄ±lÄ±m GeliÅŸtirme YaÅŸam DÃ¶ngÃ¼sÃ¼'nÃ¼n hangi aÅŸamasÄ±, sistemin gereksinimlerini, kÄ±sÄ±tlamalarÄ±nÄ± ve hedeflerini tanÄ±mlayÄ±p belgelemeyi amaÃ§lar?",
  options: [
    ["TasarÄ±m AÅŸamasÄ±", "TasarÄ±m aÅŸamasÄ±, bu belirlenen gereksinimlere gÃ¶re sistemin nasÄ±l inÅŸa edileceÄŸini planlar."],
    ["Kodlama AÅŸamasÄ±", "Kodlama aÅŸamasÄ±, tasarÄ±mÄ± koda dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r."],
    ["Gereksinimlerin Analizi ve Belirlenmesi", "Bu ilk aÅŸama, 'ne inÅŸa edeceÄŸiz?' ve 'neden inÅŸa edeceÄŸiz?' sorularÄ±nÄ± cevaplar. Projenin geri kalanÄ± bu aÅŸamada Ã¼retilen belgelere dayanÄ±r."],
    ["Test AÅŸamasÄ±", "Test aÅŸamasÄ±, inÅŸa edilen sistemin gereksinimleri karÅŸÄ±layÄ±p karÅŸÄ±lamadÄ±ÄŸÄ±nÄ± kontrol eder."],
    ["BakÄ±m AÅŸamasÄ±", "Bu, proje teslim edildikten sonraki sÃ¼reÃ§tir."]
  ],
  answer: 2,
  summary: "Gereksinim analizi, bir inÅŸaat projesindeki mimarÄ±n mÃ¼ÅŸteriyle oturup ihtiyaÃ§larÄ±nÄ± (kaÃ§ oda, nasÄ±l bir mutfak vb.) dinleyip kaydettiÄŸi en kritik toplantÄ±lara benzer. Bu adÄ±mda yapÄ±lacak bir yanlÄ±ÅŸ anlama, tÃ¼m projenin yanlÄ±ÅŸ inÅŸa edilmesine neden olabilir."
},
{
  q: "16. `Dizi (Array)` ve `KayÄ±t (Record)` veri yapÄ±larÄ± arasÄ±ndaki en temel fark nedir?",
  options: [
    ["Diziler bellekte, kayÄ±tlar diskte saklanÄ±r.", "Her ikisi de bellekte saklanabilir."],
    ["Dizilerin boyutu dinamik, kayÄ±tlarÄ±nki statiktir.", "Her ikisi iÃ§in de farklÄ± bellek stratejileri olabilir."],
    ["Diziler homojen (aynÄ± tÃ¼rden), kayÄ±tlar ise heterojen (farklÄ± tÃ¼rlerden) veri elemanlarÄ± iÃ§erir.", "Bir dizi sadece tamsayÄ±larÄ± veya sadece metinleri tutabilirken, bir 'Ã¶ÄŸrenci' kaydÄ± bir tamsayÄ± (numara), bir metin (ad) ve bir ondalÄ±klÄ± sayÄ±yÄ± (ortalama) aynÄ± anda iÃ§erebilir."],
    ["Dizilere isimle, kayÄ±tlara indisle eriÅŸilir.", "Tam tersi doÄŸrudur."],
    ["Diziler ilkel, kayÄ±tlar yapÄ±sal bir tiptir.", "Her ikisi de yapÄ±sal (bileÅŸik) birer veri tipidir."]
  ],
  answer: 2,
  summary: "Bir dizi, bir 'koli yumurta' gibidir; iÃ§indeki her ÅŸey aynÄ± tÃ¼rdendir ve sÄ±ralÄ±dÄ±r. Bir kayÄ±t ise bir 'cÃ¼zdan' gibidir; iÃ§inde farklÄ± tÃ¼rden ÅŸeyler (kimlik kartÄ±, kredi kartÄ±, nakit para) bulunur ve her birine kendi etiketiyle (alan adÄ±) eriÅŸilir."
},
{
  q: "17. Bir programlama dilinde `(int)deger` gibi bir ifade kullanarak, programcÄ±nÄ±n bir tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼ bilinÃ§li ve zorunlu olarak yapmasÄ±na ne ad verilir?",
  options: [
    ["Zorunlu DÃ¶nÃ¼ÅŸÃ¼m (Coercion)", "Bu, derleyicinin otomatik ve Ã¶rtÃ¼lÃ¼ olarak yaptÄ±ÄŸÄ± dÃ¶nÃ¼ÅŸÃ¼mdÃ¼r."],
    ["GeniÅŸleyen DÃ¶nÃ¼ÅŸÃ¼m", "Bu, dÃ¶nÃ¼ÅŸÃ¼mÃ¼n gÃ¼venli olup olmadÄ±ÄŸÄ±nÄ± belirten bir tÃ¼rdÃ¼r."],
    ["DÄ±ÅŸsal Tip DÃ¶nÃ¼ÅŸÃ¼mÃ¼ (Explicit Type Conversion / Casting)", "ProgramcÄ±nÄ±n, bir deÄŸiÅŸkenin tipini belirli bir iÅŸlem iÃ§in geÃ§ici olarak baÅŸka bir tipe dÃ¶nÃ¼ÅŸtÃ¼rmesini kodda aÃ§Ä±kÃ§a belirttiÄŸi bu iÅŸleme 'cast' veya 'dÄ±ÅŸsal tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼' denir."],
    ["Tip Denetimi", "Bu bir kontrol iÅŸlemidir, dÃ¶nÃ¼ÅŸÃ¼m deÄŸil."],
    ["Daralan DÃ¶nÃ¼ÅŸÃ¼m", "Bu dÃ¶nÃ¼ÅŸÃ¼m genellikle daralan bir dÃ¶nÃ¼ÅŸÃ¼mdÃ¼r, ancak iÅŸlemin adÄ± 'dÄ±ÅŸsal dÃ¶nÃ¼ÅŸÃ¼m'dÃ¼r."]
  ],
  answer: 2,
  summary: "DÄ±ÅŸsal tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼, programcÄ±nÄ±n derleyiciye 'normalde bu iÅŸleme izin vermediÄŸini biliyorum, ama ben ne yaptÄ±ÄŸÄ±mÄ±n farkÄ±ndayÄ±m ve bu veri kaybÄ± riskini gÃ¶ze alarak bu dÃ¶nÃ¼ÅŸÃ¼mÃ¼n yapÄ±lmasÄ±nÄ± istiyorum' demesidir."
},
{
  q: "18. C++ ve Java gibi dillerde, bir sÄ±nÄ±fÄ±n sadece kendisi ve ondan tÃ¼retilen alt sÄ±nÄ±flar tarafÄ±ndan eriÅŸilebilen Ã¼yelerini tanÄ±mlamak iÃ§in hangi eriÅŸim belirteci kullanÄ±lÄ±r?",
  options: [
    ["`public`", "`public`, eriÅŸim iÃ§in hiÃ§bir sÄ±nÄ±rlama olmadÄ±ÄŸÄ±nÄ± belirtir."],
    ["`private`", "`private`, sadece o sÄ±nÄ±fÄ±n kendi iÃ§inden eriÅŸime izin verir."],
    ["`protected`", "`protected`, bir Ã¼yenin 'aile iÃ§inde' kalmasÄ±nÄ± saÄŸlar. Yani, o sÄ±nÄ±f ve o sÄ±nÄ±ftan miras alan 'Ã§ocuk' sÄ±nÄ±flar tarafÄ±ndan eriÅŸilebilir, ancak dÄ±ÅŸarÄ±dan tamamen baÄŸÄ±msÄ±z sÄ±nÄ±flar tarafÄ±ndan eriÅŸilemez."],
    ["`internal`", "Bu, C#'a Ã¶zgÃ¼ bir eriÅŸim belirtecidir."],
    ["`static`", "`static` bir eriÅŸim belirteci deÄŸildir, bir Ã¼yenin sÄ±nÄ±fa mÄ± yoksa nesneye mi ait olduÄŸunu belirtir."]
  ],
  answer: 2,
  summary: "`protected` Ã¼yeler, bir ailenin sadece kendi Ã¼yelerinin kullandÄ±ÄŸÄ± Ã¶zel eÅŸyalar gibidir. DÄ±ÅŸarÄ±dan gelen bir misafir (baÄŸÄ±msÄ±z sÄ±nÄ±f) bu eÅŸyalarÄ± kullanamaz, ama ailenin Ã§ocuklarÄ± (alt sÄ±nÄ±flar) kullanabilir."
},
{
  q: "19. AÅŸaÄŸÄ±dakilerden hangisi, kullanÄ±cÄ±dan habersiz olarak programÄ±n A ve B gibi kÃ¼Ã§Ã¼k farklÄ±lÄ±klar iÃ§eren sÃ¼rÃ¼mlerini sunarak hangi versiyonun daha Ã§ok tercih edildiÄŸini Ã¶lÃ§en test tÃ¼rÃ¼dÃ¼r?",
  options: [
    ["Alfa Testi", "Bu, iÃ§ ekip tarafÄ±ndan bilinÃ§li olarak yapÄ±lÄ±r."],
    ["Beta Testi", "Bu, gÃ¶nÃ¼llÃ¼ kullanÄ±cÄ±lar tarafÄ±ndan bilinÃ§li olarak yapÄ±lÄ±r."],
    ["Birim Testi", "Bu, kod modÃ¼llerinin testidir."],
    ["A/B Testi", "A/B testi, kullanÄ±cÄ±larÄ±n haberi olmadan, bir dÃ¼ÄŸmenin rengi veya bir menÃ¼nÃ¼n yeri gibi kÃ¼Ã§Ã¼k deÄŸiÅŸikliklerin kullanÄ±cÄ± davranÄ±ÅŸÄ±nÄ± nasÄ±l etkilediÄŸini (daha fazla tÄ±klama, daha fazla satÄ±n alma vb.) istatistiksel olarak Ã¶lÃ§mek iÃ§in kullanÄ±lan bir tekniktir."],
    ["Entegrasyon Testi", "Bu, modÃ¼llerin bir arada Ã§alÄ±ÅŸma testidir."]
  ],
  answer: 3,
  summary: "BÃ¼yÃ¼k web siteleri, 'satÄ±n al' dÃ¼ÄŸmesinin rengini yeÅŸil mi yoksa turuncu mu yapacaklarÄ±na karar vermek iÃ§in A/B testlerini sÄ±kÃ§a kullanÄ±r. KullanÄ±cÄ±larÄ±n yarÄ±sÄ±na yeÅŸil, diÄŸer yarÄ±sÄ±na turuncu dÃ¼ÄŸmeyi gÃ¶sterir ve hangi grubun daha fazla tÄ±klama yaptÄ±ÄŸÄ±nÄ± analiz ederek en etkili tasarÄ±mÄ± seÃ§erler."
},
{
  q: "20. Dinamik baÄŸlama ile, Ã§okyapÄ±lÄ± (polymorphic) bir deÄŸiÅŸkene gÃ¶nderilen bir mesaja hangi metodun yanÄ±t vereceÄŸi ne zaman belirlenir?",
  options: [
    ["Derleme zamanÄ±nda, kod analizi ile", "Bu statik baÄŸlamadÄ±r."],
    ["ProgramcÄ± tarafÄ±ndan kodun en baÅŸÄ±nda", "Bu bir belirleme deÄŸildir."],
    ["Ã‡alÄ±ÅŸma zamanÄ±nda, deÄŸiÅŸkenin o an gÃ¶sterdiÄŸi nesnenin gerÃ§ek tipine gÃ¶re", "Dinamik baÄŸlamanÄ±n gÃ¼cÃ¼ budur. Program Ã§alÄ±ÅŸÄ±rken, `sekil.ciz()` komutuyla karÅŸÄ±laÅŸtÄ±ÄŸÄ±nda, `sekil` deÄŸiÅŸkeninin iÃ§inde o an bir `Daire` mi yoksa bir `Kare` mi olduÄŸuna bakar ve ilgili sÄ±nÄ±fÄ±n `ciz()` metodunu Ã§aÄŸÄ±rÄ±r."],
    ["HiÃ§bir zaman belirlenmez, rastgele bir metot Ã§alÄ±ÅŸÄ±r.", "Bu kaosa yol aÃ§ardÄ±."],
    ["Ä°ÅŸletim sistemi tarafÄ±ndan, program Ã§alÄ±ÅŸmadan Ã¶nce", "Bu mÃ¼mkÃ¼n deÄŸildir."]
  ],
  answer: 2,
  summary: "Dinamik baÄŸlama, nesneye yÃ¶nelik programlamanÄ±n 'akÄ±llÄ±' davranmasÄ±nÄ± saÄŸlayan mekanizmadÄ±r. Kodun, duruma gÃ¶re esnek davranmasÄ±na ve doÄŸru eylemi Ã§alÄ±ÅŸma anÄ±nda seÃ§mesine olanak tanÄ±r. Bu, Ã¶zellikle metod Ã¼zerine yazma (overriding) ile birlikte kullanÄ±lÄ±r."
}    
  ];

  const quizDiv = document.getElementById('quiz');
  const optionLabels = ['A)', 'B)', 'C)', 'D)', 'E)'];
  const userAnswers = new Array(questions.length).fill(null);


  questions.forEach((qObj, index) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'question-container';
    questionContainer.id = `question-${index}`;

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = qObj.q;
    questionContainer.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options-group';

    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback';
    feedbackDiv.style.display = 'none'; // Initially hidden

    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'summary';
    summaryDiv.style.display = 'none'; // Initially hidden


    qObj.options.forEach((opt, i) => {
      const optDiv = document.createElement('div');
      optDiv.className = 'option';
      optDiv.textContent = `${optionLabels[i]} ${opt[0]}`;
      optDiv.onclick = () => {
        // Clear previous selection visuals for this question
        const allOptsInGroup = optsDiv.querySelectorAll('.option');
        allOptsInGroup.forEach(el => el.classList.remove('selected'));
        optDiv.classList.add('selected'); // Mark as selected

        userAnswers[index] = i; // Store user's answer

        // Show feedback immediately
        const feedbackText = opt[1] || (i === qObj.answer ? "DoÄŸru cevap!" : "YanlÄ±ÅŸ cevap."); // Fallback feedback
        feedbackDiv.className = 'feedback ' + (i === qObj.answer ? 'correct' : 'incorrect');
        feedbackDiv.style.display = 'block';
        feedbackDiv.textContent = (i === qObj.answer ? 'âœ”ï¸ DoÄŸru: ' : 'âŒ YanlÄ±ÅŸ: ') + feedbackText;


        if (i === qObj.answer && qObj.summary) {
          summaryDiv.style.display = 'block';
          summaryDiv.textContent = 'ðŸ’¡ ' + qObj.summary;
        } else {
          summaryDiv.style.display = 'none';
        }
      };
      optsDiv.appendChild(optDiv);
    });

    questionContainer.appendChild(optsDiv);
    questionContainer.appendChild(feedbackDiv);
    questionContainer.appendChild(summaryDiv);
    quizDiv.appendChild(questionContainer);
  });

  function showResults() {
    let correctCount = 0;
    userAnswers.forEach((answer, index) => {
        if (answer !== null && answer === questions[index].answer) {
            correctCount++;
        }
    });

    const totalQuestions = questions.length;
    const scorePercentage = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(2) : 0;

    document.getElementById('total-questions').textContent = totalQuestions;
    document.getElementById('correct-answers').textContent = correctCount;
    document.getElementById('score-percentage').textContent = scorePercentage;
    document.getElementById('results-summary').style.display = 'block';

    // Scroll to results
    document.getElementById('results-summary').scrollIntoView({ behavior: 'smooth' });
  }

</script>
</body>
</html>